# This file was auto-generated by Fern from our API Definition.

import datetime as dt
import typing

from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.request_options import RequestOptions
from ..types.balance_definition import BalanceDefinition
from ..types.balance_limit import BalanceLimit
from ..types.transaction import Transaction
from .raw_client import AsyncRawBalanceClient, RawBalanceClient
from .types.create_balance_limit_request_constraint_type import CreateBalanceLimitRequestConstraintType
from .types.create_balance_limit_request_duration_unit import CreateBalanceLimitRequestDurationUnit
from .types.create_balance_limit_request_transaction_type import CreateBalanceLimitRequestTransactionType
from .types.create_balance_order_response import CreateBalanceOrderResponse
from .types.get_balance_definition_list_request_sort import GetBalanceDefinitionListRequestSort
from .types.get_balance_definition_list_request_sort_field import GetBalanceDefinitionListRequestSortField
from .types.get_balance_definition_list_request_version import GetBalanceDefinitionListRequestVersion
from .types.get_balance_definition_list_response import GetBalanceDefinitionListResponse
from .types.get_balance_definition_request_version import GetBalanceDefinitionRequestVersion
from .types.get_balance_limit_request_version import GetBalanceLimitRequestVersion
from .types.get_contact_balances_response import GetContactBalancesResponse
from .types.get_loyalty_balance_programs_pid_transaction_history_request_sort import (
    GetLoyaltyBalanceProgramsPidTransactionHistoryRequestSort,
)
from .types.get_loyalty_balance_programs_pid_transaction_history_request_sort_field import (
    GetLoyaltyBalanceProgramsPidTransactionHistoryRequestSortField,
)
from .types.get_loyalty_balance_programs_pid_transaction_history_response import (
    GetLoyaltyBalanceProgramsPidTransactionHistoryResponse,
)
from .types.get_subscription_balances_response import GetSubscriptionBalancesResponse
from .types.post_loyalty_balance_programs_pid_balance_definitions_request_balance_availability_duration_modifier import (
    PostLoyaltyBalanceProgramsPidBalanceDefinitionsRequestBalanceAvailabilityDurationModifier,
)
from .types.post_loyalty_balance_programs_pid_balance_definitions_request_balance_availability_duration_unit import (
    PostLoyaltyBalanceProgramsPidBalanceDefinitionsRequestBalanceAvailabilityDurationUnit,
)
from .types.post_loyalty_balance_programs_pid_balance_definitions_request_balance_option_amount_overtaking_strategy import (
    PostLoyaltyBalanceProgramsPidBalanceDefinitionsRequestBalanceOptionAmountOvertakingStrategy,
)
from .types.post_loyalty_balance_programs_pid_balance_definitions_request_balance_option_credit_rounding import (
    PostLoyaltyBalanceProgramsPidBalanceDefinitionsRequestBalanceOptionCreditRounding,
)
from .types.post_loyalty_balance_programs_pid_balance_definitions_request_balance_option_debit_rounding import (
    PostLoyaltyBalanceProgramsPidBalanceDefinitionsRequestBalanceOptionDebitRounding,
)
from .types.post_loyalty_balance_programs_pid_balance_definitions_request_unit import (
    PostLoyaltyBalanceProgramsPidBalanceDefinitionsRequestUnit,
)
from .types.post_loyalty_balance_programs_pid_subscriptions_cid_balances_response import (
    PostLoyaltyBalanceProgramsPidSubscriptionsCidBalancesResponse,
)
from .types.update_balance_definition_request_balance_availability_duration_modifier import (
    UpdateBalanceDefinitionRequestBalanceAvailabilityDurationModifier,
)
from .types.update_balance_definition_request_balance_availability_duration_unit import (
    UpdateBalanceDefinitionRequestBalanceAvailabilityDurationUnit,
)
from .types.update_balance_definition_request_balance_option_amount_overtaking_strategy import (
    UpdateBalanceDefinitionRequestBalanceOptionAmountOvertakingStrategy,
)
from .types.update_balance_definition_request_balance_option_credit_rounding import (
    UpdateBalanceDefinitionRequestBalanceOptionCreditRounding,
)
from .types.update_balance_definition_request_balance_option_debit_rounding import (
    UpdateBalanceDefinitionRequestBalanceOptionDebitRounding,
)
from .types.update_balance_definition_request_unit import UpdateBalanceDefinitionRequestUnit
from .types.update_balance_limit_request_constraint_type import UpdateBalanceLimitRequestConstraintType
from .types.update_balance_limit_request_duration_unit import UpdateBalanceLimitRequestDurationUnit
from .types.update_balance_limit_request_transaction_type import UpdateBalanceLimitRequestTransactionType

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class BalanceClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._raw_client = RawBalanceClient(client_wrapper=client_wrapper)

    @property
    def with_raw_response(self) -> RawBalanceClient:
        """
        Retrieves a raw implementation of this client that returns raw responses.

        Returns
        -------
        RawBalanceClient
        """
        return self._raw_client

    def get_active_balances_api(
        self,
        pid: str,
        *,
        contact_id: int,
        balance_definition_id: str,
        limit: typing.Optional[int] = None,
        offset: typing.Optional[int] = None,
        sort_field: typing.Optional[str] = None,
        sort: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> BalanceLimit:
        """
        Returns Active Balances

        Parameters
        ----------
        pid : str
            Loyalty Program Id

        contact_id : int
            Contact ID

        balance_definition_id : str
            Balance Definition ID

        limit : typing.Optional[int]
            Limit

        offset : typing.Optional[int]
            Offset

        sort_field : typing.Optional[str]
            Sort Field

        sort : typing.Optional[str]
            Sort Order

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        BalanceLimit
            Successful retrieval of active balance

        Examples
        --------
        from brevo import Brevo

        client = Brevo(
            api_key="YOUR_API_KEY",
        )
        client.balance.get_active_balances_api(
            pid="pid",
            contact_id=1,
            balance_definition_id="balance_definition_id",
        )
        """
        _response = self._raw_client.get_active_balances_api(
            pid,
            contact_id=contact_id,
            balance_definition_id=balance_definition_id,
            limit=limit,
            offset=offset,
            sort_field=sort_field,
            sort=sort,
            request_options=request_options,
        )
        return _response.data

    def get_balance_definition_list(
        self,
        pid: str,
        *,
        limit: typing.Optional[int] = None,
        offset: typing.Optional[int] = None,
        sort_field: typing.Optional[GetBalanceDefinitionListRequestSortField] = None,
        sort: typing.Optional[GetBalanceDefinitionListRequestSort] = None,
        version: typing.Optional[GetBalanceDefinitionListRequestVersion] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GetBalanceDefinitionListResponse:
        """
        Returns balance definition page

        Parameters
        ----------
        pid : str
            Loyalty Program Id

        limit : typing.Optional[int]
            Limit the number of records returned

        offset : typing.Optional[int]
            Offset to paginate records

        sort_field : typing.Optional[GetBalanceDefinitionListRequestSortField]
            Field to sort by

        sort : typing.Optional[GetBalanceDefinitionListRequestSort]
            Sort direction

        version : typing.Optional[GetBalanceDefinitionListRequestVersion]
            Version

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GetBalanceDefinitionListResponse
            Successful retrieval of balance definition page

        Examples
        --------
        from brevo import Brevo

        client = Brevo(
            api_key="YOUR_API_KEY",
        )
        client.balance.get_balance_definition_list(
            pid="pid",
        )
        """
        _response = self._raw_client.get_balance_definition_list(
            pid,
            limit=limit,
            offset=offset,
            sort_field=sort_field,
            sort=sort,
            version=version,
            request_options=request_options,
        )
        return _response.data

    def create_balance_definition(
        self,
        pid: str,
        *,
        name: str,
        unit: PostLoyaltyBalanceProgramsPidBalanceDefinitionsRequestUnit,
        balance_availability_duration_modifier: typing.Optional[
            PostLoyaltyBalanceProgramsPidBalanceDefinitionsRequestBalanceAvailabilityDurationModifier
        ] = OMIT,
        balance_availability_duration_unit: typing.Optional[
            PostLoyaltyBalanceProgramsPidBalanceDefinitionsRequestBalanceAvailabilityDurationUnit
        ] = OMIT,
        balance_availability_duration_value: typing.Optional[int] = OMIT,
        balance_expiration_date: typing.Optional[dt.date] = OMIT,
        balance_option_amount_overtaking_strategy: typing.Optional[
            PostLoyaltyBalanceProgramsPidBalanceDefinitionsRequestBalanceOptionAmountOvertakingStrategy
        ] = OMIT,
        balance_option_credit_rounding: typing.Optional[
            PostLoyaltyBalanceProgramsPidBalanceDefinitionsRequestBalanceOptionCreditRounding
        ] = OMIT,
        balance_option_debit_rounding: typing.Optional[
            PostLoyaltyBalanceProgramsPidBalanceDefinitionsRequestBalanceOptionDebitRounding
        ] = OMIT,
        description: typing.Optional[str] = OMIT,
        image_ref: typing.Optional[str] = OMIT,
        max_amount: typing.Optional[float] = OMIT,
        max_credit_amount_limit: typing.Optional[float] = OMIT,
        max_debit_amount_limit: typing.Optional[float] = OMIT,
        meta: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        min_amount: typing.Optional[float] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> BalanceDefinition:
        """
        Creates balance definition and returns information

        Parameters
        ----------
        pid : str
            Loyalty Program Id

        name : str
            Name of the balance definition.

        unit : PostLoyaltyBalanceProgramsPidBalanceDefinitionsRequestUnit
            Unit of balance measurement.

        balance_availability_duration_modifier : typing.Optional[PostLoyaltyBalanceProgramsPidBalanceDefinitionsRequestBalanceAvailabilityDurationModifier]
            Defines when the balance expires within the selected duration.

        balance_availability_duration_unit : typing.Optional[PostLoyaltyBalanceProgramsPidBalanceDefinitionsRequestBalanceAvailabilityDurationUnit]
            Unit of time for balance validity.

        balance_availability_duration_value : typing.Optional[int]
            Number of time units before the balance expires.

        balance_expiration_date : typing.Optional[dt.date]
            Fixed expiration date (`dd/mm` format) as an alternative to duration-based expiry.

        balance_option_amount_overtaking_strategy : typing.Optional[PostLoyaltyBalanceProgramsPidBalanceDefinitionsRequestBalanceOptionAmountOvertakingStrategy]
            Defines whether partial credit is allowed when reaching max balance.

        balance_option_credit_rounding : typing.Optional[PostLoyaltyBalanceProgramsPidBalanceDefinitionsRequestBalanceOptionCreditRounding]
            Defines rounding strategy for credit transactions.

        balance_option_debit_rounding : typing.Optional[PostLoyaltyBalanceProgramsPidBalanceDefinitionsRequestBalanceOptionDebitRounding]
            Defines rounding strategy for debit transactions.

        description : typing.Optional[str]
            Short description of the balance definition.

        image_ref : typing.Optional[str]
            URL of an optional image reference.

        max_amount : typing.Optional[float]
            Maximum allowable balance amount.

        max_credit_amount_limit : typing.Optional[float]
            Maximum credit allowed per operation.

        max_debit_amount_limit : typing.Optional[float]
            Maximum debit allowed per operation.

        meta : typing.Optional[typing.Dict[str, typing.Any]]
            Additional metadata for the balance definition.

        min_amount : typing.Optional[float]
            Minimum allowable balance amount.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        BalanceDefinition
            Successful creation of balance definition

        Examples
        --------
        from brevo import Brevo

        client = Brevo(
            api_key="YOUR_API_KEY",
        )
        client.balance.create_balance_definition(
            pid="pid",
            name="name",
            unit="POINTS",
        )
        """
        _response = self._raw_client.create_balance_definition(
            pid,
            name=name,
            unit=unit,
            balance_availability_duration_modifier=balance_availability_duration_modifier,
            balance_availability_duration_unit=balance_availability_duration_unit,
            balance_availability_duration_value=balance_availability_duration_value,
            balance_expiration_date=balance_expiration_date,
            balance_option_amount_overtaking_strategy=balance_option_amount_overtaking_strategy,
            balance_option_credit_rounding=balance_option_credit_rounding,
            balance_option_debit_rounding=balance_option_debit_rounding,
            description=description,
            image_ref=image_ref,
            max_amount=max_amount,
            max_credit_amount_limit=max_credit_amount_limit,
            max_debit_amount_limit=max_debit_amount_limit,
            meta=meta,
            min_amount=min_amount,
            request_options=request_options,
        )
        return _response.data

    def get_balance_definition(
        self,
        pid: str,
        bdid: str,
        *,
        version: typing.Optional[GetBalanceDefinitionRequestVersion] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> BalanceDefinition:
        """
        Returns balance definition

        Parameters
        ----------
        pid : str
            Loyalty Program Id

        bdid : str
            Balance Definition Id

        version : typing.Optional[GetBalanceDefinitionRequestVersion]
            Version

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        BalanceDefinition
            Successful retrieval of balance definition

        Examples
        --------
        from brevo import Brevo

        client = Brevo(
            api_key="YOUR_API_KEY",
        )
        client.balance.get_balance_definition(
            pid="pid",
            bdid="bdid",
        )
        """
        _response = self._raw_client.get_balance_definition(pid, bdid, version=version, request_options=request_options)
        return _response.data

    def update_balance_definition(
        self,
        pid: str,
        bdid: str,
        *,
        name: str,
        unit: UpdateBalanceDefinitionRequestUnit,
        balance_availability_duration_modifier: typing.Optional[
            UpdateBalanceDefinitionRequestBalanceAvailabilityDurationModifier
        ] = OMIT,
        balance_availability_duration_unit: typing.Optional[
            UpdateBalanceDefinitionRequestBalanceAvailabilityDurationUnit
        ] = OMIT,
        balance_availability_duration_value: typing.Optional[int] = OMIT,
        balance_expiration_date: typing.Optional[str] = OMIT,
        balance_option_amount_overtaking_strategy: typing.Optional[
            UpdateBalanceDefinitionRequestBalanceOptionAmountOvertakingStrategy
        ] = OMIT,
        balance_option_credit_rounding: typing.Optional[
            UpdateBalanceDefinitionRequestBalanceOptionCreditRounding
        ] = OMIT,
        balance_option_debit_rounding: typing.Optional[UpdateBalanceDefinitionRequestBalanceOptionDebitRounding] = OMIT,
        description: typing.Optional[str] = OMIT,
        image_ref: typing.Optional[str] = OMIT,
        max_amount: typing.Optional[float] = OMIT,
        max_credit_amount_limit: typing.Optional[float] = OMIT,
        max_debit_amount_limit: typing.Optional[float] = OMIT,
        meta: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        min_amount: typing.Optional[float] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> BalanceDefinition:
        """
        Updates Balance definition

        Parameters
        ----------
        pid : str
            Loyalty Program Id

        bdid : str
            Balance Definition Id

        name : str
            Name of the balance definition.

        unit : UpdateBalanceDefinitionRequestUnit
            Unit of balance measurement.

        balance_availability_duration_modifier : typing.Optional[UpdateBalanceDefinitionRequestBalanceAvailabilityDurationModifier]
            Defines when the balance expires within the selected duration.

        balance_availability_duration_unit : typing.Optional[UpdateBalanceDefinitionRequestBalanceAvailabilityDurationUnit]
            Unit of time for balance validity.

        balance_availability_duration_value : typing.Optional[int]
            Number of time units before the balance expires.

        balance_expiration_date : typing.Optional[str]
            Expiration date (`dd/mm` format) or empty if not applicable.

        balance_option_amount_overtaking_strategy : typing.Optional[UpdateBalanceDefinitionRequestBalanceOptionAmountOvertakingStrategy]
            Defines whether partial credit is allowed when reaching max balance.

        balance_option_credit_rounding : typing.Optional[UpdateBalanceDefinitionRequestBalanceOptionCreditRounding]
            Rounding strategy for credit transactions.

        balance_option_debit_rounding : typing.Optional[UpdateBalanceDefinitionRequestBalanceOptionDebitRounding]
            Rounding strategy for debit transactions.

        description : typing.Optional[str]
            Short description of the balance definition.

        image_ref : typing.Optional[str]
            URL of an optional image reference.

        max_amount : typing.Optional[float]
            Maximum allowable balance amount.

        max_credit_amount_limit : typing.Optional[float]
            Maximum credit allowed per operation.

        max_debit_amount_limit : typing.Optional[float]
            Maximum debit allowed per operation.

        meta : typing.Optional[typing.Dict[str, typing.Any]]
            Optional metadata for the balance definition.

        min_amount : typing.Optional[float]
            Minimum allowable balance amount.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        BalanceDefinition
            Successful update of balance definition

        Examples
        --------
        from brevo import Brevo

        client = Brevo(
            api_key="YOUR_API_KEY",
        )
        client.balance.update_balance_definition(
            pid="pid",
            bdid="bdid",
            name="name",
            unit="POINTS",
        )
        """
        _response = self._raw_client.update_balance_definition(
            pid,
            bdid,
            name=name,
            unit=unit,
            balance_availability_duration_modifier=balance_availability_duration_modifier,
            balance_availability_duration_unit=balance_availability_duration_unit,
            balance_availability_duration_value=balance_availability_duration_value,
            balance_expiration_date=balance_expiration_date,
            balance_option_amount_overtaking_strategy=balance_option_amount_overtaking_strategy,
            balance_option_credit_rounding=balance_option_credit_rounding,
            balance_option_debit_rounding=balance_option_debit_rounding,
            description=description,
            image_ref=image_ref,
            max_amount=max_amount,
            max_credit_amount_limit=max_credit_amount_limit,
            max_debit_amount_limit=max_debit_amount_limit,
            meta=meta,
            min_amount=min_amount,
            request_options=request_options,
        )
        return _response.data

    def delete_balance_definition(
        self, pid: str, bdid: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> None:
        """
        Delete Balance definition

        Parameters
        ----------
        pid : str
            Loyalty Program Id

        bdid : str
            Balance Definition Id

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from brevo import Brevo

        client = Brevo(
            api_key="YOUR_API_KEY",
        )
        client.balance.delete_balance_definition(
            pid="pid",
            bdid="bdid",
        )
        """
        _response = self._raw_client.delete_balance_definition(pid, bdid, request_options=request_options)
        return _response.data

    def create_balance_limit(
        self,
        pid: str,
        bdid: str,
        *,
        constraint_type: CreateBalanceLimitRequestConstraintType,
        duration_unit: CreateBalanceLimitRequestDurationUnit,
        duration_value: int,
        transaction_type: CreateBalanceLimitRequestTransactionType,
        value: int,
        sliding_schedule: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> BalanceLimit:
        """
        Creates balance limit and sends the created UUID along with the data

        Parameters
        ----------
        pid : str
            Loyalty Program Id

        bdid : str
            Balance Definition Id

        constraint_type : CreateBalanceLimitRequestConstraintType
            Defines whether the limit applies to transaction count or amount.

        duration_unit : CreateBalanceLimitRequestDurationUnit
            Unit of time for which the limit is applicable.

        duration_value : int
            Number of time units for the balance limit.

        transaction_type : CreateBalanceLimitRequestTransactionType
            Specifies whether the limit applies to credit or debit transactions.

        value : int
            Maximum allowed value for the specified constraint type.

        sliding_schedule : typing.Optional[bool]
            Determines if the limit resets on a rolling schedule.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        BalanceLimit
            Successful creation of balance limit

        Examples
        --------
        from brevo import Brevo

        client = Brevo(
            api_key="YOUR_API_KEY",
        )
        client.balance.create_balance_limit(
            pid="pid",
            bdid="bdid",
            constraint_type="transaction",
            duration_unit="day",
            duration_value=1,
            transaction_type="credit",
            value=1,
        )
        """
        _response = self._raw_client.create_balance_limit(
            pid,
            bdid,
            constraint_type=constraint_type,
            duration_unit=duration_unit,
            duration_value=duration_value,
            transaction_type=transaction_type,
            value=value,
            sliding_schedule=sliding_schedule,
            request_options=request_options,
        )
        return _response.data

    def get_balance_limit(
        self,
        pid: str,
        bdid: str,
        blid: str,
        *,
        version: typing.Optional[GetBalanceLimitRequestVersion] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> BalanceLimit:
        """
        Fetches balance limits and send the created UUID along with the data

        Parameters
        ----------
        pid : str
            Loyalty Program Id

        bdid : str
            Balance Definition Id

        blid : str
            Balance Limit Id

        version : typing.Optional[GetBalanceLimitRequestVersion]
            Version

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        BalanceLimit
            Successful retrieval of balance limit

        Examples
        --------
        from brevo import Brevo

        client = Brevo(
            api_key="YOUR_API_KEY",
        )
        client.balance.get_balance_limit(
            pid="pid",
            bdid="bdid",
            blid="blid",
        )
        """
        _response = self._raw_client.get_balance_limit(
            pid, bdid, blid, version=version, request_options=request_options
        )
        return _response.data

    def update_balance_limit(
        self,
        pid: str,
        bdid: str,
        blid: str,
        *,
        constraint_type: UpdateBalanceLimitRequestConstraintType,
        duration_unit: UpdateBalanceLimitRequestDurationUnit,
        duration_value: int,
        transaction_type: UpdateBalanceLimitRequestTransactionType,
        value: int,
        sliding_schedule: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> BalanceLimit:
        """
        Updates balance limit

        Parameters
        ----------
        pid : str
            Loyalty Program Id

        bdid : str
            Balance Definition Id

        blid : str
            Balance Limit Id

        constraint_type : UpdateBalanceLimitRequestConstraintType
            Defines whether the limit applies to transaction count or amount.

        duration_unit : UpdateBalanceLimitRequestDurationUnit
            Unit of time for which the limit is applicable.

        duration_value : int
            Number of time units for the balance limit.

        transaction_type : UpdateBalanceLimitRequestTransactionType
            Specifies whether the limit applies to credit or debit transactions.

        value : int
            Maximum allowed value for the specified constraint type.

        sliding_schedule : typing.Optional[bool]
            Determines if the limit resets on a rolling schedule.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        BalanceLimit
            Successful update of balance limit

        Examples
        --------
        from brevo import Brevo

        client = Brevo(
            api_key="YOUR_API_KEY",
        )
        client.balance.update_balance_limit(
            pid="pid",
            bdid="bdid",
            blid="blid",
            constraint_type="transaction",
            duration_unit="day",
            duration_value=1,
            transaction_type="credit",
            value=1,
        )
        """
        _response = self._raw_client.update_balance_limit(
            pid,
            bdid,
            blid,
            constraint_type=constraint_type,
            duration_unit=duration_unit,
            duration_value=duration_value,
            transaction_type=transaction_type,
            value=value,
            sliding_schedule=sliding_schedule,
            request_options=request_options,
        )
        return _response.data

    def delete_balance_limit(
        self, pid: str, bdid: str, blid: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> None:
        """
        Delete balance limit

        Parameters
        ----------
        pid : str
            Loyalty Program Id

        bdid : str
            Balance Definition Id

        blid : str
            Balance Limit Id

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from brevo import Brevo

        client = Brevo(
            api_key="YOUR_API_KEY",
        )
        client.balance.delete_balance_limit(
            pid="pid",
            bdid="bdid",
            blid="blid",
        )
        """
        _response = self._raw_client.delete_balance_limit(pid, bdid, blid, request_options=request_options)
        return _response.data

    def get_contact_balances(
        self, pid: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> GetContactBalancesResponse:
        """
        Returns balance list

        Parameters
        ----------
        pid : str
            Loyalty Program Id

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GetContactBalancesResponse
            Successful retrieval of contact balance

        Examples
        --------
        from brevo import Brevo

        client = Brevo(
            api_key="YOUR_API_KEY",
        )
        client.balance.get_contact_balances(
            pid="pid",
        )
        """
        _response = self._raw_client.get_contact_balances(pid, request_options=request_options)
        return _response.data

    def create_balance_order(
        self,
        pid: str,
        *,
        amount: float,
        balance_definition_id: str,
        contact_id: int,
        due_at: str,
        source: str,
        expires_at: typing.Optional[str] = OMIT,
        meta: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CreateBalanceOrderResponse:
        """
        Returns created order

        Parameters
        ----------
        pid : str
            Loyalty Program Id

        amount : float
            Order amount (must be non-zero).

        balance_definition_id : str
            Unique identifier (UUID) of the associated balance definition.

        contact_id : int
            Unique identifier of the contact placing the order (must be â‰¥ 1).

        due_at : str
            RFC3339 timestamp specifying when the order is due.

        source : str
            Specifies the origin of the order (`engine` or `user`).

        expires_at : typing.Optional[str]
            Optional RFC3339 timestamp defining order expiration.

        meta : typing.Optional[typing.Dict[str, typing.Any]]
            Optional metadata associated with the order.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CreateBalanceOrderResponse
            Successful creation of order

        Examples
        --------
        from brevo import Brevo

        client = Brevo(
            api_key="YOUR_API_KEY",
        )
        client.balance.create_balance_order(
            pid="pid",
            amount=1.1,
            balance_definition_id="balanceDefinitionId",
            contact_id=1,
            due_at="dueAt",
            source="source",
        )
        """
        _response = self._raw_client.create_balance_order(
            pid,
            amount=amount,
            balance_definition_id=balance_definition_id,
            contact_id=contact_id,
            due_at=due_at,
            source=source,
            expires_at=expires_at,
            meta=meta,
            request_options=request_options,
        )
        return _response.data

    def get_subscription_balances(
        self, pid: str, cid: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> GetSubscriptionBalancesResponse:
        """
        Returns subscription balances

        Parameters
        ----------
        pid : str
            Loyalty Program Id

        cid : str
            Contact Id

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GetSubscriptionBalancesResponse
            Successful retrieval of contact balance

        Examples
        --------
        from brevo import Brevo

        client = Brevo(
            api_key="YOUR_API_KEY",
        )
        client.balance.get_subscription_balances(
            pid="pid",
            cid="cid",
        )
        """
        _response = self._raw_client.get_subscription_balances(pid, cid, request_options=request_options)
        return _response.data

    def create_subscription_balances(
        self, pid: str, cid: str, *, balance_definition_id: str, request_options: typing.Optional[RequestOptions] = None
    ) -> PostLoyaltyBalanceProgramsPidSubscriptionsCidBalancesResponse:
        """
        Creates a balance for a contact

        Parameters
        ----------
        pid : str
            Loyalty Program Id

        cid : str
            Contact Id

        balance_definition_id : str
            Unique identifier (UUID) of the balance definition associated with the new balance.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        PostLoyaltyBalanceProgramsPidSubscriptionsCidBalancesResponse
            Successful creation of balance

        Examples
        --------
        from brevo import Brevo

        client = Brevo(
            api_key="YOUR_API_KEY",
        )
        client.balance.create_subscription_balances(
            pid="pid",
            cid="cid",
            balance_definition_id="balanceDefinitionId",
        )
        """
        _response = self._raw_client.create_subscription_balances(
            pid, cid, balance_definition_id=balance_definition_id, request_options=request_options
        )
        return _response.data

    def get_transaction_history_api(
        self,
        pid: str,
        *,
        contact_id: int,
        balance_definition_id: str,
        limit: typing.Optional[int] = None,
        offset: typing.Optional[int] = None,
        sort_field: typing.Optional[GetLoyaltyBalanceProgramsPidTransactionHistoryRequestSortField] = None,
        sort: typing.Optional[GetLoyaltyBalanceProgramsPidTransactionHistoryRequestSort] = None,
        filters: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GetLoyaltyBalanceProgramsPidTransactionHistoryResponse:
        """
        Returns transaction history

        Parameters
        ----------
        pid : str
            Loyalty Program Id

        contact_id : int
            Contact ID

        balance_definition_id : str
            Balance Definition ID

        limit : typing.Optional[int]
            Limit the number of records returned

        offset : typing.Optional[int]
            Skip a number of records

        sort_field : typing.Optional[GetLoyaltyBalanceProgramsPidTransactionHistoryRequestSortField]
            Field to sort by

        sort : typing.Optional[GetLoyaltyBalanceProgramsPidTransactionHistoryRequestSort]
            Sort order, either asc or desc

        filters : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            Filters to apply

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GetLoyaltyBalanceProgramsPidTransactionHistoryResponse
            Successful retrieval of transaction history

        Examples
        --------
        from brevo import Brevo

        client = Brevo(
            api_key="YOUR_API_KEY",
        )
        client.balance.get_transaction_history_api(
            pid="pid",
            contact_id=1,
            balance_definition_id="balance_definition_id",
        )
        """
        _response = self._raw_client.get_transaction_history_api(
            pid,
            contact_id=contact_id,
            balance_definition_id=balance_definition_id,
            limit=limit,
            offset=offset,
            sort_field=sort_field,
            sort=sort,
            filters=filters,
            request_options=request_options,
        )
        return _response.data

    def begin_transaction(
        self,
        pid: str,
        *,
        amount: float,
        balance_definition_id: str,
        loyalty_subscription_id: typing.Optional[str] = OMIT,
        auto_complete: typing.Optional[bool] = OMIT,
        balance_expiry_in_minutes: typing.Optional[int] = OMIT,
        contact_id: typing.Optional[int] = OMIT,
        event_time: typing.Optional[str] = OMIT,
        meta: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        ttl: typing.Optional[int] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Transaction:
        """
        Creates new transaction and returns information

        Parameters
        ----------
        pid : str
            Loyalty Program Id

        amount : float
            Transaction amount (must be provided).

        balance_definition_id : str
            Unique identifier (UUID) of the associated balance definition.

        loyalty_subscription_id : typing.Optional[str]
            Unique identifier for the loyalty subscription (required unless `contactId` is provided).

        auto_complete : typing.Optional[bool]
            Whether the transaction should be automatically completed.

        balance_expiry_in_minutes : typing.Optional[int]
            Optional expiry time for the balance in minutes (must be greater than 0 if provided).

        contact_id : typing.Optional[int]
            Unique identifier of the contact involved in the transaction (required unless `LoyaltySubscriptionId` is provided).

        event_time : typing.Optional[str]
            Optional timestamp specifying when the transaction occurred.

        meta : typing.Optional[typing.Dict[str, typing.Any]]
            Optional metadata associated with the transaction.

        ttl : typing.Optional[int]
            Optional time-to-live for the transaction (must be greater than 0 if provided).

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Transaction
            Transaction information

        Examples
        --------
        from brevo import Brevo

        client = Brevo(
            api_key="YOUR_API_KEY",
        )
        client.balance.begin_transaction(
            pid="pid",
            amount=1.1,
            balance_definition_id="balanceDefinitionId",
        )
        """
        _response = self._raw_client.begin_transaction(
            pid,
            amount=amount,
            balance_definition_id=balance_definition_id,
            loyalty_subscription_id=loyalty_subscription_id,
            auto_complete=auto_complete,
            balance_expiry_in_minutes=balance_expiry_in_minutes,
            contact_id=contact_id,
            event_time=event_time,
            meta=meta,
            ttl=ttl,
            request_options=request_options,
        )
        return _response.data

    def cancel_transaction(
        self, pid: str, tid: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> Transaction:
        """
        Cancels transaction

        Parameters
        ----------
        pid : str
            Loyalty Program Id

        tid : str
            Transaction Id

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Transaction
            Transaction information

        Examples
        --------
        from brevo import Brevo

        client = Brevo(
            api_key="YOUR_API_KEY",
        )
        client.balance.cancel_transaction(
            pid="pid",
            tid="tid",
        )
        """
        _response = self._raw_client.cancel_transaction(pid, tid, request_options=request_options)
        return _response.data

    def complete_transaction(
        self, pid: str, tid: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> Transaction:
        """
        Completes transaction

        Parameters
        ----------
        pid : str
            Loyalty Program Id

        tid : str
            Transaction Id

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Transaction
            Transaction information

        Examples
        --------
        from brevo import Brevo

        client = Brevo(
            api_key="YOUR_API_KEY",
        )
        client.balance.complete_transaction(
            pid="pid",
            tid="tid",
        )
        """
        _response = self._raw_client.complete_transaction(pid, tid, request_options=request_options)
        return _response.data


class AsyncBalanceClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._raw_client = AsyncRawBalanceClient(client_wrapper=client_wrapper)

    @property
    def with_raw_response(self) -> AsyncRawBalanceClient:
        """
        Retrieves a raw implementation of this client that returns raw responses.

        Returns
        -------
        AsyncRawBalanceClient
        """
        return self._raw_client

    async def get_active_balances_api(
        self,
        pid: str,
        *,
        contact_id: int,
        balance_definition_id: str,
        limit: typing.Optional[int] = None,
        offset: typing.Optional[int] = None,
        sort_field: typing.Optional[str] = None,
        sort: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> BalanceLimit:
        """
        Returns Active Balances

        Parameters
        ----------
        pid : str
            Loyalty Program Id

        contact_id : int
            Contact ID

        balance_definition_id : str
            Balance Definition ID

        limit : typing.Optional[int]
            Limit

        offset : typing.Optional[int]
            Offset

        sort_field : typing.Optional[str]
            Sort Field

        sort : typing.Optional[str]
            Sort Order

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        BalanceLimit
            Successful retrieval of active balance

        Examples
        --------
        import asyncio

        from brevo import AsyncBrevo

        client = AsyncBrevo(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.balance.get_active_balances_api(
                pid="pid",
                contact_id=1,
                balance_definition_id="balance_definition_id",
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.get_active_balances_api(
            pid,
            contact_id=contact_id,
            balance_definition_id=balance_definition_id,
            limit=limit,
            offset=offset,
            sort_field=sort_field,
            sort=sort,
            request_options=request_options,
        )
        return _response.data

    async def get_balance_definition_list(
        self,
        pid: str,
        *,
        limit: typing.Optional[int] = None,
        offset: typing.Optional[int] = None,
        sort_field: typing.Optional[GetBalanceDefinitionListRequestSortField] = None,
        sort: typing.Optional[GetBalanceDefinitionListRequestSort] = None,
        version: typing.Optional[GetBalanceDefinitionListRequestVersion] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GetBalanceDefinitionListResponse:
        """
        Returns balance definition page

        Parameters
        ----------
        pid : str
            Loyalty Program Id

        limit : typing.Optional[int]
            Limit the number of records returned

        offset : typing.Optional[int]
            Offset to paginate records

        sort_field : typing.Optional[GetBalanceDefinitionListRequestSortField]
            Field to sort by

        sort : typing.Optional[GetBalanceDefinitionListRequestSort]
            Sort direction

        version : typing.Optional[GetBalanceDefinitionListRequestVersion]
            Version

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GetBalanceDefinitionListResponse
            Successful retrieval of balance definition page

        Examples
        --------
        import asyncio

        from brevo import AsyncBrevo

        client = AsyncBrevo(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.balance.get_balance_definition_list(
                pid="pid",
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.get_balance_definition_list(
            pid,
            limit=limit,
            offset=offset,
            sort_field=sort_field,
            sort=sort,
            version=version,
            request_options=request_options,
        )
        return _response.data

    async def create_balance_definition(
        self,
        pid: str,
        *,
        name: str,
        unit: PostLoyaltyBalanceProgramsPidBalanceDefinitionsRequestUnit,
        balance_availability_duration_modifier: typing.Optional[
            PostLoyaltyBalanceProgramsPidBalanceDefinitionsRequestBalanceAvailabilityDurationModifier
        ] = OMIT,
        balance_availability_duration_unit: typing.Optional[
            PostLoyaltyBalanceProgramsPidBalanceDefinitionsRequestBalanceAvailabilityDurationUnit
        ] = OMIT,
        balance_availability_duration_value: typing.Optional[int] = OMIT,
        balance_expiration_date: typing.Optional[dt.date] = OMIT,
        balance_option_amount_overtaking_strategy: typing.Optional[
            PostLoyaltyBalanceProgramsPidBalanceDefinitionsRequestBalanceOptionAmountOvertakingStrategy
        ] = OMIT,
        balance_option_credit_rounding: typing.Optional[
            PostLoyaltyBalanceProgramsPidBalanceDefinitionsRequestBalanceOptionCreditRounding
        ] = OMIT,
        balance_option_debit_rounding: typing.Optional[
            PostLoyaltyBalanceProgramsPidBalanceDefinitionsRequestBalanceOptionDebitRounding
        ] = OMIT,
        description: typing.Optional[str] = OMIT,
        image_ref: typing.Optional[str] = OMIT,
        max_amount: typing.Optional[float] = OMIT,
        max_credit_amount_limit: typing.Optional[float] = OMIT,
        max_debit_amount_limit: typing.Optional[float] = OMIT,
        meta: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        min_amount: typing.Optional[float] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> BalanceDefinition:
        """
        Creates balance definition and returns information

        Parameters
        ----------
        pid : str
            Loyalty Program Id

        name : str
            Name of the balance definition.

        unit : PostLoyaltyBalanceProgramsPidBalanceDefinitionsRequestUnit
            Unit of balance measurement.

        balance_availability_duration_modifier : typing.Optional[PostLoyaltyBalanceProgramsPidBalanceDefinitionsRequestBalanceAvailabilityDurationModifier]
            Defines when the balance expires within the selected duration.

        balance_availability_duration_unit : typing.Optional[PostLoyaltyBalanceProgramsPidBalanceDefinitionsRequestBalanceAvailabilityDurationUnit]
            Unit of time for balance validity.

        balance_availability_duration_value : typing.Optional[int]
            Number of time units before the balance expires.

        balance_expiration_date : typing.Optional[dt.date]
            Fixed expiration date (`dd/mm` format) as an alternative to duration-based expiry.

        balance_option_amount_overtaking_strategy : typing.Optional[PostLoyaltyBalanceProgramsPidBalanceDefinitionsRequestBalanceOptionAmountOvertakingStrategy]
            Defines whether partial credit is allowed when reaching max balance.

        balance_option_credit_rounding : typing.Optional[PostLoyaltyBalanceProgramsPidBalanceDefinitionsRequestBalanceOptionCreditRounding]
            Defines rounding strategy for credit transactions.

        balance_option_debit_rounding : typing.Optional[PostLoyaltyBalanceProgramsPidBalanceDefinitionsRequestBalanceOptionDebitRounding]
            Defines rounding strategy for debit transactions.

        description : typing.Optional[str]
            Short description of the balance definition.

        image_ref : typing.Optional[str]
            URL of an optional image reference.

        max_amount : typing.Optional[float]
            Maximum allowable balance amount.

        max_credit_amount_limit : typing.Optional[float]
            Maximum credit allowed per operation.

        max_debit_amount_limit : typing.Optional[float]
            Maximum debit allowed per operation.

        meta : typing.Optional[typing.Dict[str, typing.Any]]
            Additional metadata for the balance definition.

        min_amount : typing.Optional[float]
            Minimum allowable balance amount.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        BalanceDefinition
            Successful creation of balance definition

        Examples
        --------
        import asyncio

        from brevo import AsyncBrevo

        client = AsyncBrevo(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.balance.create_balance_definition(
                pid="pid",
                name="name",
                unit="POINTS",
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.create_balance_definition(
            pid,
            name=name,
            unit=unit,
            balance_availability_duration_modifier=balance_availability_duration_modifier,
            balance_availability_duration_unit=balance_availability_duration_unit,
            balance_availability_duration_value=balance_availability_duration_value,
            balance_expiration_date=balance_expiration_date,
            balance_option_amount_overtaking_strategy=balance_option_amount_overtaking_strategy,
            balance_option_credit_rounding=balance_option_credit_rounding,
            balance_option_debit_rounding=balance_option_debit_rounding,
            description=description,
            image_ref=image_ref,
            max_amount=max_amount,
            max_credit_amount_limit=max_credit_amount_limit,
            max_debit_amount_limit=max_debit_amount_limit,
            meta=meta,
            min_amount=min_amount,
            request_options=request_options,
        )
        return _response.data

    async def get_balance_definition(
        self,
        pid: str,
        bdid: str,
        *,
        version: typing.Optional[GetBalanceDefinitionRequestVersion] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> BalanceDefinition:
        """
        Returns balance definition

        Parameters
        ----------
        pid : str
            Loyalty Program Id

        bdid : str
            Balance Definition Id

        version : typing.Optional[GetBalanceDefinitionRequestVersion]
            Version

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        BalanceDefinition
            Successful retrieval of balance definition

        Examples
        --------
        import asyncio

        from brevo import AsyncBrevo

        client = AsyncBrevo(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.balance.get_balance_definition(
                pid="pid",
                bdid="bdid",
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.get_balance_definition(
            pid, bdid, version=version, request_options=request_options
        )
        return _response.data

    async def update_balance_definition(
        self,
        pid: str,
        bdid: str,
        *,
        name: str,
        unit: UpdateBalanceDefinitionRequestUnit,
        balance_availability_duration_modifier: typing.Optional[
            UpdateBalanceDefinitionRequestBalanceAvailabilityDurationModifier
        ] = OMIT,
        balance_availability_duration_unit: typing.Optional[
            UpdateBalanceDefinitionRequestBalanceAvailabilityDurationUnit
        ] = OMIT,
        balance_availability_duration_value: typing.Optional[int] = OMIT,
        balance_expiration_date: typing.Optional[str] = OMIT,
        balance_option_amount_overtaking_strategy: typing.Optional[
            UpdateBalanceDefinitionRequestBalanceOptionAmountOvertakingStrategy
        ] = OMIT,
        balance_option_credit_rounding: typing.Optional[
            UpdateBalanceDefinitionRequestBalanceOptionCreditRounding
        ] = OMIT,
        balance_option_debit_rounding: typing.Optional[UpdateBalanceDefinitionRequestBalanceOptionDebitRounding] = OMIT,
        description: typing.Optional[str] = OMIT,
        image_ref: typing.Optional[str] = OMIT,
        max_amount: typing.Optional[float] = OMIT,
        max_credit_amount_limit: typing.Optional[float] = OMIT,
        max_debit_amount_limit: typing.Optional[float] = OMIT,
        meta: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        min_amount: typing.Optional[float] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> BalanceDefinition:
        """
        Updates Balance definition

        Parameters
        ----------
        pid : str
            Loyalty Program Id

        bdid : str
            Balance Definition Id

        name : str
            Name of the balance definition.

        unit : UpdateBalanceDefinitionRequestUnit
            Unit of balance measurement.

        balance_availability_duration_modifier : typing.Optional[UpdateBalanceDefinitionRequestBalanceAvailabilityDurationModifier]
            Defines when the balance expires within the selected duration.

        balance_availability_duration_unit : typing.Optional[UpdateBalanceDefinitionRequestBalanceAvailabilityDurationUnit]
            Unit of time for balance validity.

        balance_availability_duration_value : typing.Optional[int]
            Number of time units before the balance expires.

        balance_expiration_date : typing.Optional[str]
            Expiration date (`dd/mm` format) or empty if not applicable.

        balance_option_amount_overtaking_strategy : typing.Optional[UpdateBalanceDefinitionRequestBalanceOptionAmountOvertakingStrategy]
            Defines whether partial credit is allowed when reaching max balance.

        balance_option_credit_rounding : typing.Optional[UpdateBalanceDefinitionRequestBalanceOptionCreditRounding]
            Rounding strategy for credit transactions.

        balance_option_debit_rounding : typing.Optional[UpdateBalanceDefinitionRequestBalanceOptionDebitRounding]
            Rounding strategy for debit transactions.

        description : typing.Optional[str]
            Short description of the balance definition.

        image_ref : typing.Optional[str]
            URL of an optional image reference.

        max_amount : typing.Optional[float]
            Maximum allowable balance amount.

        max_credit_amount_limit : typing.Optional[float]
            Maximum credit allowed per operation.

        max_debit_amount_limit : typing.Optional[float]
            Maximum debit allowed per operation.

        meta : typing.Optional[typing.Dict[str, typing.Any]]
            Optional metadata for the balance definition.

        min_amount : typing.Optional[float]
            Minimum allowable balance amount.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        BalanceDefinition
            Successful update of balance definition

        Examples
        --------
        import asyncio

        from brevo import AsyncBrevo

        client = AsyncBrevo(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.balance.update_balance_definition(
                pid="pid",
                bdid="bdid",
                name="name",
                unit="POINTS",
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.update_balance_definition(
            pid,
            bdid,
            name=name,
            unit=unit,
            balance_availability_duration_modifier=balance_availability_duration_modifier,
            balance_availability_duration_unit=balance_availability_duration_unit,
            balance_availability_duration_value=balance_availability_duration_value,
            balance_expiration_date=balance_expiration_date,
            balance_option_amount_overtaking_strategy=balance_option_amount_overtaking_strategy,
            balance_option_credit_rounding=balance_option_credit_rounding,
            balance_option_debit_rounding=balance_option_debit_rounding,
            description=description,
            image_ref=image_ref,
            max_amount=max_amount,
            max_credit_amount_limit=max_credit_amount_limit,
            max_debit_amount_limit=max_debit_amount_limit,
            meta=meta,
            min_amount=min_amount,
            request_options=request_options,
        )
        return _response.data

    async def delete_balance_definition(
        self, pid: str, bdid: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> None:
        """
        Delete Balance definition

        Parameters
        ----------
        pid : str
            Loyalty Program Id

        bdid : str
            Balance Definition Id

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from brevo import AsyncBrevo

        client = AsyncBrevo(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.balance.delete_balance_definition(
                pid="pid",
                bdid="bdid",
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.delete_balance_definition(pid, bdid, request_options=request_options)
        return _response.data

    async def create_balance_limit(
        self,
        pid: str,
        bdid: str,
        *,
        constraint_type: CreateBalanceLimitRequestConstraintType,
        duration_unit: CreateBalanceLimitRequestDurationUnit,
        duration_value: int,
        transaction_type: CreateBalanceLimitRequestTransactionType,
        value: int,
        sliding_schedule: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> BalanceLimit:
        """
        Creates balance limit and sends the created UUID along with the data

        Parameters
        ----------
        pid : str
            Loyalty Program Id

        bdid : str
            Balance Definition Id

        constraint_type : CreateBalanceLimitRequestConstraintType
            Defines whether the limit applies to transaction count or amount.

        duration_unit : CreateBalanceLimitRequestDurationUnit
            Unit of time for which the limit is applicable.

        duration_value : int
            Number of time units for the balance limit.

        transaction_type : CreateBalanceLimitRequestTransactionType
            Specifies whether the limit applies to credit or debit transactions.

        value : int
            Maximum allowed value for the specified constraint type.

        sliding_schedule : typing.Optional[bool]
            Determines if the limit resets on a rolling schedule.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        BalanceLimit
            Successful creation of balance limit

        Examples
        --------
        import asyncio

        from brevo import AsyncBrevo

        client = AsyncBrevo(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.balance.create_balance_limit(
                pid="pid",
                bdid="bdid",
                constraint_type="transaction",
                duration_unit="day",
                duration_value=1,
                transaction_type="credit",
                value=1,
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.create_balance_limit(
            pid,
            bdid,
            constraint_type=constraint_type,
            duration_unit=duration_unit,
            duration_value=duration_value,
            transaction_type=transaction_type,
            value=value,
            sliding_schedule=sliding_schedule,
            request_options=request_options,
        )
        return _response.data

    async def get_balance_limit(
        self,
        pid: str,
        bdid: str,
        blid: str,
        *,
        version: typing.Optional[GetBalanceLimitRequestVersion] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> BalanceLimit:
        """
        Fetches balance limits and send the created UUID along with the data

        Parameters
        ----------
        pid : str
            Loyalty Program Id

        bdid : str
            Balance Definition Id

        blid : str
            Balance Limit Id

        version : typing.Optional[GetBalanceLimitRequestVersion]
            Version

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        BalanceLimit
            Successful retrieval of balance limit

        Examples
        --------
        import asyncio

        from brevo import AsyncBrevo

        client = AsyncBrevo(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.balance.get_balance_limit(
                pid="pid",
                bdid="bdid",
                blid="blid",
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.get_balance_limit(
            pid, bdid, blid, version=version, request_options=request_options
        )
        return _response.data

    async def update_balance_limit(
        self,
        pid: str,
        bdid: str,
        blid: str,
        *,
        constraint_type: UpdateBalanceLimitRequestConstraintType,
        duration_unit: UpdateBalanceLimitRequestDurationUnit,
        duration_value: int,
        transaction_type: UpdateBalanceLimitRequestTransactionType,
        value: int,
        sliding_schedule: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> BalanceLimit:
        """
        Updates balance limit

        Parameters
        ----------
        pid : str
            Loyalty Program Id

        bdid : str
            Balance Definition Id

        blid : str
            Balance Limit Id

        constraint_type : UpdateBalanceLimitRequestConstraintType
            Defines whether the limit applies to transaction count or amount.

        duration_unit : UpdateBalanceLimitRequestDurationUnit
            Unit of time for which the limit is applicable.

        duration_value : int
            Number of time units for the balance limit.

        transaction_type : UpdateBalanceLimitRequestTransactionType
            Specifies whether the limit applies to credit or debit transactions.

        value : int
            Maximum allowed value for the specified constraint type.

        sliding_schedule : typing.Optional[bool]
            Determines if the limit resets on a rolling schedule.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        BalanceLimit
            Successful update of balance limit

        Examples
        --------
        import asyncio

        from brevo import AsyncBrevo

        client = AsyncBrevo(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.balance.update_balance_limit(
                pid="pid",
                bdid="bdid",
                blid="blid",
                constraint_type="transaction",
                duration_unit="day",
                duration_value=1,
                transaction_type="credit",
                value=1,
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.update_balance_limit(
            pid,
            bdid,
            blid,
            constraint_type=constraint_type,
            duration_unit=duration_unit,
            duration_value=duration_value,
            transaction_type=transaction_type,
            value=value,
            sliding_schedule=sliding_schedule,
            request_options=request_options,
        )
        return _response.data

    async def delete_balance_limit(
        self, pid: str, bdid: str, blid: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> None:
        """
        Delete balance limit

        Parameters
        ----------
        pid : str
            Loyalty Program Id

        bdid : str
            Balance Definition Id

        blid : str
            Balance Limit Id

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from brevo import AsyncBrevo

        client = AsyncBrevo(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.balance.delete_balance_limit(
                pid="pid",
                bdid="bdid",
                blid="blid",
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.delete_balance_limit(pid, bdid, blid, request_options=request_options)
        return _response.data

    async def get_contact_balances(
        self, pid: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> GetContactBalancesResponse:
        """
        Returns balance list

        Parameters
        ----------
        pid : str
            Loyalty Program Id

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GetContactBalancesResponse
            Successful retrieval of contact balance

        Examples
        --------
        import asyncio

        from brevo import AsyncBrevo

        client = AsyncBrevo(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.balance.get_contact_balances(
                pid="pid",
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.get_contact_balances(pid, request_options=request_options)
        return _response.data

    async def create_balance_order(
        self,
        pid: str,
        *,
        amount: float,
        balance_definition_id: str,
        contact_id: int,
        due_at: str,
        source: str,
        expires_at: typing.Optional[str] = OMIT,
        meta: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CreateBalanceOrderResponse:
        """
        Returns created order

        Parameters
        ----------
        pid : str
            Loyalty Program Id

        amount : float
            Order amount (must be non-zero).

        balance_definition_id : str
            Unique identifier (UUID) of the associated balance definition.

        contact_id : int
            Unique identifier of the contact placing the order (must be â‰¥ 1).

        due_at : str
            RFC3339 timestamp specifying when the order is due.

        source : str
            Specifies the origin of the order (`engine` or `user`).

        expires_at : typing.Optional[str]
            Optional RFC3339 timestamp defining order expiration.

        meta : typing.Optional[typing.Dict[str, typing.Any]]
            Optional metadata associated with the order.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CreateBalanceOrderResponse
            Successful creation of order

        Examples
        --------
        import asyncio

        from brevo import AsyncBrevo

        client = AsyncBrevo(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.balance.create_balance_order(
                pid="pid",
                amount=1.1,
                balance_definition_id="balanceDefinitionId",
                contact_id=1,
                due_at="dueAt",
                source="source",
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.create_balance_order(
            pid,
            amount=amount,
            balance_definition_id=balance_definition_id,
            contact_id=contact_id,
            due_at=due_at,
            source=source,
            expires_at=expires_at,
            meta=meta,
            request_options=request_options,
        )
        return _response.data

    async def get_subscription_balances(
        self, pid: str, cid: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> GetSubscriptionBalancesResponse:
        """
        Returns subscription balances

        Parameters
        ----------
        pid : str
            Loyalty Program Id

        cid : str
            Contact Id

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GetSubscriptionBalancesResponse
            Successful retrieval of contact balance

        Examples
        --------
        import asyncio

        from brevo import AsyncBrevo

        client = AsyncBrevo(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.balance.get_subscription_balances(
                pid="pid",
                cid="cid",
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.get_subscription_balances(pid, cid, request_options=request_options)
        return _response.data

    async def create_subscription_balances(
        self, pid: str, cid: str, *, balance_definition_id: str, request_options: typing.Optional[RequestOptions] = None
    ) -> PostLoyaltyBalanceProgramsPidSubscriptionsCidBalancesResponse:
        """
        Creates a balance for a contact

        Parameters
        ----------
        pid : str
            Loyalty Program Id

        cid : str
            Contact Id

        balance_definition_id : str
            Unique identifier (UUID) of the balance definition associated with the new balance.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        PostLoyaltyBalanceProgramsPidSubscriptionsCidBalancesResponse
            Successful creation of balance

        Examples
        --------
        import asyncio

        from brevo import AsyncBrevo

        client = AsyncBrevo(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.balance.create_subscription_balances(
                pid="pid",
                cid="cid",
                balance_definition_id="balanceDefinitionId",
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.create_subscription_balances(
            pid, cid, balance_definition_id=balance_definition_id, request_options=request_options
        )
        return _response.data

    async def get_transaction_history_api(
        self,
        pid: str,
        *,
        contact_id: int,
        balance_definition_id: str,
        limit: typing.Optional[int] = None,
        offset: typing.Optional[int] = None,
        sort_field: typing.Optional[GetLoyaltyBalanceProgramsPidTransactionHistoryRequestSortField] = None,
        sort: typing.Optional[GetLoyaltyBalanceProgramsPidTransactionHistoryRequestSort] = None,
        filters: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GetLoyaltyBalanceProgramsPidTransactionHistoryResponse:
        """
        Returns transaction history

        Parameters
        ----------
        pid : str
            Loyalty Program Id

        contact_id : int
            Contact ID

        balance_definition_id : str
            Balance Definition ID

        limit : typing.Optional[int]
            Limit the number of records returned

        offset : typing.Optional[int]
            Skip a number of records

        sort_field : typing.Optional[GetLoyaltyBalanceProgramsPidTransactionHistoryRequestSortField]
            Field to sort by

        sort : typing.Optional[GetLoyaltyBalanceProgramsPidTransactionHistoryRequestSort]
            Sort order, either asc or desc

        filters : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            Filters to apply

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GetLoyaltyBalanceProgramsPidTransactionHistoryResponse
            Successful retrieval of transaction history

        Examples
        --------
        import asyncio

        from brevo import AsyncBrevo

        client = AsyncBrevo(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.balance.get_transaction_history_api(
                pid="pid",
                contact_id=1,
                balance_definition_id="balance_definition_id",
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.get_transaction_history_api(
            pid,
            contact_id=contact_id,
            balance_definition_id=balance_definition_id,
            limit=limit,
            offset=offset,
            sort_field=sort_field,
            sort=sort,
            filters=filters,
            request_options=request_options,
        )
        return _response.data

    async def begin_transaction(
        self,
        pid: str,
        *,
        amount: float,
        balance_definition_id: str,
        loyalty_subscription_id: typing.Optional[str] = OMIT,
        auto_complete: typing.Optional[bool] = OMIT,
        balance_expiry_in_minutes: typing.Optional[int] = OMIT,
        contact_id: typing.Optional[int] = OMIT,
        event_time: typing.Optional[str] = OMIT,
        meta: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        ttl: typing.Optional[int] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Transaction:
        """
        Creates new transaction and returns information

        Parameters
        ----------
        pid : str
            Loyalty Program Id

        amount : float
            Transaction amount (must be provided).

        balance_definition_id : str
            Unique identifier (UUID) of the associated balance definition.

        loyalty_subscription_id : typing.Optional[str]
            Unique identifier for the loyalty subscription (required unless `contactId` is provided).

        auto_complete : typing.Optional[bool]
            Whether the transaction should be automatically completed.

        balance_expiry_in_minutes : typing.Optional[int]
            Optional expiry time for the balance in minutes (must be greater than 0 if provided).

        contact_id : typing.Optional[int]
            Unique identifier of the contact involved in the transaction (required unless `LoyaltySubscriptionId` is provided).

        event_time : typing.Optional[str]
            Optional timestamp specifying when the transaction occurred.

        meta : typing.Optional[typing.Dict[str, typing.Any]]
            Optional metadata associated with the transaction.

        ttl : typing.Optional[int]
            Optional time-to-live for the transaction (must be greater than 0 if provided).

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Transaction
            Transaction information

        Examples
        --------
        import asyncio

        from brevo import AsyncBrevo

        client = AsyncBrevo(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.balance.begin_transaction(
                pid="pid",
                amount=1.1,
                balance_definition_id="balanceDefinitionId",
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.begin_transaction(
            pid,
            amount=amount,
            balance_definition_id=balance_definition_id,
            loyalty_subscription_id=loyalty_subscription_id,
            auto_complete=auto_complete,
            balance_expiry_in_minutes=balance_expiry_in_minutes,
            contact_id=contact_id,
            event_time=event_time,
            meta=meta,
            ttl=ttl,
            request_options=request_options,
        )
        return _response.data

    async def cancel_transaction(
        self, pid: str, tid: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> Transaction:
        """
        Cancels transaction

        Parameters
        ----------
        pid : str
            Loyalty Program Id

        tid : str
            Transaction Id

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Transaction
            Transaction information

        Examples
        --------
        import asyncio

        from brevo import AsyncBrevo

        client = AsyncBrevo(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.balance.cancel_transaction(
                pid="pid",
                tid="tid",
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.cancel_transaction(pid, tid, request_options=request_options)
        return _response.data

    async def complete_transaction(
        self, pid: str, tid: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> Transaction:
        """
        Completes transaction

        Parameters
        ----------
        pid : str
            Loyalty Program Id

        tid : str
            Transaction Id

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Transaction
            Transaction information

        Examples
        --------
        import asyncio

        from brevo import AsyncBrevo

        client = AsyncBrevo(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.balance.complete_transaction(
                pid="pid",
                tid="tid",
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.complete_transaction(pid, tid, request_options=request_options)
        return _response.data
