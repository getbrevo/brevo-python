# This file was auto-generated by Fern from our API Definition.

import datetime as dt
import typing
from json.decoder import JSONDecodeError

from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.http_response import AsyncHttpResponse, HttpResponse
from ..core.jsonable_encoder import jsonable_encoder
from ..core.request_options import RequestOptions
from ..core.unchecked_base_model import construct_type
from ..errors.failed_dependency_error import FailedDependencyError
from ..errors.forbidden_error import ForbiddenError
from ..errors.internal_server_error import InternalServerError
from ..errors.not_found_error import NotFoundError
from ..errors.unauthorized_error import UnauthorizedError
from ..errors.unprocessable_entity_error import UnprocessableEntityError
from ..types.balance_definition import BalanceDefinition
from ..types.balance_limit import BalanceLimit
from ..types.error_model import ErrorModel
from ..types.transaction import Transaction
from .types.create_balance_limit_request_constraint_type import CreateBalanceLimitRequestConstraintType
from .types.create_balance_limit_request_duration_unit import CreateBalanceLimitRequestDurationUnit
from .types.create_balance_limit_request_transaction_type import CreateBalanceLimitRequestTransactionType
from .types.create_balance_order_response import CreateBalanceOrderResponse
from .types.get_balance_definition_list_request_sort import GetBalanceDefinitionListRequestSort
from .types.get_balance_definition_list_request_sort_field import GetBalanceDefinitionListRequestSortField
from .types.get_balance_definition_list_request_version import GetBalanceDefinitionListRequestVersion
from .types.get_balance_definition_list_response import GetBalanceDefinitionListResponse
from .types.get_balance_definition_request_version import GetBalanceDefinitionRequestVersion
from .types.get_balance_limit_request_version import GetBalanceLimitRequestVersion
from .types.get_contact_balances_response import GetContactBalancesResponse
from .types.get_loyalty_balance_programs_pid_transaction_history_request_sort import (
    GetLoyaltyBalanceProgramsPidTransactionHistoryRequestSort,
)
from .types.get_loyalty_balance_programs_pid_transaction_history_request_sort_field import (
    GetLoyaltyBalanceProgramsPidTransactionHistoryRequestSortField,
)
from .types.get_loyalty_balance_programs_pid_transaction_history_response import (
    GetLoyaltyBalanceProgramsPidTransactionHistoryResponse,
)
from .types.get_subscription_balances_response import GetSubscriptionBalancesResponse
from .types.post_loyalty_balance_programs_pid_balance_definitions_request_balance_availability_duration_modifier import (
    PostLoyaltyBalanceProgramsPidBalanceDefinitionsRequestBalanceAvailabilityDurationModifier,
)
from .types.post_loyalty_balance_programs_pid_balance_definitions_request_balance_availability_duration_unit import (
    PostLoyaltyBalanceProgramsPidBalanceDefinitionsRequestBalanceAvailabilityDurationUnit,
)
from .types.post_loyalty_balance_programs_pid_balance_definitions_request_balance_option_amount_overtaking_strategy import (
    PostLoyaltyBalanceProgramsPidBalanceDefinitionsRequestBalanceOptionAmountOvertakingStrategy,
)
from .types.post_loyalty_balance_programs_pid_balance_definitions_request_balance_option_credit_rounding import (
    PostLoyaltyBalanceProgramsPidBalanceDefinitionsRequestBalanceOptionCreditRounding,
)
from .types.post_loyalty_balance_programs_pid_balance_definitions_request_balance_option_debit_rounding import (
    PostLoyaltyBalanceProgramsPidBalanceDefinitionsRequestBalanceOptionDebitRounding,
)
from .types.post_loyalty_balance_programs_pid_balance_definitions_request_unit import (
    PostLoyaltyBalanceProgramsPidBalanceDefinitionsRequestUnit,
)
from .types.post_loyalty_balance_programs_pid_subscriptions_cid_balances_response import (
    PostLoyaltyBalanceProgramsPidSubscriptionsCidBalancesResponse,
)
from .types.update_balance_definition_request_balance_availability_duration_modifier import (
    UpdateBalanceDefinitionRequestBalanceAvailabilityDurationModifier,
)
from .types.update_balance_definition_request_balance_availability_duration_unit import (
    UpdateBalanceDefinitionRequestBalanceAvailabilityDurationUnit,
)
from .types.update_balance_definition_request_balance_option_amount_overtaking_strategy import (
    UpdateBalanceDefinitionRequestBalanceOptionAmountOvertakingStrategy,
)
from .types.update_balance_definition_request_balance_option_credit_rounding import (
    UpdateBalanceDefinitionRequestBalanceOptionCreditRounding,
)
from .types.update_balance_definition_request_balance_option_debit_rounding import (
    UpdateBalanceDefinitionRequestBalanceOptionDebitRounding,
)
from .types.update_balance_definition_request_unit import UpdateBalanceDefinitionRequestUnit
from .types.update_balance_limit_request_constraint_type import UpdateBalanceLimitRequestConstraintType
from .types.update_balance_limit_request_duration_unit import UpdateBalanceLimitRequestDurationUnit
from .types.update_balance_limit_request_transaction_type import UpdateBalanceLimitRequestTransactionType

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawBalanceClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def get_active_balances_api(
        self,
        pid: str,
        *,
        contact_id: int,
        balance_definition_id: str,
        limit: typing.Optional[int] = None,
        offset: typing.Optional[int] = None,
        sort_field: typing.Optional[str] = None,
        sort: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[BalanceLimit]:
        """
        Returns Active Balances

        Parameters
        ----------
        pid : str
            Loyalty Program Id

        contact_id : int
            Contact ID

        balance_definition_id : str
            Balance Definition ID

        limit : typing.Optional[int]
            Limit

        offset : typing.Optional[int]
            Offset

        sort_field : typing.Optional[str]
            Sort Field

        sort : typing.Optional[str]
            Sort Order

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[BalanceLimit]
            Successful retrieval of active balance
        """
        _response = self._client_wrapper.httpx_client.request(
            f"loyalty/balance/programs/{jsonable_encoder(pid)}/active-balance",
            method="GET",
            params={
                "limit": limit,
                "offset": offset,
                "sort_field": sort_field,
                "sort": sort,
                "contact_id": contact_id,
                "balance_definition_id": balance_definition_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    BalanceLimit,
                    construct_type(
                        type_=BalanceLimit,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorModel,
                        construct_type(
                            type_=ErrorModel,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_balance_definition_list(
        self,
        pid: str,
        *,
        limit: typing.Optional[int] = None,
        offset: typing.Optional[int] = None,
        sort_field: typing.Optional[GetBalanceDefinitionListRequestSortField] = None,
        sort: typing.Optional[GetBalanceDefinitionListRequestSort] = None,
        version: typing.Optional[GetBalanceDefinitionListRequestVersion] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[GetBalanceDefinitionListResponse]:
        """
        Returns balance definition page

        Parameters
        ----------
        pid : str
            Loyalty Program Id

        limit : typing.Optional[int]
            Limit the number of records returned

        offset : typing.Optional[int]
            Offset to paginate records

        sort_field : typing.Optional[GetBalanceDefinitionListRequestSortField]
            Field to sort by

        sort : typing.Optional[GetBalanceDefinitionListRequestSort]
            Sort direction

        version : typing.Optional[GetBalanceDefinitionListRequestVersion]
            Version

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetBalanceDefinitionListResponse]
            Successful retrieval of balance definition page
        """
        _response = self._client_wrapper.httpx_client.request(
            f"loyalty/balance/programs/{jsonable_encoder(pid)}/balance-definitions",
            method="GET",
            params={
                "limit": limit,
                "offset": offset,
                "sortField": sort_field,
                "sort": sort,
                "version": version,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetBalanceDefinitionListResponse,
                    construct_type(
                        type_=GetBalanceDefinitionListResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorModel,
                        construct_type(
                            type_=ErrorModel,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def create_balance_definition(
        self,
        pid: str,
        *,
        name: str,
        unit: PostLoyaltyBalanceProgramsPidBalanceDefinitionsRequestUnit,
        balance_availability_duration_modifier: typing.Optional[
            PostLoyaltyBalanceProgramsPidBalanceDefinitionsRequestBalanceAvailabilityDurationModifier
        ] = OMIT,
        balance_availability_duration_unit: typing.Optional[
            PostLoyaltyBalanceProgramsPidBalanceDefinitionsRequestBalanceAvailabilityDurationUnit
        ] = OMIT,
        balance_availability_duration_value: typing.Optional[int] = OMIT,
        balance_expiration_date: typing.Optional[dt.date] = OMIT,
        balance_option_amount_overtaking_strategy: typing.Optional[
            PostLoyaltyBalanceProgramsPidBalanceDefinitionsRequestBalanceOptionAmountOvertakingStrategy
        ] = OMIT,
        balance_option_credit_rounding: typing.Optional[
            PostLoyaltyBalanceProgramsPidBalanceDefinitionsRequestBalanceOptionCreditRounding
        ] = OMIT,
        balance_option_debit_rounding: typing.Optional[
            PostLoyaltyBalanceProgramsPidBalanceDefinitionsRequestBalanceOptionDebitRounding
        ] = OMIT,
        description: typing.Optional[str] = OMIT,
        image_ref: typing.Optional[str] = OMIT,
        max_amount: typing.Optional[float] = OMIT,
        max_credit_amount_limit: typing.Optional[float] = OMIT,
        max_debit_amount_limit: typing.Optional[float] = OMIT,
        meta: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        min_amount: typing.Optional[float] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[BalanceDefinition]:
        """
        Creates balance definition and returns information

        Parameters
        ----------
        pid : str
            Loyalty Program Id

        name : str
            Name of the balance definition.

        unit : PostLoyaltyBalanceProgramsPidBalanceDefinitionsRequestUnit
            Unit of balance measurement.

        balance_availability_duration_modifier : typing.Optional[PostLoyaltyBalanceProgramsPidBalanceDefinitionsRequestBalanceAvailabilityDurationModifier]
            Defines when the balance expires within the selected duration.

        balance_availability_duration_unit : typing.Optional[PostLoyaltyBalanceProgramsPidBalanceDefinitionsRequestBalanceAvailabilityDurationUnit]
            Unit of time for balance validity.

        balance_availability_duration_value : typing.Optional[int]
            Number of time units before the balance expires.

        balance_expiration_date : typing.Optional[dt.date]
            Fixed expiration date (`dd/mm` format) as an alternative to duration-based expiry.

        balance_option_amount_overtaking_strategy : typing.Optional[PostLoyaltyBalanceProgramsPidBalanceDefinitionsRequestBalanceOptionAmountOvertakingStrategy]
            Defines whether partial credit is allowed when reaching max balance.

        balance_option_credit_rounding : typing.Optional[PostLoyaltyBalanceProgramsPidBalanceDefinitionsRequestBalanceOptionCreditRounding]
            Defines rounding strategy for credit transactions.

        balance_option_debit_rounding : typing.Optional[PostLoyaltyBalanceProgramsPidBalanceDefinitionsRequestBalanceOptionDebitRounding]
            Defines rounding strategy for debit transactions.

        description : typing.Optional[str]
            Short description of the balance definition.

        image_ref : typing.Optional[str]
            URL of an optional image reference.

        max_amount : typing.Optional[float]
            Maximum allowable balance amount.

        max_credit_amount_limit : typing.Optional[float]
            Maximum credit allowed per operation.

        max_debit_amount_limit : typing.Optional[float]
            Maximum debit allowed per operation.

        meta : typing.Optional[typing.Dict[str, typing.Any]]
            Additional metadata for the balance definition.

        min_amount : typing.Optional[float]
            Minimum allowable balance amount.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[BalanceDefinition]
            Successful creation of balance definition
        """
        _response = self._client_wrapper.httpx_client.request(
            f"loyalty/balance/programs/{jsonable_encoder(pid)}/balance-definitions",
            method="POST",
            json={
                "balanceAvailabilityDurationModifier": balance_availability_duration_modifier,
                "balanceAvailabilityDurationUnit": balance_availability_duration_unit,
                "balanceAvailabilityDurationValue": balance_availability_duration_value,
                "balanceExpirationDate": balance_expiration_date,
                "balanceOptionAmountOvertakingStrategy": balance_option_amount_overtaking_strategy,
                "balanceOptionCreditRounding": balance_option_credit_rounding,
                "balanceOptionDebitRounding": balance_option_debit_rounding,
                "description": description,
                "imageRef": image_ref,
                "maxAmount": max_amount,
                "maxCreditAmountLimit": max_credit_amount_limit,
                "maxDebitAmountLimit": max_debit_amount_limit,
                "meta": meta,
                "minAmount": min_amount,
                "name": name,
                "unit": unit,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    BalanceDefinition,
                    construct_type(
                        type_=BalanceDefinition,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorModel,
                        construct_type(
                            type_=ErrorModel,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_balance_definition(
        self,
        pid: str,
        bdid: str,
        *,
        version: typing.Optional[GetBalanceDefinitionRequestVersion] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[BalanceDefinition]:
        """
        Returns balance definition

        Parameters
        ----------
        pid : str
            Loyalty Program Id

        bdid : str
            Balance Definition Id

        version : typing.Optional[GetBalanceDefinitionRequestVersion]
            Version

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[BalanceDefinition]
            Successful retrieval of balance definition
        """
        _response = self._client_wrapper.httpx_client.request(
            f"loyalty/balance/programs/{jsonable_encoder(pid)}/balance-definitions/{jsonable_encoder(bdid)}",
            method="GET",
            params={
                "version": version,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    BalanceDefinition,
                    construct_type(
                        type_=BalanceDefinition,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorModel,
                        construct_type(
                            type_=ErrorModel,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def update_balance_definition(
        self,
        pid: str,
        bdid: str,
        *,
        name: str,
        unit: UpdateBalanceDefinitionRequestUnit,
        balance_availability_duration_modifier: typing.Optional[
            UpdateBalanceDefinitionRequestBalanceAvailabilityDurationModifier
        ] = OMIT,
        balance_availability_duration_unit: typing.Optional[
            UpdateBalanceDefinitionRequestBalanceAvailabilityDurationUnit
        ] = OMIT,
        balance_availability_duration_value: typing.Optional[int] = OMIT,
        balance_expiration_date: typing.Optional[str] = OMIT,
        balance_option_amount_overtaking_strategy: typing.Optional[
            UpdateBalanceDefinitionRequestBalanceOptionAmountOvertakingStrategy
        ] = OMIT,
        balance_option_credit_rounding: typing.Optional[
            UpdateBalanceDefinitionRequestBalanceOptionCreditRounding
        ] = OMIT,
        balance_option_debit_rounding: typing.Optional[UpdateBalanceDefinitionRequestBalanceOptionDebitRounding] = OMIT,
        description: typing.Optional[str] = OMIT,
        image_ref: typing.Optional[str] = OMIT,
        max_amount: typing.Optional[float] = OMIT,
        max_credit_amount_limit: typing.Optional[float] = OMIT,
        max_debit_amount_limit: typing.Optional[float] = OMIT,
        meta: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        min_amount: typing.Optional[float] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[BalanceDefinition]:
        """
        Updates Balance definition

        Parameters
        ----------
        pid : str
            Loyalty Program Id

        bdid : str
            Balance Definition Id

        name : str
            Name of the balance definition.

        unit : UpdateBalanceDefinitionRequestUnit
            Unit of balance measurement.

        balance_availability_duration_modifier : typing.Optional[UpdateBalanceDefinitionRequestBalanceAvailabilityDurationModifier]
            Defines when the balance expires within the selected duration.

        balance_availability_duration_unit : typing.Optional[UpdateBalanceDefinitionRequestBalanceAvailabilityDurationUnit]
            Unit of time for balance validity.

        balance_availability_duration_value : typing.Optional[int]
            Number of time units before the balance expires.

        balance_expiration_date : typing.Optional[str]
            Expiration date (`dd/mm` format) or empty if not applicable.

        balance_option_amount_overtaking_strategy : typing.Optional[UpdateBalanceDefinitionRequestBalanceOptionAmountOvertakingStrategy]
            Defines whether partial credit is allowed when reaching max balance.

        balance_option_credit_rounding : typing.Optional[UpdateBalanceDefinitionRequestBalanceOptionCreditRounding]
            Rounding strategy for credit transactions.

        balance_option_debit_rounding : typing.Optional[UpdateBalanceDefinitionRequestBalanceOptionDebitRounding]
            Rounding strategy for debit transactions.

        description : typing.Optional[str]
            Short description of the balance definition.

        image_ref : typing.Optional[str]
            URL of an optional image reference.

        max_amount : typing.Optional[float]
            Maximum allowable balance amount.

        max_credit_amount_limit : typing.Optional[float]
            Maximum credit allowed per operation.

        max_debit_amount_limit : typing.Optional[float]
            Maximum debit allowed per operation.

        meta : typing.Optional[typing.Dict[str, typing.Any]]
            Optional metadata for the balance definition.

        min_amount : typing.Optional[float]
            Minimum allowable balance amount.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[BalanceDefinition]
            Successful update of balance definition
        """
        _response = self._client_wrapper.httpx_client.request(
            f"loyalty/balance/programs/{jsonable_encoder(pid)}/balance-definitions/{jsonable_encoder(bdid)}",
            method="PUT",
            json={
                "balanceAvailabilityDurationModifier": balance_availability_duration_modifier,
                "balanceAvailabilityDurationUnit": balance_availability_duration_unit,
                "balanceAvailabilityDurationValue": balance_availability_duration_value,
                "balanceExpirationDate": balance_expiration_date,
                "balanceOptionAmountOvertakingStrategy": balance_option_amount_overtaking_strategy,
                "balanceOptionCreditRounding": balance_option_credit_rounding,
                "balanceOptionDebitRounding": balance_option_debit_rounding,
                "description": description,
                "imageRef": image_ref,
                "maxAmount": max_amount,
                "maxCreditAmountLimit": max_credit_amount_limit,
                "maxDebitAmountLimit": max_debit_amount_limit,
                "meta": meta,
                "minAmount": min_amount,
                "name": name,
                "unit": unit,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    BalanceDefinition,
                    construct_type(
                        type_=BalanceDefinition,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorModel,
                        construct_type(
                            type_=ErrorModel,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 424:
                raise FailedDependencyError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def delete_balance_definition(
        self, pid: str, bdid: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[None]:
        """
        Delete Balance definition

        Parameters
        ----------
        pid : str
            Loyalty Program Id

        bdid : str
            Balance Definition Id

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"loyalty/balance/programs/{jsonable_encoder(pid)}/balance-definitions/{jsonable_encoder(bdid)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorModel,
                        construct_type(
                            type_=ErrorModel,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def create_balance_limit(
        self,
        pid: str,
        bdid: str,
        *,
        constraint_type: CreateBalanceLimitRequestConstraintType,
        duration_unit: CreateBalanceLimitRequestDurationUnit,
        duration_value: int,
        transaction_type: CreateBalanceLimitRequestTransactionType,
        value: int,
        sliding_schedule: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[BalanceLimit]:
        """
        Creates balance limit and sends the created UUID along with the data

        Parameters
        ----------
        pid : str
            Loyalty Program Id

        bdid : str
            Balance Definition Id

        constraint_type : CreateBalanceLimitRequestConstraintType
            Defines whether the limit applies to transaction count or amount.

        duration_unit : CreateBalanceLimitRequestDurationUnit
            Unit of time for which the limit is applicable.

        duration_value : int
            Number of time units for the balance limit.

        transaction_type : CreateBalanceLimitRequestTransactionType
            Specifies whether the limit applies to credit or debit transactions.

        value : int
            Maximum allowed value for the specified constraint type.

        sliding_schedule : typing.Optional[bool]
            Determines if the limit resets on a rolling schedule.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[BalanceLimit]
            Successful creation of balance limit
        """
        _response = self._client_wrapper.httpx_client.request(
            f"loyalty/balance/programs/{jsonable_encoder(pid)}/balance-definitions/{jsonable_encoder(bdid)}/limits",
            method="POST",
            json={
                "constraintType": constraint_type,
                "durationUnit": duration_unit,
                "durationValue": duration_value,
                "slidingSchedule": sliding_schedule,
                "transactionType": transaction_type,
                "value": value,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    BalanceLimit,
                    construct_type(
                        type_=BalanceLimit,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorModel,
                        construct_type(
                            type_=ErrorModel,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 424:
                raise FailedDependencyError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_balance_limit(
        self,
        pid: str,
        bdid: str,
        blid: str,
        *,
        version: typing.Optional[GetBalanceLimitRequestVersion] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[BalanceLimit]:
        """
        Fetches balance limits and send the created UUID along with the data

        Parameters
        ----------
        pid : str
            Loyalty Program Id

        bdid : str
            Balance Definition Id

        blid : str
            Balance Limit Id

        version : typing.Optional[GetBalanceLimitRequestVersion]
            Version

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[BalanceLimit]
            Successful retrieval of balance limit
        """
        _response = self._client_wrapper.httpx_client.request(
            f"loyalty/balance/programs/{jsonable_encoder(pid)}/balance-definitions/{jsonable_encoder(bdid)}/limits/{jsonable_encoder(blid)}",
            method="GET",
            params={
                "version": version,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    BalanceLimit,
                    construct_type(
                        type_=BalanceLimit,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorModel,
                        construct_type(
                            type_=ErrorModel,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def update_balance_limit(
        self,
        pid: str,
        bdid: str,
        blid: str,
        *,
        constraint_type: UpdateBalanceLimitRequestConstraintType,
        duration_unit: UpdateBalanceLimitRequestDurationUnit,
        duration_value: int,
        transaction_type: UpdateBalanceLimitRequestTransactionType,
        value: int,
        sliding_schedule: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[BalanceLimit]:
        """
        Updates balance limit

        Parameters
        ----------
        pid : str
            Loyalty Program Id

        bdid : str
            Balance Definition Id

        blid : str
            Balance Limit Id

        constraint_type : UpdateBalanceLimitRequestConstraintType
            Defines whether the limit applies to transaction count or amount.

        duration_unit : UpdateBalanceLimitRequestDurationUnit
            Unit of time for which the limit is applicable.

        duration_value : int
            Number of time units for the balance limit.

        transaction_type : UpdateBalanceLimitRequestTransactionType
            Specifies whether the limit applies to credit or debit transactions.

        value : int
            Maximum allowed value for the specified constraint type.

        sliding_schedule : typing.Optional[bool]
            Determines if the limit resets on a rolling schedule.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[BalanceLimit]
            Successful update of balance limit
        """
        _response = self._client_wrapper.httpx_client.request(
            f"loyalty/balance/programs/{jsonable_encoder(pid)}/balance-definitions/{jsonable_encoder(bdid)}/limits/{jsonable_encoder(blid)}",
            method="PUT",
            json={
                "constraintType": constraint_type,
                "durationUnit": duration_unit,
                "durationValue": duration_value,
                "slidingSchedule": sliding_schedule,
                "transactionType": transaction_type,
                "value": value,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    BalanceLimit,
                    construct_type(
                        type_=BalanceLimit,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorModel,
                        construct_type(
                            type_=ErrorModel,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def delete_balance_limit(
        self, pid: str, bdid: str, blid: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[None]:
        """
        Delete balance limit

        Parameters
        ----------
        pid : str
            Loyalty Program Id

        bdid : str
            Balance Definition Id

        blid : str
            Balance Limit Id

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"loyalty/balance/programs/{jsonable_encoder(pid)}/balance-definitions/{jsonable_encoder(bdid)}/limits/{jsonable_encoder(blid)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorModel,
                        construct_type(
                            type_=ErrorModel,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_contact_balances(
        self, pid: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[GetContactBalancesResponse]:
        """
        Returns balance list

        Parameters
        ----------
        pid : str
            Loyalty Program Id

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetContactBalancesResponse]
            Successful retrieval of contact balance
        """
        _response = self._client_wrapper.httpx_client.request(
            f"loyalty/balance/programs/{jsonable_encoder(pid)}/contact-balances",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetContactBalancesResponse,
                    construct_type(
                        type_=GetContactBalancesResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorModel,
                        construct_type(
                            type_=ErrorModel,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def create_balance_order(
        self,
        pid: str,
        *,
        amount: float,
        balance_definition_id: str,
        contact_id: int,
        due_at: str,
        source: str,
        expires_at: typing.Optional[str] = OMIT,
        meta: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[CreateBalanceOrderResponse]:
        """
        Returns created order

        Parameters
        ----------
        pid : str
            Loyalty Program Id

        amount : float
            Order amount (must be non-zero).

        balance_definition_id : str
            Unique identifier (UUID) of the associated balance definition.

        contact_id : int
            Unique identifier of the contact placing the order (must be  1).

        due_at : str
            RFC3339 timestamp specifying when the order is due.

        source : str
            Specifies the origin of the order (`engine` or `user`).

        expires_at : typing.Optional[str]
            Optional RFC3339 timestamp defining order expiration.

        meta : typing.Optional[typing.Dict[str, typing.Any]]
            Optional metadata associated with the order.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[CreateBalanceOrderResponse]
            Successful creation of order
        """
        _response = self._client_wrapper.httpx_client.request(
            f"loyalty/balance/programs/{jsonable_encoder(pid)}/create-order",
            method="POST",
            json={
                "amount": amount,
                "balanceDefinitionId": balance_definition_id,
                "contactId": contact_id,
                "dueAt": due_at,
                "expiresAt": expires_at,
                "meta": meta,
                "source": source,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CreateBalanceOrderResponse,
                    construct_type(
                        type_=CreateBalanceOrderResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorModel,
                        construct_type(
                            type_=ErrorModel,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_subscription_balances(
        self, pid: str, cid: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[GetSubscriptionBalancesResponse]:
        """
        Returns subscription balances

        Parameters
        ----------
        pid : str
            Loyalty Program Id

        cid : str
            Contact Id

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetSubscriptionBalancesResponse]
            Successful retrieval of contact balance
        """
        _response = self._client_wrapper.httpx_client.request(
            f"loyalty/balance/programs/{jsonable_encoder(pid)}/subscriptions/{jsonable_encoder(cid)}/balances",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetSubscriptionBalancesResponse,
                    construct_type(
                        type_=GetSubscriptionBalancesResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorModel,
                        construct_type(
                            type_=ErrorModel,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def create_subscription_balances(
        self, pid: str, cid: str, *, balance_definition_id: str, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[PostLoyaltyBalanceProgramsPidSubscriptionsCidBalancesResponse]:
        """
        Creates a balance for a contact

        Parameters
        ----------
        pid : str
            Loyalty Program Id

        cid : str
            Contact Id

        balance_definition_id : str
            Unique identifier (UUID) of the balance definition associated with the new balance.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[PostLoyaltyBalanceProgramsPidSubscriptionsCidBalancesResponse]
            Successful creation of balance
        """
        _response = self._client_wrapper.httpx_client.request(
            f"loyalty/balance/programs/{jsonable_encoder(pid)}/subscriptions/{jsonable_encoder(cid)}/balances",
            method="POST",
            json={
                "balanceDefinitionId": balance_definition_id,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PostLoyaltyBalanceProgramsPidSubscriptionsCidBalancesResponse,
                    construct_type(
                        type_=PostLoyaltyBalanceProgramsPidSubscriptionsCidBalancesResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorModel,
                        construct_type(
                            type_=ErrorModel,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_transaction_history_api(
        self,
        pid: str,
        *,
        contact_id: int,
        balance_definition_id: str,
        limit: typing.Optional[int] = None,
        offset: typing.Optional[int] = None,
        sort_field: typing.Optional[GetLoyaltyBalanceProgramsPidTransactionHistoryRequestSortField] = None,
        sort: typing.Optional[GetLoyaltyBalanceProgramsPidTransactionHistoryRequestSort] = None,
        filters: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[GetLoyaltyBalanceProgramsPidTransactionHistoryResponse]:
        """
        Returns transaction history

        Parameters
        ----------
        pid : str
            Loyalty Program Id

        contact_id : int
            Contact ID

        balance_definition_id : str
            Balance Definition ID

        limit : typing.Optional[int]
            Limit the number of records returned

        offset : typing.Optional[int]
            Skip a number of records

        sort_field : typing.Optional[GetLoyaltyBalanceProgramsPidTransactionHistoryRequestSortField]
            Field to sort by

        sort : typing.Optional[GetLoyaltyBalanceProgramsPidTransactionHistoryRequestSort]
            Sort order, either asc or desc

        filters : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            Filters to apply

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetLoyaltyBalanceProgramsPidTransactionHistoryResponse]
            Successful retrieval of transaction history
        """
        _response = self._client_wrapper.httpx_client.request(
            f"loyalty/balance/programs/{jsonable_encoder(pid)}/transaction-history",
            method="GET",
            params={
                "limit": limit,
                "offset": offset,
                "sort_field": sort_field,
                "sort": sort,
                "contact_id": contact_id,
                "balance_definition_id": balance_definition_id,
                "filters": filters,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetLoyaltyBalanceProgramsPidTransactionHistoryResponse,
                    construct_type(
                        type_=GetLoyaltyBalanceProgramsPidTransactionHistoryResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorModel,
                        construct_type(
                            type_=ErrorModel,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def begin_transaction(
        self,
        pid: str,
        *,
        amount: float,
        balance_definition_id: str,
        loyalty_subscription_id: typing.Optional[str] = OMIT,
        auto_complete: typing.Optional[bool] = OMIT,
        balance_expiry_in_minutes: typing.Optional[int] = OMIT,
        contact_id: typing.Optional[int] = OMIT,
        event_time: typing.Optional[str] = OMIT,
        meta: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        ttl: typing.Optional[int] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[Transaction]:
        """
        Creates new transaction and returns information

        Parameters
        ----------
        pid : str
            Loyalty Program Id

        amount : float
            Transaction amount (must be provided).

        balance_definition_id : str
            Unique identifier (UUID) of the associated balance definition.

        loyalty_subscription_id : typing.Optional[str]
            Unique identifier for the loyalty subscription (required unless `contactId` is provided).

        auto_complete : typing.Optional[bool]
            Whether the transaction should be automatically completed.

        balance_expiry_in_minutes : typing.Optional[int]
            Optional expiry time for the balance in minutes (must be greater than 0 if provided).

        contact_id : typing.Optional[int]
            Unique identifier of the contact involved in the transaction (required unless `LoyaltySubscriptionId` is provided).

        event_time : typing.Optional[str]
            Optional timestamp specifying when the transaction occurred.

        meta : typing.Optional[typing.Dict[str, typing.Any]]
            Optional metadata associated with the transaction.

        ttl : typing.Optional[int]
            Optional time-to-live for the transaction (must be greater than 0 if provided).

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Transaction]
            Transaction information
        """
        _response = self._client_wrapper.httpx_client.request(
            f"loyalty/balance/programs/{jsonable_encoder(pid)}/transactions",
            method="POST",
            json={
                "LoyaltySubscriptionId": loyalty_subscription_id,
                "amount": amount,
                "autoComplete": auto_complete,
                "balanceDefinitionId": balance_definition_id,
                "balanceExpiryInMinutes": balance_expiry_in_minutes,
                "contactId": contact_id,
                "eventTime": event_time,
                "meta": meta,
                "ttl": ttl,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Transaction,
                    construct_type(
                        type_=Transaction,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorModel,
                        construct_type(
                            type_=ErrorModel,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def cancel_transaction(
        self, pid: str, tid: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[Transaction]:
        """
        Cancels transaction

        Parameters
        ----------
        pid : str
            Loyalty Program Id

        tid : str
            Transaction Id

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Transaction]
            Transaction information
        """
        _response = self._client_wrapper.httpx_client.request(
            f"loyalty/balance/programs/{jsonable_encoder(pid)}/transactions/{jsonable_encoder(tid)}/cancel",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Transaction,
                    construct_type(
                        type_=Transaction,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorModel,
                        construct_type(
                            type_=ErrorModel,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def complete_transaction(
        self, pid: str, tid: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[Transaction]:
        """
        Completes transaction

        Parameters
        ----------
        pid : str
            Loyalty Program Id

        tid : str
            Transaction Id

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Transaction]
            Transaction information
        """
        _response = self._client_wrapper.httpx_client.request(
            f"loyalty/balance/programs/{jsonable_encoder(pid)}/transactions/{jsonable_encoder(tid)}/complete",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Transaction,
                    construct_type(
                        type_=Transaction,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorModel,
                        construct_type(
                            type_=ErrorModel,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawBalanceClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def get_active_balances_api(
        self,
        pid: str,
        *,
        contact_id: int,
        balance_definition_id: str,
        limit: typing.Optional[int] = None,
        offset: typing.Optional[int] = None,
        sort_field: typing.Optional[str] = None,
        sort: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[BalanceLimit]:
        """
        Returns Active Balances

        Parameters
        ----------
        pid : str
            Loyalty Program Id

        contact_id : int
            Contact ID

        balance_definition_id : str
            Balance Definition ID

        limit : typing.Optional[int]
            Limit

        offset : typing.Optional[int]
            Offset

        sort_field : typing.Optional[str]
            Sort Field

        sort : typing.Optional[str]
            Sort Order

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[BalanceLimit]
            Successful retrieval of active balance
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"loyalty/balance/programs/{jsonable_encoder(pid)}/active-balance",
            method="GET",
            params={
                "limit": limit,
                "offset": offset,
                "sort_field": sort_field,
                "sort": sort,
                "contact_id": contact_id,
                "balance_definition_id": balance_definition_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    BalanceLimit,
                    construct_type(
                        type_=BalanceLimit,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorModel,
                        construct_type(
                            type_=ErrorModel,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_balance_definition_list(
        self,
        pid: str,
        *,
        limit: typing.Optional[int] = None,
        offset: typing.Optional[int] = None,
        sort_field: typing.Optional[GetBalanceDefinitionListRequestSortField] = None,
        sort: typing.Optional[GetBalanceDefinitionListRequestSort] = None,
        version: typing.Optional[GetBalanceDefinitionListRequestVersion] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[GetBalanceDefinitionListResponse]:
        """
        Returns balance definition page

        Parameters
        ----------
        pid : str
            Loyalty Program Id

        limit : typing.Optional[int]
            Limit the number of records returned

        offset : typing.Optional[int]
            Offset to paginate records

        sort_field : typing.Optional[GetBalanceDefinitionListRequestSortField]
            Field to sort by

        sort : typing.Optional[GetBalanceDefinitionListRequestSort]
            Sort direction

        version : typing.Optional[GetBalanceDefinitionListRequestVersion]
            Version

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetBalanceDefinitionListResponse]
            Successful retrieval of balance definition page
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"loyalty/balance/programs/{jsonable_encoder(pid)}/balance-definitions",
            method="GET",
            params={
                "limit": limit,
                "offset": offset,
                "sortField": sort_field,
                "sort": sort,
                "version": version,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetBalanceDefinitionListResponse,
                    construct_type(
                        type_=GetBalanceDefinitionListResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorModel,
                        construct_type(
                            type_=ErrorModel,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def create_balance_definition(
        self,
        pid: str,
        *,
        name: str,
        unit: PostLoyaltyBalanceProgramsPidBalanceDefinitionsRequestUnit,
        balance_availability_duration_modifier: typing.Optional[
            PostLoyaltyBalanceProgramsPidBalanceDefinitionsRequestBalanceAvailabilityDurationModifier
        ] = OMIT,
        balance_availability_duration_unit: typing.Optional[
            PostLoyaltyBalanceProgramsPidBalanceDefinitionsRequestBalanceAvailabilityDurationUnit
        ] = OMIT,
        balance_availability_duration_value: typing.Optional[int] = OMIT,
        balance_expiration_date: typing.Optional[dt.date] = OMIT,
        balance_option_amount_overtaking_strategy: typing.Optional[
            PostLoyaltyBalanceProgramsPidBalanceDefinitionsRequestBalanceOptionAmountOvertakingStrategy
        ] = OMIT,
        balance_option_credit_rounding: typing.Optional[
            PostLoyaltyBalanceProgramsPidBalanceDefinitionsRequestBalanceOptionCreditRounding
        ] = OMIT,
        balance_option_debit_rounding: typing.Optional[
            PostLoyaltyBalanceProgramsPidBalanceDefinitionsRequestBalanceOptionDebitRounding
        ] = OMIT,
        description: typing.Optional[str] = OMIT,
        image_ref: typing.Optional[str] = OMIT,
        max_amount: typing.Optional[float] = OMIT,
        max_credit_amount_limit: typing.Optional[float] = OMIT,
        max_debit_amount_limit: typing.Optional[float] = OMIT,
        meta: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        min_amount: typing.Optional[float] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[BalanceDefinition]:
        """
        Creates balance definition and returns information

        Parameters
        ----------
        pid : str
            Loyalty Program Id

        name : str
            Name of the balance definition.

        unit : PostLoyaltyBalanceProgramsPidBalanceDefinitionsRequestUnit
            Unit of balance measurement.

        balance_availability_duration_modifier : typing.Optional[PostLoyaltyBalanceProgramsPidBalanceDefinitionsRequestBalanceAvailabilityDurationModifier]
            Defines when the balance expires within the selected duration.

        balance_availability_duration_unit : typing.Optional[PostLoyaltyBalanceProgramsPidBalanceDefinitionsRequestBalanceAvailabilityDurationUnit]
            Unit of time for balance validity.

        balance_availability_duration_value : typing.Optional[int]
            Number of time units before the balance expires.

        balance_expiration_date : typing.Optional[dt.date]
            Fixed expiration date (`dd/mm` format) as an alternative to duration-based expiry.

        balance_option_amount_overtaking_strategy : typing.Optional[PostLoyaltyBalanceProgramsPidBalanceDefinitionsRequestBalanceOptionAmountOvertakingStrategy]
            Defines whether partial credit is allowed when reaching max balance.

        balance_option_credit_rounding : typing.Optional[PostLoyaltyBalanceProgramsPidBalanceDefinitionsRequestBalanceOptionCreditRounding]
            Defines rounding strategy for credit transactions.

        balance_option_debit_rounding : typing.Optional[PostLoyaltyBalanceProgramsPidBalanceDefinitionsRequestBalanceOptionDebitRounding]
            Defines rounding strategy for debit transactions.

        description : typing.Optional[str]
            Short description of the balance definition.

        image_ref : typing.Optional[str]
            URL of an optional image reference.

        max_amount : typing.Optional[float]
            Maximum allowable balance amount.

        max_credit_amount_limit : typing.Optional[float]
            Maximum credit allowed per operation.

        max_debit_amount_limit : typing.Optional[float]
            Maximum debit allowed per operation.

        meta : typing.Optional[typing.Dict[str, typing.Any]]
            Additional metadata for the balance definition.

        min_amount : typing.Optional[float]
            Minimum allowable balance amount.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[BalanceDefinition]
            Successful creation of balance definition
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"loyalty/balance/programs/{jsonable_encoder(pid)}/balance-definitions",
            method="POST",
            json={
                "balanceAvailabilityDurationModifier": balance_availability_duration_modifier,
                "balanceAvailabilityDurationUnit": balance_availability_duration_unit,
                "balanceAvailabilityDurationValue": balance_availability_duration_value,
                "balanceExpirationDate": balance_expiration_date,
                "balanceOptionAmountOvertakingStrategy": balance_option_amount_overtaking_strategy,
                "balanceOptionCreditRounding": balance_option_credit_rounding,
                "balanceOptionDebitRounding": balance_option_debit_rounding,
                "description": description,
                "imageRef": image_ref,
                "maxAmount": max_amount,
                "maxCreditAmountLimit": max_credit_amount_limit,
                "maxDebitAmountLimit": max_debit_amount_limit,
                "meta": meta,
                "minAmount": min_amount,
                "name": name,
                "unit": unit,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    BalanceDefinition,
                    construct_type(
                        type_=BalanceDefinition,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorModel,
                        construct_type(
                            type_=ErrorModel,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_balance_definition(
        self,
        pid: str,
        bdid: str,
        *,
        version: typing.Optional[GetBalanceDefinitionRequestVersion] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[BalanceDefinition]:
        """
        Returns balance definition

        Parameters
        ----------
        pid : str
            Loyalty Program Id

        bdid : str
            Balance Definition Id

        version : typing.Optional[GetBalanceDefinitionRequestVersion]
            Version

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[BalanceDefinition]
            Successful retrieval of balance definition
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"loyalty/balance/programs/{jsonable_encoder(pid)}/balance-definitions/{jsonable_encoder(bdid)}",
            method="GET",
            params={
                "version": version,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    BalanceDefinition,
                    construct_type(
                        type_=BalanceDefinition,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorModel,
                        construct_type(
                            type_=ErrorModel,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def update_balance_definition(
        self,
        pid: str,
        bdid: str,
        *,
        name: str,
        unit: UpdateBalanceDefinitionRequestUnit,
        balance_availability_duration_modifier: typing.Optional[
            UpdateBalanceDefinitionRequestBalanceAvailabilityDurationModifier
        ] = OMIT,
        balance_availability_duration_unit: typing.Optional[
            UpdateBalanceDefinitionRequestBalanceAvailabilityDurationUnit
        ] = OMIT,
        balance_availability_duration_value: typing.Optional[int] = OMIT,
        balance_expiration_date: typing.Optional[str] = OMIT,
        balance_option_amount_overtaking_strategy: typing.Optional[
            UpdateBalanceDefinitionRequestBalanceOptionAmountOvertakingStrategy
        ] = OMIT,
        balance_option_credit_rounding: typing.Optional[
            UpdateBalanceDefinitionRequestBalanceOptionCreditRounding
        ] = OMIT,
        balance_option_debit_rounding: typing.Optional[UpdateBalanceDefinitionRequestBalanceOptionDebitRounding] = OMIT,
        description: typing.Optional[str] = OMIT,
        image_ref: typing.Optional[str] = OMIT,
        max_amount: typing.Optional[float] = OMIT,
        max_credit_amount_limit: typing.Optional[float] = OMIT,
        max_debit_amount_limit: typing.Optional[float] = OMIT,
        meta: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        min_amount: typing.Optional[float] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[BalanceDefinition]:
        """
        Updates Balance definition

        Parameters
        ----------
        pid : str
            Loyalty Program Id

        bdid : str
            Balance Definition Id

        name : str
            Name of the balance definition.

        unit : UpdateBalanceDefinitionRequestUnit
            Unit of balance measurement.

        balance_availability_duration_modifier : typing.Optional[UpdateBalanceDefinitionRequestBalanceAvailabilityDurationModifier]
            Defines when the balance expires within the selected duration.

        balance_availability_duration_unit : typing.Optional[UpdateBalanceDefinitionRequestBalanceAvailabilityDurationUnit]
            Unit of time for balance validity.

        balance_availability_duration_value : typing.Optional[int]
            Number of time units before the balance expires.

        balance_expiration_date : typing.Optional[str]
            Expiration date (`dd/mm` format) or empty if not applicable.

        balance_option_amount_overtaking_strategy : typing.Optional[UpdateBalanceDefinitionRequestBalanceOptionAmountOvertakingStrategy]
            Defines whether partial credit is allowed when reaching max balance.

        balance_option_credit_rounding : typing.Optional[UpdateBalanceDefinitionRequestBalanceOptionCreditRounding]
            Rounding strategy for credit transactions.

        balance_option_debit_rounding : typing.Optional[UpdateBalanceDefinitionRequestBalanceOptionDebitRounding]
            Rounding strategy for debit transactions.

        description : typing.Optional[str]
            Short description of the balance definition.

        image_ref : typing.Optional[str]
            URL of an optional image reference.

        max_amount : typing.Optional[float]
            Maximum allowable balance amount.

        max_credit_amount_limit : typing.Optional[float]
            Maximum credit allowed per operation.

        max_debit_amount_limit : typing.Optional[float]
            Maximum debit allowed per operation.

        meta : typing.Optional[typing.Dict[str, typing.Any]]
            Optional metadata for the balance definition.

        min_amount : typing.Optional[float]
            Minimum allowable balance amount.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[BalanceDefinition]
            Successful update of balance definition
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"loyalty/balance/programs/{jsonable_encoder(pid)}/balance-definitions/{jsonable_encoder(bdid)}",
            method="PUT",
            json={
                "balanceAvailabilityDurationModifier": balance_availability_duration_modifier,
                "balanceAvailabilityDurationUnit": balance_availability_duration_unit,
                "balanceAvailabilityDurationValue": balance_availability_duration_value,
                "balanceExpirationDate": balance_expiration_date,
                "balanceOptionAmountOvertakingStrategy": balance_option_amount_overtaking_strategy,
                "balanceOptionCreditRounding": balance_option_credit_rounding,
                "balanceOptionDebitRounding": balance_option_debit_rounding,
                "description": description,
                "imageRef": image_ref,
                "maxAmount": max_amount,
                "maxCreditAmountLimit": max_credit_amount_limit,
                "maxDebitAmountLimit": max_debit_amount_limit,
                "meta": meta,
                "minAmount": min_amount,
                "name": name,
                "unit": unit,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    BalanceDefinition,
                    construct_type(
                        type_=BalanceDefinition,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorModel,
                        construct_type(
                            type_=ErrorModel,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 424:
                raise FailedDependencyError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def delete_balance_definition(
        self, pid: str, bdid: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[None]:
        """
        Delete Balance definition

        Parameters
        ----------
        pid : str
            Loyalty Program Id

        bdid : str
            Balance Definition Id

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"loyalty/balance/programs/{jsonable_encoder(pid)}/balance-definitions/{jsonable_encoder(bdid)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorModel,
                        construct_type(
                            type_=ErrorModel,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def create_balance_limit(
        self,
        pid: str,
        bdid: str,
        *,
        constraint_type: CreateBalanceLimitRequestConstraintType,
        duration_unit: CreateBalanceLimitRequestDurationUnit,
        duration_value: int,
        transaction_type: CreateBalanceLimitRequestTransactionType,
        value: int,
        sliding_schedule: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[BalanceLimit]:
        """
        Creates balance limit and sends the created UUID along with the data

        Parameters
        ----------
        pid : str
            Loyalty Program Id

        bdid : str
            Balance Definition Id

        constraint_type : CreateBalanceLimitRequestConstraintType
            Defines whether the limit applies to transaction count or amount.

        duration_unit : CreateBalanceLimitRequestDurationUnit
            Unit of time for which the limit is applicable.

        duration_value : int
            Number of time units for the balance limit.

        transaction_type : CreateBalanceLimitRequestTransactionType
            Specifies whether the limit applies to credit or debit transactions.

        value : int
            Maximum allowed value for the specified constraint type.

        sliding_schedule : typing.Optional[bool]
            Determines if the limit resets on a rolling schedule.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[BalanceLimit]
            Successful creation of balance limit
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"loyalty/balance/programs/{jsonable_encoder(pid)}/balance-definitions/{jsonable_encoder(bdid)}/limits",
            method="POST",
            json={
                "constraintType": constraint_type,
                "durationUnit": duration_unit,
                "durationValue": duration_value,
                "slidingSchedule": sliding_schedule,
                "transactionType": transaction_type,
                "value": value,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    BalanceLimit,
                    construct_type(
                        type_=BalanceLimit,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorModel,
                        construct_type(
                            type_=ErrorModel,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 424:
                raise FailedDependencyError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_balance_limit(
        self,
        pid: str,
        bdid: str,
        blid: str,
        *,
        version: typing.Optional[GetBalanceLimitRequestVersion] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[BalanceLimit]:
        """
        Fetches balance limits and send the created UUID along with the data

        Parameters
        ----------
        pid : str
            Loyalty Program Id

        bdid : str
            Balance Definition Id

        blid : str
            Balance Limit Id

        version : typing.Optional[GetBalanceLimitRequestVersion]
            Version

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[BalanceLimit]
            Successful retrieval of balance limit
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"loyalty/balance/programs/{jsonable_encoder(pid)}/balance-definitions/{jsonable_encoder(bdid)}/limits/{jsonable_encoder(blid)}",
            method="GET",
            params={
                "version": version,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    BalanceLimit,
                    construct_type(
                        type_=BalanceLimit,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorModel,
                        construct_type(
                            type_=ErrorModel,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def update_balance_limit(
        self,
        pid: str,
        bdid: str,
        blid: str,
        *,
        constraint_type: UpdateBalanceLimitRequestConstraintType,
        duration_unit: UpdateBalanceLimitRequestDurationUnit,
        duration_value: int,
        transaction_type: UpdateBalanceLimitRequestTransactionType,
        value: int,
        sliding_schedule: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[BalanceLimit]:
        """
        Updates balance limit

        Parameters
        ----------
        pid : str
            Loyalty Program Id

        bdid : str
            Balance Definition Id

        blid : str
            Balance Limit Id

        constraint_type : UpdateBalanceLimitRequestConstraintType
            Defines whether the limit applies to transaction count or amount.

        duration_unit : UpdateBalanceLimitRequestDurationUnit
            Unit of time for which the limit is applicable.

        duration_value : int
            Number of time units for the balance limit.

        transaction_type : UpdateBalanceLimitRequestTransactionType
            Specifies whether the limit applies to credit or debit transactions.

        value : int
            Maximum allowed value for the specified constraint type.

        sliding_schedule : typing.Optional[bool]
            Determines if the limit resets on a rolling schedule.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[BalanceLimit]
            Successful update of balance limit
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"loyalty/balance/programs/{jsonable_encoder(pid)}/balance-definitions/{jsonable_encoder(bdid)}/limits/{jsonable_encoder(blid)}",
            method="PUT",
            json={
                "constraintType": constraint_type,
                "durationUnit": duration_unit,
                "durationValue": duration_value,
                "slidingSchedule": sliding_schedule,
                "transactionType": transaction_type,
                "value": value,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    BalanceLimit,
                    construct_type(
                        type_=BalanceLimit,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorModel,
                        construct_type(
                            type_=ErrorModel,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def delete_balance_limit(
        self, pid: str, bdid: str, blid: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[None]:
        """
        Delete balance limit

        Parameters
        ----------
        pid : str
            Loyalty Program Id

        bdid : str
            Balance Definition Id

        blid : str
            Balance Limit Id

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"loyalty/balance/programs/{jsonable_encoder(pid)}/balance-definitions/{jsonable_encoder(bdid)}/limits/{jsonable_encoder(blid)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorModel,
                        construct_type(
                            type_=ErrorModel,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_contact_balances(
        self, pid: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[GetContactBalancesResponse]:
        """
        Returns balance list

        Parameters
        ----------
        pid : str
            Loyalty Program Id

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetContactBalancesResponse]
            Successful retrieval of contact balance
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"loyalty/balance/programs/{jsonable_encoder(pid)}/contact-balances",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetContactBalancesResponse,
                    construct_type(
                        type_=GetContactBalancesResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorModel,
                        construct_type(
                            type_=ErrorModel,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def create_balance_order(
        self,
        pid: str,
        *,
        amount: float,
        balance_definition_id: str,
        contact_id: int,
        due_at: str,
        source: str,
        expires_at: typing.Optional[str] = OMIT,
        meta: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[CreateBalanceOrderResponse]:
        """
        Returns created order

        Parameters
        ----------
        pid : str
            Loyalty Program Id

        amount : float
            Order amount (must be non-zero).

        balance_definition_id : str
            Unique identifier (UUID) of the associated balance definition.

        contact_id : int
            Unique identifier of the contact placing the order (must be  1).

        due_at : str
            RFC3339 timestamp specifying when the order is due.

        source : str
            Specifies the origin of the order (`engine` or `user`).

        expires_at : typing.Optional[str]
            Optional RFC3339 timestamp defining order expiration.

        meta : typing.Optional[typing.Dict[str, typing.Any]]
            Optional metadata associated with the order.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[CreateBalanceOrderResponse]
            Successful creation of order
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"loyalty/balance/programs/{jsonable_encoder(pid)}/create-order",
            method="POST",
            json={
                "amount": amount,
                "balanceDefinitionId": balance_definition_id,
                "contactId": contact_id,
                "dueAt": due_at,
                "expiresAt": expires_at,
                "meta": meta,
                "source": source,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CreateBalanceOrderResponse,
                    construct_type(
                        type_=CreateBalanceOrderResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorModel,
                        construct_type(
                            type_=ErrorModel,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_subscription_balances(
        self, pid: str, cid: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[GetSubscriptionBalancesResponse]:
        """
        Returns subscription balances

        Parameters
        ----------
        pid : str
            Loyalty Program Id

        cid : str
            Contact Id

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetSubscriptionBalancesResponse]
            Successful retrieval of contact balance
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"loyalty/balance/programs/{jsonable_encoder(pid)}/subscriptions/{jsonable_encoder(cid)}/balances",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetSubscriptionBalancesResponse,
                    construct_type(
                        type_=GetSubscriptionBalancesResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorModel,
                        construct_type(
                            type_=ErrorModel,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def create_subscription_balances(
        self, pid: str, cid: str, *, balance_definition_id: str, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[PostLoyaltyBalanceProgramsPidSubscriptionsCidBalancesResponse]:
        """
        Creates a balance for a contact

        Parameters
        ----------
        pid : str
            Loyalty Program Id

        cid : str
            Contact Id

        balance_definition_id : str
            Unique identifier (UUID) of the balance definition associated with the new balance.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[PostLoyaltyBalanceProgramsPidSubscriptionsCidBalancesResponse]
            Successful creation of balance
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"loyalty/balance/programs/{jsonable_encoder(pid)}/subscriptions/{jsonable_encoder(cid)}/balances",
            method="POST",
            json={
                "balanceDefinitionId": balance_definition_id,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PostLoyaltyBalanceProgramsPidSubscriptionsCidBalancesResponse,
                    construct_type(
                        type_=PostLoyaltyBalanceProgramsPidSubscriptionsCidBalancesResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorModel,
                        construct_type(
                            type_=ErrorModel,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_transaction_history_api(
        self,
        pid: str,
        *,
        contact_id: int,
        balance_definition_id: str,
        limit: typing.Optional[int] = None,
        offset: typing.Optional[int] = None,
        sort_field: typing.Optional[GetLoyaltyBalanceProgramsPidTransactionHistoryRequestSortField] = None,
        sort: typing.Optional[GetLoyaltyBalanceProgramsPidTransactionHistoryRequestSort] = None,
        filters: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[GetLoyaltyBalanceProgramsPidTransactionHistoryResponse]:
        """
        Returns transaction history

        Parameters
        ----------
        pid : str
            Loyalty Program Id

        contact_id : int
            Contact ID

        balance_definition_id : str
            Balance Definition ID

        limit : typing.Optional[int]
            Limit the number of records returned

        offset : typing.Optional[int]
            Skip a number of records

        sort_field : typing.Optional[GetLoyaltyBalanceProgramsPidTransactionHistoryRequestSortField]
            Field to sort by

        sort : typing.Optional[GetLoyaltyBalanceProgramsPidTransactionHistoryRequestSort]
            Sort order, either asc or desc

        filters : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            Filters to apply

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetLoyaltyBalanceProgramsPidTransactionHistoryResponse]
            Successful retrieval of transaction history
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"loyalty/balance/programs/{jsonable_encoder(pid)}/transaction-history",
            method="GET",
            params={
                "limit": limit,
                "offset": offset,
                "sort_field": sort_field,
                "sort": sort,
                "contact_id": contact_id,
                "balance_definition_id": balance_definition_id,
                "filters": filters,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetLoyaltyBalanceProgramsPidTransactionHistoryResponse,
                    construct_type(
                        type_=GetLoyaltyBalanceProgramsPidTransactionHistoryResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorModel,
                        construct_type(
                            type_=ErrorModel,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def begin_transaction(
        self,
        pid: str,
        *,
        amount: float,
        balance_definition_id: str,
        loyalty_subscription_id: typing.Optional[str] = OMIT,
        auto_complete: typing.Optional[bool] = OMIT,
        balance_expiry_in_minutes: typing.Optional[int] = OMIT,
        contact_id: typing.Optional[int] = OMIT,
        event_time: typing.Optional[str] = OMIT,
        meta: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        ttl: typing.Optional[int] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[Transaction]:
        """
        Creates new transaction and returns information

        Parameters
        ----------
        pid : str
            Loyalty Program Id

        amount : float
            Transaction amount (must be provided).

        balance_definition_id : str
            Unique identifier (UUID) of the associated balance definition.

        loyalty_subscription_id : typing.Optional[str]
            Unique identifier for the loyalty subscription (required unless `contactId` is provided).

        auto_complete : typing.Optional[bool]
            Whether the transaction should be automatically completed.

        balance_expiry_in_minutes : typing.Optional[int]
            Optional expiry time for the balance in minutes (must be greater than 0 if provided).

        contact_id : typing.Optional[int]
            Unique identifier of the contact involved in the transaction (required unless `LoyaltySubscriptionId` is provided).

        event_time : typing.Optional[str]
            Optional timestamp specifying when the transaction occurred.

        meta : typing.Optional[typing.Dict[str, typing.Any]]
            Optional metadata associated with the transaction.

        ttl : typing.Optional[int]
            Optional time-to-live for the transaction (must be greater than 0 if provided).

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Transaction]
            Transaction information
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"loyalty/balance/programs/{jsonable_encoder(pid)}/transactions",
            method="POST",
            json={
                "LoyaltySubscriptionId": loyalty_subscription_id,
                "amount": amount,
                "autoComplete": auto_complete,
                "balanceDefinitionId": balance_definition_id,
                "balanceExpiryInMinutes": balance_expiry_in_minutes,
                "contactId": contact_id,
                "eventTime": event_time,
                "meta": meta,
                "ttl": ttl,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Transaction,
                    construct_type(
                        type_=Transaction,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorModel,
                        construct_type(
                            type_=ErrorModel,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def cancel_transaction(
        self, pid: str, tid: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[Transaction]:
        """
        Cancels transaction

        Parameters
        ----------
        pid : str
            Loyalty Program Id

        tid : str
            Transaction Id

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Transaction]
            Transaction information
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"loyalty/balance/programs/{jsonable_encoder(pid)}/transactions/{jsonable_encoder(tid)}/cancel",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Transaction,
                    construct_type(
                        type_=Transaction,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorModel,
                        construct_type(
                            type_=ErrorModel,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def complete_transaction(
        self, pid: str, tid: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[Transaction]:
        """
        Completes transaction

        Parameters
        ----------
        pid : str
            Loyalty Program Id

        tid : str
            Transaction Id

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Transaction]
            Transaction information
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"loyalty/balance/programs/{jsonable_encoder(pid)}/transactions/{jsonable_encoder(tid)}/complete",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Transaction,
                    construct_type(
                        type_=Transaction,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorModel,
                        construct_type(
                            type_=ErrorModel,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)
