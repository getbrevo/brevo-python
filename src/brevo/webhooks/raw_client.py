# This file was auto-generated by Fern from our API Definition.

import typing
from json.decoder import JSONDecodeError

from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.http_response import AsyncHttpResponse, HttpResponse
from ..core.jsonable_encoder import jsonable_encoder
from ..core.request_options import RequestOptions
from ..core.serialization import convert_and_respect_annotation_metadata
from ..core.unchecked_base_model import construct_type
from ..errors.bad_request_error import BadRequestError
from ..errors.not_found_error import NotFoundError
from ..types.get_webhook import GetWebhook
from .types.create_webhook_request_auth import CreateWebhookRequestAuth
from .types.create_webhook_request_channel import CreateWebhookRequestChannel
from .types.create_webhook_request_events_item import CreateWebhookRequestEventsItem
from .types.create_webhook_request_headers_item import CreateWebhookRequestHeadersItem
from .types.create_webhook_request_type import CreateWebhookRequestType
from .types.create_webhook_response import CreateWebhookResponse
from .types.export_webhooks_history_request_event import ExportWebhooksHistoryRequestEvent
from .types.export_webhooks_history_request_type import ExportWebhooksHistoryRequestType
from .types.export_webhooks_history_response import ExportWebhooksHistoryResponse
from .types.get_webhooks_request_sort import GetWebhooksRequestSort
from .types.get_webhooks_request_type import GetWebhooksRequestType
from .types.get_webhooks_response import GetWebhooksResponse
from .types.update_webhook_request_auth import UpdateWebhookRequestAuth
from .types.update_webhook_request_events_item import UpdateWebhookRequestEventsItem
from .types.update_webhook_request_headers_item import UpdateWebhookRequestHeadersItem

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawWebhooksClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def get_webhooks(
        self,
        *,
        type: typing.Optional[GetWebhooksRequestType] = None,
        sort: typing.Optional[GetWebhooksRequestSort] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[GetWebhooksResponse]:
        """
        Retrieves all webhooks from your Brevo account with filtering and sorting options.

        Use this to:
        - Monitor webhook configurations and event handling
        - List webhooks by type (transactional, marketing, inbound)
        - Review webhook endpoints and authentication
        - Track webhook creation and modification history
        - Audit webhook event subscriptions

        Key information returned:
        - Complete webhook details and configuration
        - Event types and channel subscriptions
        - Authentication and security settings
        - Webhook URLs and custom headers
        - Creation and modification timestamps

        Parameters
        ----------
        type : typing.Optional[GetWebhooksRequestType]
            Filter on webhook type

        sort : typing.Optional[GetWebhooksRequestSort]
            Sort the results in the ascending/descending order of webhook creation

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetWebhooksResponse]
            Webhooks informations
        """
        _response = self._client_wrapper.httpx_client.request(
            "webhooks",
            method="GET",
            params={
                "type": type,
                "sort": sort,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetWebhooksResponse,
                    construct_type(
                        type_=GetWebhooksResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def create_webhook(
        self,
        *,
        events: typing.Sequence[CreateWebhookRequestEventsItem],
        url: str,
        auth: typing.Optional[CreateWebhookRequestAuth] = OMIT,
        batched: typing.Optional[bool] = OMIT,
        channel: typing.Optional[CreateWebhookRequestChannel] = OMIT,
        description: typing.Optional[str] = OMIT,
        domain: typing.Optional[str] = OMIT,
        headers: typing.Optional[typing.Sequence[CreateWebhookRequestHeadersItem]] = OMIT,
        type: typing.Optional[CreateWebhookRequestType] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[CreateWebhookResponse]:
        """
        Creates a new webhook to receive real-time notifications for specified events.

        Use this to:
        - Set up event notifications for transactional or marketing emails
        - Configure webhook endpoints for campaign tracking
        - Enable real-time monitoring of email delivery status
        - Subscribe to contact list changes and updates
        - Implement custom event handling and automation

        Key information returned:
        - Created webhook ID and configuration
        - Success confirmation and setup details

        Parameters
        ----------
        events : typing.Sequence[CreateWebhookRequestEventsItem]
            - Events triggering the webhook. Possible values for
            **Transactional** type webhook: #### `sent` OR `request`,
            `delivered`, `hardBounce`, `softBounce`, `blocked`, `spam`,
            `invalid`, `deferred`, `click`, `opened`, `uniqueOpened` and
            `unsubscribed` - Possible values for **Marketing** type webhook:
            #### `spam`, `opened`, `click`, `hardBounce`, `softBounce`,
            `unsubscribed`, `listAddition` & `delivered` - Possible values
            for **Inbound** type webhook: #### `inboundEmailProcessed` -
            Possible values for type **Transactional** and channel **SMS**
            ####
            `accepted`,`delivered`,`softBounce`,`hardBounce`,`unsubscribe`,`reply`,
            `subscribe`,`sent`,`blacklisted`,`skip` - Possible values for
            type **Marketing**  channel **SMS** ####
            `sent`,`delivered`,`softBounce`,`hardBounce`,`unsubscribe`,`reply`,
            `subscribe`,`skip`

        url : str
            URL of the webhook

        auth : typing.Optional[CreateWebhookRequestAuth]
            Add authentication on webhook url

        batched : typing.Optional[bool]
            To send batched webhooks

        channel : typing.Optional[CreateWebhookRequestChannel]
            channel of webhook

        description : typing.Optional[str]
            Description of the webhook

        domain : typing.Optional[str]
            Inbound domain of webhook, required in case of event type
            `inbound`

        headers : typing.Optional[typing.Sequence[CreateWebhookRequestHeadersItem]]
            Custom headers to be send with webhooks

        type : typing.Optional[CreateWebhookRequestType]
            Type of the webhook

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[CreateWebhookResponse]
            successfully created
        """
        _response = self._client_wrapper.httpx_client.request(
            "webhooks",
            method="POST",
            json={
                "auth": convert_and_respect_annotation_metadata(
                    object_=auth, annotation=CreateWebhookRequestAuth, direction="write"
                ),
                "batched": batched,
                "channel": channel,
                "description": description,
                "domain": domain,
                "events": events,
                "headers": convert_and_respect_annotation_metadata(
                    object_=headers, annotation=typing.Sequence[CreateWebhookRequestHeadersItem], direction="write"
                ),
                "type": type,
                "url": url,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CreateWebhookResponse,
                    construct_type(
                        type_=CreateWebhookResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def export_webhooks_history(
        self,
        *,
        event: ExportWebhooksHistoryRequestEvent,
        notify_url: str,
        type: ExportWebhooksHistoryRequestType,
        days: typing.Optional[int] = OMIT,
        email: typing.Optional[str] = OMIT,
        end_date: typing.Optional[str] = OMIT,
        message_id: typing.Optional[int] = OMIT,
        sort: typing.Optional[str] = OMIT,
        start_date: typing.Optional[str] = OMIT,
        webhook_id: typing.Optional[int] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[ExportWebhooksHistoryResponse]:
        """
        <Note title="This feature is available for Professional and Enterprise plans">
        To have it activated please send us a request and we will activate it for your account.
        </Note>

        Exports webhook event history to CSV format for analysis and reporting.

        Use this to:
        - Generate comprehensive webhook event reports
        - Analyze webhook delivery patterns and success rates
        - Export event data for external analysis tools
        - Create historical reports for compliance and auditing
        - Track webhook performance and reliability metrics

        Key information returned:
        - Process ID for tracking export completion
        - CSV file will be delivered to specified webhook URL

        Parameters
        ----------
        event : ExportWebhooksHistoryRequestEvent
            Filter the history for a specific event type

        notify_url : str
            Webhook URL to receive CSV file link

        type : ExportWebhooksHistoryRequestType
            Filter the history based on webhook type

        days : typing.Optional[int]
            Number of days in the past including today (positive
            integer). _Not compatible with 'startDate' and 'endDate'_

        email : typing.Optional[str]
            Filter the history for a specific email

        end_date : typing.Optional[str]
            Mandatory if startDate is used. Ending date of the report
            (YYYY-MM-DD). Must be greater than equal to startDate

        message_id : typing.Optional[int]
            Filter the history for a specific message id. Applicable
            only for transactional webhooks.

        sort : typing.Optional[str]
            Sorting order of records (asc or desc)

        start_date : typing.Optional[str]
            Mandatory if endDate is used. Starting date of the history
            (YYYY-MM-DD). Must be lower than equal to endDate

        webhook_id : typing.Optional[int]
            Filter the history for a specific webhook id

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ExportWebhooksHistoryResponse]
            process id created
        """
        _response = self._client_wrapper.httpx_client.request(
            "webhooks/export",
            method="POST",
            json={
                "days": days,
                "email": email,
                "endDate": end_date,
                "event": event,
                "messageId": message_id,
                "notifyURL": notify_url,
                "sort": sort,
                "startDate": start_date,
                "type": type,
                "webhookId": webhook_id,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ExportWebhooksHistoryResponse,
                    construct_type(
                        type_=ExportWebhooksHistoryResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_webhook(
        self, webhook_id: int, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[GetWebhook]:
        """
        Retrieves detailed information about a specific webhook configuration.

        Use this to:
        - Get complete webhook configuration and settings
        - Check webhook event subscriptions and triggers
        - Review authentication and security settings
        - Verify webhook URL and custom headers
        - Access webhook creation and modification history

        Key information returned:
        - Complete webhook details and configuration
        - Event types and channel subscriptions
        - Authentication credentials and methods
        - Custom headers and request settings
        - Webhook status and activity information

        Parameters
        ----------
        webhook_id : int
            Id of the webhook

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetWebhook]
            Webhook informations
        """
        _response = self._client_wrapper.httpx_client.request(
            f"webhooks/{jsonable_encoder(webhook_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetWebhook,
                    construct_type(
                        type_=GetWebhook,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def update_webhook(
        self,
        webhook_id: int,
        *,
        auth: typing.Optional[UpdateWebhookRequestAuth] = OMIT,
        batched: typing.Optional[bool] = OMIT,
        description: typing.Optional[str] = OMIT,
        domain: typing.Optional[str] = OMIT,
        events: typing.Optional[typing.Sequence[UpdateWebhookRequestEventsItem]] = OMIT,
        headers: typing.Optional[typing.Sequence[UpdateWebhookRequestHeadersItem]] = OMIT,
        url: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Updates an existing webhook configuration and event subscriptions.

        Use this to:
        - Modify webhook event subscriptions and triggers
        - Update webhook URL and endpoint configuration
        - Change authentication settings and credentials
        - Adjust custom headers and request parameters
        - Enable or disable specific webhook events

        Key information returned:
        - Success confirmation of webhook updates

        Parameters
        ----------
        webhook_id : int
            Id of the webhook

        auth : typing.Optional[UpdateWebhookRequestAuth]
            Add authentication on webhook url

        batched : typing.Optional[bool]
            To send batched webhooks

        description : typing.Optional[str]
            Description of the webhook

        domain : typing.Optional[str]
            Inbound domain of webhook, used in case of event type `inbound`

        events : typing.Optional[typing.Sequence[UpdateWebhookRequestEventsItem]]
            - Events triggering the webhook. Possible values for
            **Transactional** type webhook: #### `sent` OR `request`,
            `delivered`, `hardBounce`, `softBounce`, `blocked`, `spam`,
            `invalid`, `deferred`, `click`, `opened`, `uniqueOpened` and
            `unsubscribed` - Possible values for **Marketing** type webhook:
            #### `spam`, `opened`, `click`, `hardBounce`, `softBounce`,
            `unsubscribed`, `listAddition` & `delivered` - Possible values
            for **Inbound** type webhook: #### `inboundEmailProcessed`

        headers : typing.Optional[typing.Sequence[UpdateWebhookRequestHeadersItem]]
            Custom headers to be send with webhooks

        url : typing.Optional[str]
            URL of the webhook

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"webhooks/{jsonable_encoder(webhook_id)}",
            method="PUT",
            json={
                "auth": convert_and_respect_annotation_metadata(
                    object_=auth, annotation=UpdateWebhookRequestAuth, direction="write"
                ),
                "batched": batched,
                "description": description,
                "domain": domain,
                "events": events,
                "headers": convert_and_respect_annotation_metadata(
                    object_=headers, annotation=typing.Sequence[UpdateWebhookRequestHeadersItem], direction="write"
                ),
                "url": url,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def delete_webhook(
        self, webhook_id: int, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[None]:
        """
        Permanently deletes a webhook and stops all event notifications.

        Use this to:
        - Remove unused or obsolete webhook configurations
        - Clean up webhook endpoints and subscriptions
        - Stop event notifications to specific URLs
        - Maintain organized webhook management

        Key information returned:
        - Success confirmation of webhook deletion

        Parameters
        ----------
        webhook_id : int
            Id of the webhook

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"webhooks/{jsonable_encoder(webhook_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawWebhooksClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def get_webhooks(
        self,
        *,
        type: typing.Optional[GetWebhooksRequestType] = None,
        sort: typing.Optional[GetWebhooksRequestSort] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[GetWebhooksResponse]:
        """
        Retrieves all webhooks from your Brevo account with filtering and sorting options.

        Use this to:
        - Monitor webhook configurations and event handling
        - List webhooks by type (transactional, marketing, inbound)
        - Review webhook endpoints and authentication
        - Track webhook creation and modification history
        - Audit webhook event subscriptions

        Key information returned:
        - Complete webhook details and configuration
        - Event types and channel subscriptions
        - Authentication and security settings
        - Webhook URLs and custom headers
        - Creation and modification timestamps

        Parameters
        ----------
        type : typing.Optional[GetWebhooksRequestType]
            Filter on webhook type

        sort : typing.Optional[GetWebhooksRequestSort]
            Sort the results in the ascending/descending order of webhook creation

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetWebhooksResponse]
            Webhooks informations
        """
        _response = await self._client_wrapper.httpx_client.request(
            "webhooks",
            method="GET",
            params={
                "type": type,
                "sort": sort,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetWebhooksResponse,
                    construct_type(
                        type_=GetWebhooksResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def create_webhook(
        self,
        *,
        events: typing.Sequence[CreateWebhookRequestEventsItem],
        url: str,
        auth: typing.Optional[CreateWebhookRequestAuth] = OMIT,
        batched: typing.Optional[bool] = OMIT,
        channel: typing.Optional[CreateWebhookRequestChannel] = OMIT,
        description: typing.Optional[str] = OMIT,
        domain: typing.Optional[str] = OMIT,
        headers: typing.Optional[typing.Sequence[CreateWebhookRequestHeadersItem]] = OMIT,
        type: typing.Optional[CreateWebhookRequestType] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[CreateWebhookResponse]:
        """
        Creates a new webhook to receive real-time notifications for specified events.

        Use this to:
        - Set up event notifications for transactional or marketing emails
        - Configure webhook endpoints for campaign tracking
        - Enable real-time monitoring of email delivery status
        - Subscribe to contact list changes and updates
        - Implement custom event handling and automation

        Key information returned:
        - Created webhook ID and configuration
        - Success confirmation and setup details

        Parameters
        ----------
        events : typing.Sequence[CreateWebhookRequestEventsItem]
            - Events triggering the webhook. Possible values for
            **Transactional** type webhook: #### `sent` OR `request`,
            `delivered`, `hardBounce`, `softBounce`, `blocked`, `spam`,
            `invalid`, `deferred`, `click`, `opened`, `uniqueOpened` and
            `unsubscribed` - Possible values for **Marketing** type webhook:
            #### `spam`, `opened`, `click`, `hardBounce`, `softBounce`,
            `unsubscribed`, `listAddition` & `delivered` - Possible values
            for **Inbound** type webhook: #### `inboundEmailProcessed` -
            Possible values for type **Transactional** and channel **SMS**
            ####
            `accepted`,`delivered`,`softBounce`,`hardBounce`,`unsubscribe`,`reply`,
            `subscribe`,`sent`,`blacklisted`,`skip` - Possible values for
            type **Marketing**  channel **SMS** ####
            `sent`,`delivered`,`softBounce`,`hardBounce`,`unsubscribe`,`reply`,
            `subscribe`,`skip`

        url : str
            URL of the webhook

        auth : typing.Optional[CreateWebhookRequestAuth]
            Add authentication on webhook url

        batched : typing.Optional[bool]
            To send batched webhooks

        channel : typing.Optional[CreateWebhookRequestChannel]
            channel of webhook

        description : typing.Optional[str]
            Description of the webhook

        domain : typing.Optional[str]
            Inbound domain of webhook, required in case of event type
            `inbound`

        headers : typing.Optional[typing.Sequence[CreateWebhookRequestHeadersItem]]
            Custom headers to be send with webhooks

        type : typing.Optional[CreateWebhookRequestType]
            Type of the webhook

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[CreateWebhookResponse]
            successfully created
        """
        _response = await self._client_wrapper.httpx_client.request(
            "webhooks",
            method="POST",
            json={
                "auth": convert_and_respect_annotation_metadata(
                    object_=auth, annotation=CreateWebhookRequestAuth, direction="write"
                ),
                "batched": batched,
                "channel": channel,
                "description": description,
                "domain": domain,
                "events": events,
                "headers": convert_and_respect_annotation_metadata(
                    object_=headers, annotation=typing.Sequence[CreateWebhookRequestHeadersItem], direction="write"
                ),
                "type": type,
                "url": url,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CreateWebhookResponse,
                    construct_type(
                        type_=CreateWebhookResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def export_webhooks_history(
        self,
        *,
        event: ExportWebhooksHistoryRequestEvent,
        notify_url: str,
        type: ExportWebhooksHistoryRequestType,
        days: typing.Optional[int] = OMIT,
        email: typing.Optional[str] = OMIT,
        end_date: typing.Optional[str] = OMIT,
        message_id: typing.Optional[int] = OMIT,
        sort: typing.Optional[str] = OMIT,
        start_date: typing.Optional[str] = OMIT,
        webhook_id: typing.Optional[int] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[ExportWebhooksHistoryResponse]:
        """
        <Note title="This feature is available for Professional and Enterprise plans">
        To have it activated please send us a request and we will activate it for your account.
        </Note>

        Exports webhook event history to CSV format for analysis and reporting.

        Use this to:
        - Generate comprehensive webhook event reports
        - Analyze webhook delivery patterns and success rates
        - Export event data for external analysis tools
        - Create historical reports for compliance and auditing
        - Track webhook performance and reliability metrics

        Key information returned:
        - Process ID for tracking export completion
        - CSV file will be delivered to specified webhook URL

        Parameters
        ----------
        event : ExportWebhooksHistoryRequestEvent
            Filter the history for a specific event type

        notify_url : str
            Webhook URL to receive CSV file link

        type : ExportWebhooksHistoryRequestType
            Filter the history based on webhook type

        days : typing.Optional[int]
            Number of days in the past including today (positive
            integer). _Not compatible with 'startDate' and 'endDate'_

        email : typing.Optional[str]
            Filter the history for a specific email

        end_date : typing.Optional[str]
            Mandatory if startDate is used. Ending date of the report
            (YYYY-MM-DD). Must be greater than equal to startDate

        message_id : typing.Optional[int]
            Filter the history for a specific message id. Applicable
            only for transactional webhooks.

        sort : typing.Optional[str]
            Sorting order of records (asc or desc)

        start_date : typing.Optional[str]
            Mandatory if endDate is used. Starting date of the history
            (YYYY-MM-DD). Must be lower than equal to endDate

        webhook_id : typing.Optional[int]
            Filter the history for a specific webhook id

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ExportWebhooksHistoryResponse]
            process id created
        """
        _response = await self._client_wrapper.httpx_client.request(
            "webhooks/export",
            method="POST",
            json={
                "days": days,
                "email": email,
                "endDate": end_date,
                "event": event,
                "messageId": message_id,
                "notifyURL": notify_url,
                "sort": sort,
                "startDate": start_date,
                "type": type,
                "webhookId": webhook_id,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ExportWebhooksHistoryResponse,
                    construct_type(
                        type_=ExportWebhooksHistoryResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_webhook(
        self, webhook_id: int, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[GetWebhook]:
        """
        Retrieves detailed information about a specific webhook configuration.

        Use this to:
        - Get complete webhook configuration and settings
        - Check webhook event subscriptions and triggers
        - Review authentication and security settings
        - Verify webhook URL and custom headers
        - Access webhook creation and modification history

        Key information returned:
        - Complete webhook details and configuration
        - Event types and channel subscriptions
        - Authentication credentials and methods
        - Custom headers and request settings
        - Webhook status and activity information

        Parameters
        ----------
        webhook_id : int
            Id of the webhook

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetWebhook]
            Webhook informations
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"webhooks/{jsonable_encoder(webhook_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetWebhook,
                    construct_type(
                        type_=GetWebhook,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def update_webhook(
        self,
        webhook_id: int,
        *,
        auth: typing.Optional[UpdateWebhookRequestAuth] = OMIT,
        batched: typing.Optional[bool] = OMIT,
        description: typing.Optional[str] = OMIT,
        domain: typing.Optional[str] = OMIT,
        events: typing.Optional[typing.Sequence[UpdateWebhookRequestEventsItem]] = OMIT,
        headers: typing.Optional[typing.Sequence[UpdateWebhookRequestHeadersItem]] = OMIT,
        url: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Updates an existing webhook configuration and event subscriptions.

        Use this to:
        - Modify webhook event subscriptions and triggers
        - Update webhook URL and endpoint configuration
        - Change authentication settings and credentials
        - Adjust custom headers and request parameters
        - Enable or disable specific webhook events

        Key information returned:
        - Success confirmation of webhook updates

        Parameters
        ----------
        webhook_id : int
            Id of the webhook

        auth : typing.Optional[UpdateWebhookRequestAuth]
            Add authentication on webhook url

        batched : typing.Optional[bool]
            To send batched webhooks

        description : typing.Optional[str]
            Description of the webhook

        domain : typing.Optional[str]
            Inbound domain of webhook, used in case of event type `inbound`

        events : typing.Optional[typing.Sequence[UpdateWebhookRequestEventsItem]]
            - Events triggering the webhook. Possible values for
            **Transactional** type webhook: #### `sent` OR `request`,
            `delivered`, `hardBounce`, `softBounce`, `blocked`, `spam`,
            `invalid`, `deferred`, `click`, `opened`, `uniqueOpened` and
            `unsubscribed` - Possible values for **Marketing** type webhook:
            #### `spam`, `opened`, `click`, `hardBounce`, `softBounce`,
            `unsubscribed`, `listAddition` & `delivered` - Possible values
            for **Inbound** type webhook: #### `inboundEmailProcessed`

        headers : typing.Optional[typing.Sequence[UpdateWebhookRequestHeadersItem]]
            Custom headers to be send with webhooks

        url : typing.Optional[str]
            URL of the webhook

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"webhooks/{jsonable_encoder(webhook_id)}",
            method="PUT",
            json={
                "auth": convert_and_respect_annotation_metadata(
                    object_=auth, annotation=UpdateWebhookRequestAuth, direction="write"
                ),
                "batched": batched,
                "description": description,
                "domain": domain,
                "events": events,
                "headers": convert_and_respect_annotation_metadata(
                    object_=headers, annotation=typing.Sequence[UpdateWebhookRequestHeadersItem], direction="write"
                ),
                "url": url,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def delete_webhook(
        self, webhook_id: int, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[None]:
        """
        Permanently deletes a webhook and stops all event notifications.

        Use this to:
        - Remove unused or obsolete webhook configurations
        - Clean up webhook endpoints and subscriptions
        - Stop event notifications to specific URLs
        - Maintain organized webhook management

        Key information returned:
        - Success confirmation of webhook deletion

        Parameters
        ----------
        webhook_id : int
            Id of the webhook

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"webhooks/{jsonable_encoder(webhook_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)
