# This file was auto-generated by Fern from our API Definition.

import typing
from json.decoder import JSONDecodeError

from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.http_response import AsyncHttpResponse, HttpResponse
from ..core.request_options import RequestOptions
from ..core.serialization import convert_and_respect_annotation_metadata
from ..core.unchecked_base_model import construct_type
from ..errors.bad_request_error import BadRequestError
from ..errors.payment_required_error import PaymentRequiredError
from ..types.error_model import ErrorModel
from ..types.send_transac_sms_tag import SendTransacSmsTag
from ..types.send_transac_sms_type import SendTransacSmsType
from .types.get_sms_events_request_event import GetSmsEventsRequestEvent
from .types.get_sms_events_request_sort import GetSmsEventsRequestSort
from .types.get_sms_events_response import GetSmsEventsResponse
from .types.get_transac_aggregated_sms_report_response import GetTransacAggregatedSmsReportResponse
from .types.get_transac_sms_report_request_sort import GetTransacSmsReportRequestSort
from .types.get_transac_sms_report_response import GetTransacSmsReportResponse
from .types.send_async_transactional_sms_response import SendAsyncTransactionalSmsResponse
from .types.send_transac_sms_response import SendTransacSmsResponse

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawTransactionalSmsClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def send_async_transactional_sms(
        self,
        *,
        recipient: str,
        sender: str,
        organisation_prefix: typing.Optional[str] = OMIT,
        tag: typing.Optional[SendTransacSmsTag] = OMIT,
        type: typing.Optional[SendTransacSmsType] = OMIT,
        unicode_enabled: typing.Optional[bool] = OMIT,
        web_url: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[SendAsyncTransactionalSmsResponse]:
        """
        <Note>
        If the user includes stop code in the Transactional SMS, then it will be switched to Marketing SMS automatically and it will be interpreted as a Marketing SMS. To send Transactional SMS as Transactional, it is important not to use stop code.

        Note: For adding a stop code, client has to add reply STOP to [STOP_CODE] and the [STOP_CODE] will be replaced with the number.
        </Note>

        <Note title="For end users in France">
        Transactional SMS can be sent at any time without time restrictions. However, if a message is categorized as Marketing, it must adhere to specific time restrictions. Messages sent outside of these restricted hours will experience delays and will be processed during allowable times. Specifically, Marketing SMS cannot be processed between 10pm and 8am, on Sundays, and on French public holidays.
        </Note>

        Parameters
        ----------
        recipient : str
            Mobile number to send SMS with the country code

        sender : str
            Name of the sender. **The number of characters is limited to 11 for alphanumeric characters and 15 for numeric characters**

        organisation_prefix : typing.Optional[str]
            A recognizable prefix will ensure your audience knows who you are. Recommended by U.S. carriers. This will be added as your Brand Name before the message content. **Prefer verifying maximum length of 160 characters including this prefix in message content to avoid multiple sending of same sms.**

        tag : typing.Optional[SendTransacSmsTag]
            Tag of the message

        type : typing.Optional[SendTransacSmsType]
            Type of the SMS. Marketing SMS messages are those sent typically with marketing content. Transactional SMS messages are sent to individuals and are triggered in response to some action, such as a sign-up, purchase, etc.

        unicode_enabled : typing.Optional[bool]
            Format of the message. It indicates whether the content should be treated as unicode or not.

        web_url : typing.Optional[str]
            Webhook to call for each event triggered by the message (delivered etc.)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[SendAsyncTransactionalSmsResponse]
            SMS has been sent successfully to the recipient
        """
        _response = self._client_wrapper.httpx_client.request(
            "transactionalSMS/send",
            method="POST",
            json={
                "organisationPrefix": organisation_prefix,
                "recipient": recipient,
                "sender": sender,
                "tag": convert_and_respect_annotation_metadata(
                    object_=tag, annotation=SendTransacSmsTag, direction="write"
                ),
                "type": type,
                "unicodeEnabled": unicode_enabled,
                "webUrl": web_url,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SendAsyncTransactionalSmsResponse,
                    construct_type(
                        type_=SendAsyncTransactionalSmsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def send_transac_sms(
        self,
        *,
        recipient: str,
        sender: str,
        organisation_prefix: typing.Optional[str] = OMIT,
        tag: typing.Optional[SendTransacSmsTag] = OMIT,
        type: typing.Optional[SendTransacSmsType] = OMIT,
        unicode_enabled: typing.Optional[bool] = OMIT,
        web_url: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[SendTransacSmsResponse]:
        """
        Parameters
        ----------
        recipient : str
            Mobile number to send SMS with the country code

        sender : str
            Name of the sender. **The number of characters is limited to 11 for alphanumeric characters and 15 for numeric characters**

        organisation_prefix : typing.Optional[str]
            A recognizable prefix will ensure your audience knows who you are. Recommended by U.S. carriers. This will be added as your Brand Name before the message content. **Prefer verifying maximum length of 160 characters including this prefix in message content to avoid multiple sending of same sms.**

        tag : typing.Optional[SendTransacSmsTag]
            Tag of the message

        type : typing.Optional[SendTransacSmsType]
            Type of the SMS. Marketing SMS messages are those sent typically with marketing content. Transactional SMS messages are sent to individuals and are triggered in response to some action, such as a sign-up, purchase, etc.

        unicode_enabled : typing.Optional[bool]
            Format of the message. It indicates whether the content should be treated as unicode or not.

        web_url : typing.Optional[str]
            Webhook to call for each event triggered by the message (delivered etc.)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[SendTransacSmsResponse]
            SMS has been sent successfully to the recipient
        """
        _response = self._client_wrapper.httpx_client.request(
            "transactionalSMS/sms",
            method="POST",
            json={
                "organisationPrefix": organisation_prefix,
                "recipient": recipient,
                "sender": sender,
                "tag": convert_and_respect_annotation_metadata(
                    object_=tag, annotation=SendTransacSmsTag, direction="write"
                ),
                "type": type,
                "unicodeEnabled": unicode_enabled,
                "webUrl": web_url,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SendTransacSmsResponse,
                    construct_type(
                        type_=SendTransacSmsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 402:
                raise PaymentRequiredError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorModel,
                        construct_type(
                            type_=ErrorModel,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_transac_aggregated_sms_report(
        self,
        *,
        start_date: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        days: typing.Optional[int] = None,
        tag: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[GetTransacAggregatedSmsReportResponse]:
        """
        Parameters
        ----------
        start_date : typing.Optional[str]
            **Mandatory if endDate is used.** Starting date (YYYY-MM-DD) of the report

        end_date : typing.Optional[str]
            **Mandatory if startDate is used.** Ending date (YYYY-MM-DD) of the report

        days : typing.Optional[int]
            Number of days in the past including today (positive integer). **Not compatible with startDate and endDate**

        tag : typing.Optional[str]
            Filter on a tag

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetTransacAggregatedSmsReportResponse]
            Aggregated SMS report informations
        """
        _response = self._client_wrapper.httpx_client.request(
            "transactionalSMS/statistics/aggregatedReport",
            method="GET",
            params={
                "startDate": start_date,
                "endDate": end_date,
                "days": days,
                "tag": tag,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetTransacAggregatedSmsReportResponse,
                    construct_type(
                        type_=GetTransacAggregatedSmsReportResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_sms_events(
        self,
        *,
        limit: typing.Optional[int] = None,
        start_date: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        offset: typing.Optional[int] = None,
        days: typing.Optional[int] = None,
        phone_number: typing.Optional[str] = None,
        event: typing.Optional[GetSmsEventsRequestEvent] = None,
        tags: typing.Optional[str] = None,
        sort: typing.Optional[GetSmsEventsRequestSort] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[GetSmsEventsResponse]:
        """
        Parameters
        ----------
        limit : typing.Optional[int]
            Number of documents per page

        start_date : typing.Optional[str]
            **Mandatory if endDate is used.** Starting date (YYYY-MM-DD) of the report

        end_date : typing.Optional[str]
            **Mandatory if startDate is used.** Ending date (YYYY-MM-DD) of the report

        offset : typing.Optional[int]
            Index of the first document of the page

        days : typing.Optional[int]
            Number of days in the past including today (positive integer). **Not compatible with 'startDate' and 'endDate'**

        phone_number : typing.Optional[str]
            Filter the report for a specific phone number

        event : typing.Optional[GetSmsEventsRequestEvent]
            Filter the report for specific events

        tags : typing.Optional[str]
            Filter the report for specific tags passed as a serialized urlencoded array

        sort : typing.Optional[GetSmsEventsRequestSort]
            Sort the results in the ascending/descending order of record creation. Default order is **descending** if `sort` is not passed

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetSmsEventsResponse]
            Sms events report informations
        """
        _response = self._client_wrapper.httpx_client.request(
            "transactionalSMS/statistics/events",
            method="GET",
            params={
                "limit": limit,
                "startDate": start_date,
                "endDate": end_date,
                "offset": offset,
                "days": days,
                "phoneNumber": phone_number,
                "event": event,
                "tags": tags,
                "sort": sort,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetSmsEventsResponse,
                    construct_type(
                        type_=GetSmsEventsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_transac_sms_report(
        self,
        *,
        start_date: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        days: typing.Optional[int] = None,
        tag: typing.Optional[str] = None,
        sort: typing.Optional[GetTransacSmsReportRequestSort] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[GetTransacSmsReportResponse]:
        """
        Parameters
        ----------
        start_date : typing.Optional[str]
            **Mandatory if endDate is used.** Starting date (YYYY-MM-DD) of the report

        end_date : typing.Optional[str]
            **Mandatory if startDate is used.** Ending date (YYYY-MM-DD) of the report

        days : typing.Optional[int]
            Number of days in the past including today (positive integer). **Not compatible with 'startDate' and 'endDate'**

        tag : typing.Optional[str]
            Filter on a tag

        sort : typing.Optional[GetTransacSmsReportRequestSort]
            Sort the results in the ascending/descending order of record creation. Default order is **descending** if `sort` is not passed

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetTransacSmsReportResponse]
            Aggregated SMS report informations
        """
        _response = self._client_wrapper.httpx_client.request(
            "transactionalSMS/statistics/reports",
            method="GET",
            params={
                "startDate": start_date,
                "endDate": end_date,
                "days": days,
                "tag": tag,
                "sort": sort,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetTransacSmsReportResponse,
                    construct_type(
                        type_=GetTransacSmsReportResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawTransactionalSmsClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def send_async_transactional_sms(
        self,
        *,
        recipient: str,
        sender: str,
        organisation_prefix: typing.Optional[str] = OMIT,
        tag: typing.Optional[SendTransacSmsTag] = OMIT,
        type: typing.Optional[SendTransacSmsType] = OMIT,
        unicode_enabled: typing.Optional[bool] = OMIT,
        web_url: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[SendAsyncTransactionalSmsResponse]:
        """
        <Note>
        If the user includes stop code in the Transactional SMS, then it will be switched to Marketing SMS automatically and it will be interpreted as a Marketing SMS. To send Transactional SMS as Transactional, it is important not to use stop code.

        Note: For adding a stop code, client has to add reply STOP to [STOP_CODE] and the [STOP_CODE] will be replaced with the number.
        </Note>

        <Note title="For end users in France">
        Transactional SMS can be sent at any time without time restrictions. However, if a message is categorized as Marketing, it must adhere to specific time restrictions. Messages sent outside of these restricted hours will experience delays and will be processed during allowable times. Specifically, Marketing SMS cannot be processed between 10pm and 8am, on Sundays, and on French public holidays.
        </Note>

        Parameters
        ----------
        recipient : str
            Mobile number to send SMS with the country code

        sender : str
            Name of the sender. **The number of characters is limited to 11 for alphanumeric characters and 15 for numeric characters**

        organisation_prefix : typing.Optional[str]
            A recognizable prefix will ensure your audience knows who you are. Recommended by U.S. carriers. This will be added as your Brand Name before the message content. **Prefer verifying maximum length of 160 characters including this prefix in message content to avoid multiple sending of same sms.**

        tag : typing.Optional[SendTransacSmsTag]
            Tag of the message

        type : typing.Optional[SendTransacSmsType]
            Type of the SMS. Marketing SMS messages are those sent typically with marketing content. Transactional SMS messages are sent to individuals and are triggered in response to some action, such as a sign-up, purchase, etc.

        unicode_enabled : typing.Optional[bool]
            Format of the message. It indicates whether the content should be treated as unicode or not.

        web_url : typing.Optional[str]
            Webhook to call for each event triggered by the message (delivered etc.)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[SendAsyncTransactionalSmsResponse]
            SMS has been sent successfully to the recipient
        """
        _response = await self._client_wrapper.httpx_client.request(
            "transactionalSMS/send",
            method="POST",
            json={
                "organisationPrefix": organisation_prefix,
                "recipient": recipient,
                "sender": sender,
                "tag": convert_and_respect_annotation_metadata(
                    object_=tag, annotation=SendTransacSmsTag, direction="write"
                ),
                "type": type,
                "unicodeEnabled": unicode_enabled,
                "webUrl": web_url,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SendAsyncTransactionalSmsResponse,
                    construct_type(
                        type_=SendAsyncTransactionalSmsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def send_transac_sms(
        self,
        *,
        recipient: str,
        sender: str,
        organisation_prefix: typing.Optional[str] = OMIT,
        tag: typing.Optional[SendTransacSmsTag] = OMIT,
        type: typing.Optional[SendTransacSmsType] = OMIT,
        unicode_enabled: typing.Optional[bool] = OMIT,
        web_url: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[SendTransacSmsResponse]:
        """
        Parameters
        ----------
        recipient : str
            Mobile number to send SMS with the country code

        sender : str
            Name of the sender. **The number of characters is limited to 11 for alphanumeric characters and 15 for numeric characters**

        organisation_prefix : typing.Optional[str]
            A recognizable prefix will ensure your audience knows who you are. Recommended by U.S. carriers. This will be added as your Brand Name before the message content. **Prefer verifying maximum length of 160 characters including this prefix in message content to avoid multiple sending of same sms.**

        tag : typing.Optional[SendTransacSmsTag]
            Tag of the message

        type : typing.Optional[SendTransacSmsType]
            Type of the SMS. Marketing SMS messages are those sent typically with marketing content. Transactional SMS messages are sent to individuals and are triggered in response to some action, such as a sign-up, purchase, etc.

        unicode_enabled : typing.Optional[bool]
            Format of the message. It indicates whether the content should be treated as unicode or not.

        web_url : typing.Optional[str]
            Webhook to call for each event triggered by the message (delivered etc.)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[SendTransacSmsResponse]
            SMS has been sent successfully to the recipient
        """
        _response = await self._client_wrapper.httpx_client.request(
            "transactionalSMS/sms",
            method="POST",
            json={
                "organisationPrefix": organisation_prefix,
                "recipient": recipient,
                "sender": sender,
                "tag": convert_and_respect_annotation_metadata(
                    object_=tag, annotation=SendTransacSmsTag, direction="write"
                ),
                "type": type,
                "unicodeEnabled": unicode_enabled,
                "webUrl": web_url,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SendTransacSmsResponse,
                    construct_type(
                        type_=SendTransacSmsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 402:
                raise PaymentRequiredError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorModel,
                        construct_type(
                            type_=ErrorModel,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_transac_aggregated_sms_report(
        self,
        *,
        start_date: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        days: typing.Optional[int] = None,
        tag: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[GetTransacAggregatedSmsReportResponse]:
        """
        Parameters
        ----------
        start_date : typing.Optional[str]
            **Mandatory if endDate is used.** Starting date (YYYY-MM-DD) of the report

        end_date : typing.Optional[str]
            **Mandatory if startDate is used.** Ending date (YYYY-MM-DD) of the report

        days : typing.Optional[int]
            Number of days in the past including today (positive integer). **Not compatible with startDate and endDate**

        tag : typing.Optional[str]
            Filter on a tag

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetTransacAggregatedSmsReportResponse]
            Aggregated SMS report informations
        """
        _response = await self._client_wrapper.httpx_client.request(
            "transactionalSMS/statistics/aggregatedReport",
            method="GET",
            params={
                "startDate": start_date,
                "endDate": end_date,
                "days": days,
                "tag": tag,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetTransacAggregatedSmsReportResponse,
                    construct_type(
                        type_=GetTransacAggregatedSmsReportResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_sms_events(
        self,
        *,
        limit: typing.Optional[int] = None,
        start_date: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        offset: typing.Optional[int] = None,
        days: typing.Optional[int] = None,
        phone_number: typing.Optional[str] = None,
        event: typing.Optional[GetSmsEventsRequestEvent] = None,
        tags: typing.Optional[str] = None,
        sort: typing.Optional[GetSmsEventsRequestSort] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[GetSmsEventsResponse]:
        """
        Parameters
        ----------
        limit : typing.Optional[int]
            Number of documents per page

        start_date : typing.Optional[str]
            **Mandatory if endDate is used.** Starting date (YYYY-MM-DD) of the report

        end_date : typing.Optional[str]
            **Mandatory if startDate is used.** Ending date (YYYY-MM-DD) of the report

        offset : typing.Optional[int]
            Index of the first document of the page

        days : typing.Optional[int]
            Number of days in the past including today (positive integer). **Not compatible with 'startDate' and 'endDate'**

        phone_number : typing.Optional[str]
            Filter the report for a specific phone number

        event : typing.Optional[GetSmsEventsRequestEvent]
            Filter the report for specific events

        tags : typing.Optional[str]
            Filter the report for specific tags passed as a serialized urlencoded array

        sort : typing.Optional[GetSmsEventsRequestSort]
            Sort the results in the ascending/descending order of record creation. Default order is **descending** if `sort` is not passed

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetSmsEventsResponse]
            Sms events report informations
        """
        _response = await self._client_wrapper.httpx_client.request(
            "transactionalSMS/statistics/events",
            method="GET",
            params={
                "limit": limit,
                "startDate": start_date,
                "endDate": end_date,
                "offset": offset,
                "days": days,
                "phoneNumber": phone_number,
                "event": event,
                "tags": tags,
                "sort": sort,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetSmsEventsResponse,
                    construct_type(
                        type_=GetSmsEventsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_transac_sms_report(
        self,
        *,
        start_date: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        days: typing.Optional[int] = None,
        tag: typing.Optional[str] = None,
        sort: typing.Optional[GetTransacSmsReportRequestSort] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[GetTransacSmsReportResponse]:
        """
        Parameters
        ----------
        start_date : typing.Optional[str]
            **Mandatory if endDate is used.** Starting date (YYYY-MM-DD) of the report

        end_date : typing.Optional[str]
            **Mandatory if startDate is used.** Ending date (YYYY-MM-DD) of the report

        days : typing.Optional[int]
            Number of days in the past including today (positive integer). **Not compatible with 'startDate' and 'endDate'**

        tag : typing.Optional[str]
            Filter on a tag

        sort : typing.Optional[GetTransacSmsReportRequestSort]
            Sort the results in the ascending/descending order of record creation. Default order is **descending** if `sort` is not passed

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetTransacSmsReportResponse]
            Aggregated SMS report informations
        """
        _response = await self._client_wrapper.httpx_client.request(
            "transactionalSMS/statistics/reports",
            method="GET",
            params={
                "startDate": start_date,
                "endDate": end_date,
                "days": days,
                "tag": tag,
                "sort": sort,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetTransacSmsReportResponse,
                    construct_type(
                        type_=GetTransacSmsReportResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)
