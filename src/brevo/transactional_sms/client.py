# This file was auto-generated by Fern from our API Definition.

import typing

from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.request_options import RequestOptions
from ..types.send_transac_sms_tag import SendTransacSmsTag
from ..types.send_transac_sms_type import SendTransacSmsType
from .raw_client import AsyncRawTransactionalSmsClient, RawTransactionalSmsClient
from .types.get_sms_events_request_event import GetSmsEventsRequestEvent
from .types.get_sms_events_request_sort import GetSmsEventsRequestSort
from .types.get_sms_events_response import GetSmsEventsResponse
from .types.get_transac_aggregated_sms_report_response import GetTransacAggregatedSmsReportResponse
from .types.get_transac_sms_report_request_sort import GetTransacSmsReportRequestSort
from .types.get_transac_sms_report_response import GetTransacSmsReportResponse
from .types.send_async_transactional_sms_response import SendAsyncTransactionalSmsResponse
from .types.send_transac_sms_response import SendTransacSmsResponse

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class TransactionalSmsClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._raw_client = RawTransactionalSmsClient(client_wrapper=client_wrapper)

    @property
    def with_raw_response(self) -> RawTransactionalSmsClient:
        """
        Retrieves a raw implementation of this client that returns raw responses.

        Returns
        -------
        RawTransactionalSmsClient
        """
        return self._raw_client

    def send_async_transactional_sms(
        self,
        *,
        recipient: str,
        sender: str,
        organisation_prefix: typing.Optional[str] = OMIT,
        tag: typing.Optional[SendTransacSmsTag] = OMIT,
        type: typing.Optional[SendTransacSmsType] = OMIT,
        unicode_enabled: typing.Optional[bool] = OMIT,
        web_url: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> SendAsyncTransactionalSmsResponse:
        """
        <Note>
        If the user includes stop code in the Transactional SMS, then it will be switched to Marketing SMS automatically and it will be interpreted as a Marketing SMS. To send Transactional SMS as Transactional, it is important not to use stop code.

        Note: For adding a stop code, client has to add reply STOP to [STOP_CODE] and the [STOP_CODE] will be replaced with the number.
        </Note>

        <Note title="For end users in France">
        Transactional SMS can be sent at any time without time restrictions. However, if a message is categorized as Marketing, it must adhere to specific time restrictions. Messages sent outside of these restricted hours will experience delays and will be processed during allowable times. Specifically, Marketing SMS cannot be processed between 10pm and 8am, on Sundays, and on French public holidays.
        </Note>

        Parameters
        ----------
        recipient : str
            Mobile number to send SMS with the country code

        sender : str
            Name of the sender. **The number of characters is limited to 11 for alphanumeric characters and 15 for numeric characters**

        organisation_prefix : typing.Optional[str]
            A recognizable prefix will ensure your audience knows who you are. Recommended by U.S. carriers. This will be added as your Brand Name before the message content. **Prefer verifying maximum length of 160 characters including this prefix in message content to avoid multiple sending of same sms.**

        tag : typing.Optional[SendTransacSmsTag]
            Tag of the message

        type : typing.Optional[SendTransacSmsType]
            Type of the SMS. Marketing SMS messages are those sent typically with marketing content. Transactional SMS messages are sent to individuals and are triggered in response to some action, such as a sign-up, purchase, etc.

        unicode_enabled : typing.Optional[bool]
            Format of the message. It indicates whether the content should be treated as unicode or not.

        web_url : typing.Optional[str]
            Webhook to call for each event triggered by the message (delivered etc.)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SendAsyncTransactionalSmsResponse
            SMS has been sent successfully to the recipient

        Examples
        --------
        from brevo import Brevo

        client = Brevo(
            api_key="YOUR_API_KEY",
        )
        client.transactional_sms.send_async_transactional_sms(
            recipient="33689965433",
            sender="MyShop",
        )
        """
        _response = self._raw_client.send_async_transactional_sms(
            recipient=recipient,
            sender=sender,
            organisation_prefix=organisation_prefix,
            tag=tag,
            type=type,
            unicode_enabled=unicode_enabled,
            web_url=web_url,
            request_options=request_options,
        )
        return _response.data

    def send_transac_sms(
        self,
        *,
        recipient: str,
        sender: str,
        organisation_prefix: typing.Optional[str] = OMIT,
        tag: typing.Optional[SendTransacSmsTag] = OMIT,
        type: typing.Optional[SendTransacSmsType] = OMIT,
        unicode_enabled: typing.Optional[bool] = OMIT,
        web_url: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> SendTransacSmsResponse:
        """
        Parameters
        ----------
        recipient : str
            Mobile number to send SMS with the country code

        sender : str
            Name of the sender. **The number of characters is limited to 11 for alphanumeric characters and 15 for numeric characters**

        organisation_prefix : typing.Optional[str]
            A recognizable prefix will ensure your audience knows who you are. Recommended by U.S. carriers. This will be added as your Brand Name before the message content. **Prefer verifying maximum length of 160 characters including this prefix in message content to avoid multiple sending of same sms.**

        tag : typing.Optional[SendTransacSmsTag]
            Tag of the message

        type : typing.Optional[SendTransacSmsType]
            Type of the SMS. Marketing SMS messages are those sent typically with marketing content. Transactional SMS messages are sent to individuals and are triggered in response to some action, such as a sign-up, purchase, etc.

        unicode_enabled : typing.Optional[bool]
            Format of the message. It indicates whether the content should be treated as unicode or not.

        web_url : typing.Optional[str]
            Webhook to call for each event triggered by the message (delivered etc.)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SendTransacSmsResponse
            SMS has been sent successfully to the recipient

        Examples
        --------
        from brevo import Brevo

        client = Brevo(
            api_key="YOUR_API_KEY",
        )
        client.transactional_sms.send_transac_sms(
            recipient="33689965433",
            sender="MyShop",
        )
        """
        _response = self._raw_client.send_transac_sms(
            recipient=recipient,
            sender=sender,
            organisation_prefix=organisation_prefix,
            tag=tag,
            type=type,
            unicode_enabled=unicode_enabled,
            web_url=web_url,
            request_options=request_options,
        )
        return _response.data

    def get_transac_aggregated_sms_report(
        self,
        *,
        start_date: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        days: typing.Optional[int] = None,
        tag: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GetTransacAggregatedSmsReportResponse:
        """
        Parameters
        ----------
        start_date : typing.Optional[str]
            **Mandatory if endDate is used.** Starting date (YYYY-MM-DD) of the report

        end_date : typing.Optional[str]
            **Mandatory if startDate is used.** Ending date (YYYY-MM-DD) of the report

        days : typing.Optional[int]
            Number of days in the past including today (positive integer). **Not compatible with startDate and endDate**

        tag : typing.Optional[str]
            Filter on a tag

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GetTransacAggregatedSmsReportResponse
            Aggregated SMS report informations

        Examples
        --------
        from brevo import Brevo

        client = Brevo(
            api_key="YOUR_API_KEY",
        )
        client.transactional_sms.get_transac_aggregated_sms_report()
        """
        _response = self._raw_client.get_transac_aggregated_sms_report(
            start_date=start_date, end_date=end_date, days=days, tag=tag, request_options=request_options
        )
        return _response.data

    def get_sms_events(
        self,
        *,
        limit: typing.Optional[int] = None,
        start_date: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        offset: typing.Optional[int] = None,
        days: typing.Optional[int] = None,
        phone_number: typing.Optional[str] = None,
        event: typing.Optional[GetSmsEventsRequestEvent] = None,
        tags: typing.Optional[str] = None,
        sort: typing.Optional[GetSmsEventsRequestSort] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GetSmsEventsResponse:
        """
        Parameters
        ----------
        limit : typing.Optional[int]
            Number of documents per page

        start_date : typing.Optional[str]
            **Mandatory if endDate is used.** Starting date (YYYY-MM-DD) of the report

        end_date : typing.Optional[str]
            **Mandatory if startDate is used.** Ending date (YYYY-MM-DD) of the report

        offset : typing.Optional[int]
            Index of the first document of the page

        days : typing.Optional[int]
            Number of days in the past including today (positive integer). **Not compatible with 'startDate' and 'endDate'**

        phone_number : typing.Optional[str]
            Filter the report for a specific phone number

        event : typing.Optional[GetSmsEventsRequestEvent]
            Filter the report for specific events

        tags : typing.Optional[str]
            Filter the report for specific tags passed as a serialized urlencoded array

        sort : typing.Optional[GetSmsEventsRequestSort]
            Sort the results in the ascending/descending order of record creation. Default order is **descending** if `sort` is not passed

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GetSmsEventsResponse
            Sms events report informations

        Examples
        --------
        from brevo import Brevo

        client = Brevo(
            api_key="YOUR_API_KEY",
        )
        client.transactional_sms.get_sms_events()
        """
        _response = self._raw_client.get_sms_events(
            limit=limit,
            start_date=start_date,
            end_date=end_date,
            offset=offset,
            days=days,
            phone_number=phone_number,
            event=event,
            tags=tags,
            sort=sort,
            request_options=request_options,
        )
        return _response.data

    def get_transac_sms_report(
        self,
        *,
        start_date: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        days: typing.Optional[int] = None,
        tag: typing.Optional[str] = None,
        sort: typing.Optional[GetTransacSmsReportRequestSort] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GetTransacSmsReportResponse:
        """
        Parameters
        ----------
        start_date : typing.Optional[str]
            **Mandatory if endDate is used.** Starting date (YYYY-MM-DD) of the report

        end_date : typing.Optional[str]
            **Mandatory if startDate is used.** Ending date (YYYY-MM-DD) of the report

        days : typing.Optional[int]
            Number of days in the past including today (positive integer). **Not compatible with 'startDate' and 'endDate'**

        tag : typing.Optional[str]
            Filter on a tag

        sort : typing.Optional[GetTransacSmsReportRequestSort]
            Sort the results in the ascending/descending order of record creation. Default order is **descending** if `sort` is not passed

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GetTransacSmsReportResponse
            Aggregated SMS report informations

        Examples
        --------
        from brevo import Brevo

        client = Brevo(
            api_key="YOUR_API_KEY",
        )
        client.transactional_sms.get_transac_sms_report()
        """
        _response = self._raw_client.get_transac_sms_report(
            start_date=start_date, end_date=end_date, days=days, tag=tag, sort=sort, request_options=request_options
        )
        return _response.data


class AsyncTransactionalSmsClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._raw_client = AsyncRawTransactionalSmsClient(client_wrapper=client_wrapper)

    @property
    def with_raw_response(self) -> AsyncRawTransactionalSmsClient:
        """
        Retrieves a raw implementation of this client that returns raw responses.

        Returns
        -------
        AsyncRawTransactionalSmsClient
        """
        return self._raw_client

    async def send_async_transactional_sms(
        self,
        *,
        recipient: str,
        sender: str,
        organisation_prefix: typing.Optional[str] = OMIT,
        tag: typing.Optional[SendTransacSmsTag] = OMIT,
        type: typing.Optional[SendTransacSmsType] = OMIT,
        unicode_enabled: typing.Optional[bool] = OMIT,
        web_url: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> SendAsyncTransactionalSmsResponse:
        """
        <Note>
        If the user includes stop code in the Transactional SMS, then it will be switched to Marketing SMS automatically and it will be interpreted as a Marketing SMS. To send Transactional SMS as Transactional, it is important not to use stop code.

        Note: For adding a stop code, client has to add reply STOP to [STOP_CODE] and the [STOP_CODE] will be replaced with the number.
        </Note>

        <Note title="For end users in France">
        Transactional SMS can be sent at any time without time restrictions. However, if a message is categorized as Marketing, it must adhere to specific time restrictions. Messages sent outside of these restricted hours will experience delays and will be processed during allowable times. Specifically, Marketing SMS cannot be processed between 10pm and 8am, on Sundays, and on French public holidays.
        </Note>

        Parameters
        ----------
        recipient : str
            Mobile number to send SMS with the country code

        sender : str
            Name of the sender. **The number of characters is limited to 11 for alphanumeric characters and 15 for numeric characters**

        organisation_prefix : typing.Optional[str]
            A recognizable prefix will ensure your audience knows who you are. Recommended by U.S. carriers. This will be added as your Brand Name before the message content. **Prefer verifying maximum length of 160 characters including this prefix in message content to avoid multiple sending of same sms.**

        tag : typing.Optional[SendTransacSmsTag]
            Tag of the message

        type : typing.Optional[SendTransacSmsType]
            Type of the SMS. Marketing SMS messages are those sent typically with marketing content. Transactional SMS messages are sent to individuals and are triggered in response to some action, such as a sign-up, purchase, etc.

        unicode_enabled : typing.Optional[bool]
            Format of the message. It indicates whether the content should be treated as unicode or not.

        web_url : typing.Optional[str]
            Webhook to call for each event triggered by the message (delivered etc.)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SendAsyncTransactionalSmsResponse
            SMS has been sent successfully to the recipient

        Examples
        --------
        import asyncio

        from brevo import AsyncBrevo

        client = AsyncBrevo(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.transactional_sms.send_async_transactional_sms(
                recipient="33689965433",
                sender="MyShop",
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.send_async_transactional_sms(
            recipient=recipient,
            sender=sender,
            organisation_prefix=organisation_prefix,
            tag=tag,
            type=type,
            unicode_enabled=unicode_enabled,
            web_url=web_url,
            request_options=request_options,
        )
        return _response.data

    async def send_transac_sms(
        self,
        *,
        recipient: str,
        sender: str,
        organisation_prefix: typing.Optional[str] = OMIT,
        tag: typing.Optional[SendTransacSmsTag] = OMIT,
        type: typing.Optional[SendTransacSmsType] = OMIT,
        unicode_enabled: typing.Optional[bool] = OMIT,
        web_url: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> SendTransacSmsResponse:
        """
        Parameters
        ----------
        recipient : str
            Mobile number to send SMS with the country code

        sender : str
            Name of the sender. **The number of characters is limited to 11 for alphanumeric characters and 15 for numeric characters**

        organisation_prefix : typing.Optional[str]
            A recognizable prefix will ensure your audience knows who you are. Recommended by U.S. carriers. This will be added as your Brand Name before the message content. **Prefer verifying maximum length of 160 characters including this prefix in message content to avoid multiple sending of same sms.**

        tag : typing.Optional[SendTransacSmsTag]
            Tag of the message

        type : typing.Optional[SendTransacSmsType]
            Type of the SMS. Marketing SMS messages are those sent typically with marketing content. Transactional SMS messages are sent to individuals and are triggered in response to some action, such as a sign-up, purchase, etc.

        unicode_enabled : typing.Optional[bool]
            Format of the message. It indicates whether the content should be treated as unicode or not.

        web_url : typing.Optional[str]
            Webhook to call for each event triggered by the message (delivered etc.)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SendTransacSmsResponse
            SMS has been sent successfully to the recipient

        Examples
        --------
        import asyncio

        from brevo import AsyncBrevo

        client = AsyncBrevo(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.transactional_sms.send_transac_sms(
                recipient="33689965433",
                sender="MyShop",
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.send_transac_sms(
            recipient=recipient,
            sender=sender,
            organisation_prefix=organisation_prefix,
            tag=tag,
            type=type,
            unicode_enabled=unicode_enabled,
            web_url=web_url,
            request_options=request_options,
        )
        return _response.data

    async def get_transac_aggregated_sms_report(
        self,
        *,
        start_date: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        days: typing.Optional[int] = None,
        tag: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GetTransacAggregatedSmsReportResponse:
        """
        Parameters
        ----------
        start_date : typing.Optional[str]
            **Mandatory if endDate is used.** Starting date (YYYY-MM-DD) of the report

        end_date : typing.Optional[str]
            **Mandatory if startDate is used.** Ending date (YYYY-MM-DD) of the report

        days : typing.Optional[int]
            Number of days in the past including today (positive integer). **Not compatible with startDate and endDate**

        tag : typing.Optional[str]
            Filter on a tag

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GetTransacAggregatedSmsReportResponse
            Aggregated SMS report informations

        Examples
        --------
        import asyncio

        from brevo import AsyncBrevo

        client = AsyncBrevo(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.transactional_sms.get_transac_aggregated_sms_report()


        asyncio.run(main())
        """
        _response = await self._raw_client.get_transac_aggregated_sms_report(
            start_date=start_date, end_date=end_date, days=days, tag=tag, request_options=request_options
        )
        return _response.data

    async def get_sms_events(
        self,
        *,
        limit: typing.Optional[int] = None,
        start_date: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        offset: typing.Optional[int] = None,
        days: typing.Optional[int] = None,
        phone_number: typing.Optional[str] = None,
        event: typing.Optional[GetSmsEventsRequestEvent] = None,
        tags: typing.Optional[str] = None,
        sort: typing.Optional[GetSmsEventsRequestSort] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GetSmsEventsResponse:
        """
        Parameters
        ----------
        limit : typing.Optional[int]
            Number of documents per page

        start_date : typing.Optional[str]
            **Mandatory if endDate is used.** Starting date (YYYY-MM-DD) of the report

        end_date : typing.Optional[str]
            **Mandatory if startDate is used.** Ending date (YYYY-MM-DD) of the report

        offset : typing.Optional[int]
            Index of the first document of the page

        days : typing.Optional[int]
            Number of days in the past including today (positive integer). **Not compatible with 'startDate' and 'endDate'**

        phone_number : typing.Optional[str]
            Filter the report for a specific phone number

        event : typing.Optional[GetSmsEventsRequestEvent]
            Filter the report for specific events

        tags : typing.Optional[str]
            Filter the report for specific tags passed as a serialized urlencoded array

        sort : typing.Optional[GetSmsEventsRequestSort]
            Sort the results in the ascending/descending order of record creation. Default order is **descending** if `sort` is not passed

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GetSmsEventsResponse
            Sms events report informations

        Examples
        --------
        import asyncio

        from brevo import AsyncBrevo

        client = AsyncBrevo(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.transactional_sms.get_sms_events()


        asyncio.run(main())
        """
        _response = await self._raw_client.get_sms_events(
            limit=limit,
            start_date=start_date,
            end_date=end_date,
            offset=offset,
            days=days,
            phone_number=phone_number,
            event=event,
            tags=tags,
            sort=sort,
            request_options=request_options,
        )
        return _response.data

    async def get_transac_sms_report(
        self,
        *,
        start_date: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        days: typing.Optional[int] = None,
        tag: typing.Optional[str] = None,
        sort: typing.Optional[GetTransacSmsReportRequestSort] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GetTransacSmsReportResponse:
        """
        Parameters
        ----------
        start_date : typing.Optional[str]
            **Mandatory if endDate is used.** Starting date (YYYY-MM-DD) of the report

        end_date : typing.Optional[str]
            **Mandatory if startDate is used.** Ending date (YYYY-MM-DD) of the report

        days : typing.Optional[int]
            Number of days in the past including today (positive integer). **Not compatible with 'startDate' and 'endDate'**

        tag : typing.Optional[str]
            Filter on a tag

        sort : typing.Optional[GetTransacSmsReportRequestSort]
            Sort the results in the ascending/descending order of record creation. Default order is **descending** if `sort` is not passed

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GetTransacSmsReportResponse
            Aggregated SMS report informations

        Examples
        --------
        import asyncio

        from brevo import AsyncBrevo

        client = AsyncBrevo(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.transactional_sms.get_transac_sms_report()


        asyncio.run(main())
        """
        _response = await self._raw_client.get_transac_sms_report(
            start_date=start_date, end_date=end_date, days=days, tag=tag, sort=sort, request_options=request_options
        )
        return _response.data
