# This file was auto-generated by Fern from our API Definition.

import datetime as dt
import typing
from json.decoder import JSONDecodeError

from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.http_response import AsyncHttpResponse, HttpResponse
from ..core.jsonable_encoder import jsonable_encoder
from ..core.request_options import RequestOptions
from ..core.serialization import convert_and_respect_annotation_metadata
from ..core.unchecked_base_model import construct_type
from ..errors.bad_request_error import BadRequestError
from ..errors.not_found_error import NotFoundError
from ..types.get_smtp_template_overview import GetSmtpTemplateOverview
from .types.create_smtp_template_request_sender import CreateSmtpTemplateRequestSender
from .types.create_smtp_template_response import CreateSmtpTemplateResponse
from .types.get_aggregated_smtp_report_response import GetAggregatedSmtpReportResponse
from .types.get_blocked_domains_response import GetBlockedDomainsResponse
from .types.get_email_event_report_request_event import GetEmailEventReportRequestEvent
from .types.get_email_event_report_request_sort import GetEmailEventReportRequestSort
from .types.get_email_event_report_response import GetEmailEventReportResponse
from .types.get_scheduled_email_by_id_request_sort import GetScheduledEmailByIdRequestSort
from .types.get_scheduled_email_by_id_request_status import GetScheduledEmailByIdRequestStatus
from .types.get_scheduled_email_by_id_response import GetScheduledEmailByIdResponse
from .types.get_smtp_report_request_sort import GetSmtpReportRequestSort
from .types.get_smtp_report_response import GetSmtpReportResponse
from .types.get_smtp_templates_request_sort import GetSmtpTemplatesRequestSort
from .types.get_smtp_templates_response import GetSmtpTemplatesResponse
from .types.get_transac_blocked_contacts_request_sort import GetTransacBlockedContactsRequestSort
from .types.get_transac_blocked_contacts_response import GetTransacBlockedContactsResponse
from .types.get_transac_email_content_response import GetTransacEmailContentResponse
from .types.get_transac_emails_list_request_sort import GetTransacEmailsListRequestSort
from .types.get_transac_emails_list_response import GetTransacEmailsListResponse
from .types.post_preview_smtp_email_templates_response import PostPreviewSmtpEmailTemplatesResponse
from .types.send_transac_email_request_attachment_item import SendTransacEmailRequestAttachmentItem
from .types.send_transac_email_request_bcc_item import SendTransacEmailRequestBccItem
from .types.send_transac_email_request_cc_item import SendTransacEmailRequestCcItem
from .types.send_transac_email_request_message_versions_item import SendTransacEmailRequestMessageVersionsItem
from .types.send_transac_email_request_reply_to import SendTransacEmailRequestReplyTo
from .types.send_transac_email_request_sender import SendTransacEmailRequestSender
from .types.send_transac_email_request_to_item import SendTransacEmailRequestToItem
from .types.send_transac_email_response import SendTransacEmailResponse
from .types.update_smtp_template_request_sender import UpdateSmtpTemplateRequestSender

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawTransactionalEmailsClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def get_transac_blocked_contacts(
        self,
        *,
        start_date: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        limit: typing.Optional[int] = None,
        offset: typing.Optional[int] = None,
        senders: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        sort: typing.Optional[GetTransacBlockedContactsRequestSort] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[GetTransacBlockedContactsResponse]:
        """
        Parameters
        ----------
        start_date : typing.Optional[str]
            **Mandatory if endDate is used.** Starting date (YYYY-MM-DD) from which you want to fetch the blocked or unsubscribed contacts

        end_date : typing.Optional[str]
            **Mandatory if startDate is used.** Ending date (YYYY-MM-DD) till which you want to fetch the blocked or unsubscribed contacts

        limit : typing.Optional[int]
            Number of documents returned per page

        offset : typing.Optional[int]
            Index of the first document on the page

        senders : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            Comma separated list of emails of the senders from which contacts are blocked or unsubscribed

        sort : typing.Optional[GetTransacBlockedContactsRequestSort]
            Sort the results in the ascending/descending order of record creation. Default order is **descending** if `sort` is not passed

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetTransacBlockedContactsResponse]
            List of blocked or unsubscribed transactional contacts
        """
        _response = self._client_wrapper.httpx_client.request(
            "smtp/blockedContacts",
            method="GET",
            params={
                "startDate": start_date,
                "endDate": end_date,
                "limit": limit,
                "offset": offset,
                "senders": senders,
                "sort": sort,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetTransacBlockedContactsResponse,
                    construct_type(
                        type_=GetTransacBlockedContactsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def unblock_or_resubscribe_a_transactional_contact(
        self, email: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        email : str
            contact email (urlencoded) to unblock.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"smtp/blockedContacts/{jsonable_encoder(email)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_blocked_domains(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[GetBlockedDomainsResponse]:
        """
        Get the list of blocked domains

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetBlockedDomainsResponse]
            List of blocked domains
        """
        _response = self._client_wrapper.httpx_client.request(
            "smtp/blockedDomains",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetBlockedDomainsResponse,
                    construct_type(
                        type_=GetBlockedDomainsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def block_new_domain(
        self, *, domain: str, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[None]:
        """
        Blocks a new domain in order to avoid messages being sent to the same

        Parameters
        ----------
        domain : str
            name of the domain to be blocked

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            "smtp/blockedDomains",
            method="POST",
            json={
                "domain": domain,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def delete_blocked_domain(
        self, domain: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[None]:
        """
        Unblocks an existing domain from the list of blocked domains

        Parameters
        ----------
        domain : str
            The name of the domain to be deleted

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"smtp/blockedDomains/{jsonable_encoder(domain)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def delete_hardbounces(
        self,
        *,
        contact_email: typing.Optional[str] = OMIT,
        end_date: typing.Optional[str] = OMIT,
        start_date: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Delete hardbounces. To use carefully (e.g. in case of temporary ISP failures)

        Parameters
        ----------
        contact_email : typing.Optional[str]
            Target a specific email address

        end_date : typing.Optional[str]
            Ending date (YYYY-MM-DD) of the time period for deletion. The hardbounces until this date will be deleted. Must be greater than or equal to the startDate

        start_date : typing.Optional[str]
            Starting date (YYYY-MM-DD) of the time period for deletion. The hardbounces occurred after this date will be deleted. Must be less than or equal to the endDate

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            "smtp/deleteHardbounces",
            method="POST",
            json={
                "contactEmail": contact_email,
                "endDate": end_date,
                "startDate": start_date,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def send_transac_email(
        self,
        *,
        attachment: typing.Optional[typing.Sequence[SendTransacEmailRequestAttachmentItem]] = OMIT,
        batch_id: typing.Optional[str] = OMIT,
        bcc: typing.Optional[typing.Sequence[SendTransacEmailRequestBccItem]] = OMIT,
        cc: typing.Optional[typing.Sequence[SendTransacEmailRequestCcItem]] = OMIT,
        headers: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        html_content: typing.Optional[str] = OMIT,
        message_versions: typing.Optional[typing.Sequence[SendTransacEmailRequestMessageVersionsItem]] = OMIT,
        params: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        reply_to: typing.Optional[SendTransacEmailRequestReplyTo] = OMIT,
        scheduled_at: typing.Optional[dt.datetime] = OMIT,
        sender: typing.Optional[SendTransacEmailRequestSender] = OMIT,
        subject: typing.Optional[str] = OMIT,
        tags: typing.Optional[typing.Sequence[str]] = OMIT,
        template_id: typing.Optional[int] = OMIT,
        text_content: typing.Optional[str] = OMIT,
        to: typing.Optional[typing.Sequence[SendTransacEmailRequestToItem]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[SendTransacEmailResponse]:
        """
        Parameters
        ----------
        attachment : typing.Optional[typing.Sequence[SendTransacEmailRequestAttachmentItem]]
            Array of attachment objects. Each attachment must include either an absolute URL (no local file paths) or base64-encoded content, along with the attachment filename. The `name` field is required when `content` is provided. Supported file extensions: xlsx, xls, ods, docx, docm, doc, csv, pdf, txt, gif, jpg, jpeg, png, tif, tiff, rtf, bmp, cgm, css, shtml, html, htm, zip, xml, ppt, pptx, tar, ez, ics, mobi, msg, pub, eps, odt, mp3, m4a, m4v, wma, ogg, flac, wav, aif, aifc, aiff, mp4, mov, avi, mkv, mpeg, mpg, wmv, pkpass, xlsm. When `templateId` is specified: if the template uses the New Template Language format, both `url` and `content` attachment types are supported; if the template uses the Old Template Language format, the `attachment` parameter is ignored.

        batch_id : typing.Optional[str]
            UUIDv4 identifier for the scheduled batch of transactional emails. If omitted, a valid UUIDv4 batch identifier is automatically generated.

        bcc : typing.Optional[typing.Sequence[SendTransacEmailRequestBccItem]]
            Array of BCC recipient objects. Each object contains an email address and an optional name.

        cc : typing.Optional[typing.Sequence[SendTransacEmailRequestCcItem]]
            Array of CC recipient objects. Each object contains an email address and an optional name.

        headers : typing.Optional[typing.Dict[str, typing.Any]]
            Custom email headers (non-standard headers) to include in the email. The `sender.ip` header can be set to specify the IP address used for sending transactional emails (dedicated IP users only). Header names must use Title-Case-Format (words separated by hyphens with the first letter of each word capitalized). Headers not in this format are automatically converted. Standard email headers are not supported. Example: `{"sender.ip":"1.2.3.4", "X-Mailin-custom":"some_custom_value", "Idempotency-Key":"abc-123"}`

        html_content : typing.Optional[str]
            HTML body content of the email. Required when `templateId` is not provided. Ignored when `templateId` is provided.

        message_versions : typing.Optional[typing.Sequence[SendTransacEmailRequestMessageVersionsItem]]
            Array of message version objects for sending customized email variants. The `templateId` can be customized per version only if a global `templateId` is provided. The `htmlContent` and `textContent` can be customized per version only if at least one of these is present in the global parameters. Global parameters such as `to` (required), `bcc`, `cc`, `replyTo`, and `subject` can be customized per version. Maximum total recipients per API request is 2000. Maximum recipients per message version is 99. Individual `params` objects must not exceed 100 KB. Cumulative `params` across all versions must not exceed 1000 KB. See https://developers.brevo.com/docs/batch-send-transactional-emails for detailed usage instructions.

        params : typing.Optional[typing.Dict[str, typing.Any]]
            Key-value pairs for template variable substitution. Only applicable when the template uses the New Template Language format.

        reply_to : typing.Optional[SendTransacEmailRequestReplyTo]
            Reply-to email address (required) and optional display name. Recipients will use this address when replying to the email.

        scheduled_at : typing.Optional[dt.datetime]
            UTC date-time when the email should be sent (format: YYYY-MM-DDTHH:mm:ss.SSSZ). Include timezone information in the date-time value. Scheduled emails may be delayed by up to 5 minutes.

        sender : typing.Optional[SendTransacEmailRequestSender]
            Sender information. Required when `templateId` is not provided. Specify either an email address (with optional name) or a sender ID. The `name` field is ignored when `id` is provided.

        subject : typing.Optional[str]
            Email subject line. Required when `templateId` is not provided.

        tags : typing.Optional[typing.Sequence[str]]
            Array of tags for categorizing and filtering emails

        template_id : typing.Optional[int]
            Template identifier

        text_content : typing.Optional[str]
            Plain text body content of the email. Ignored when `templateId` is provided.

        to : typing.Optional[typing.Sequence[SendTransacEmailRequestToItem]]
            Array of recipient objects. Each object contains an email address and an optional display name. Required when `messageVersions` is not provided. Ignored when `messageVersions` is provided. Example: `[{"name":"Jimmy", "email":"jimmy@example.com"}, {"name":"Joe", "email":"joe@example.com"}]`

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[SendTransacEmailResponse]
            Transactional email sent successfully
        """
        _response = self._client_wrapper.httpx_client.request(
            "smtp/email",
            method="POST",
            json={
                "attachment": convert_and_respect_annotation_metadata(
                    object_=attachment,
                    annotation=typing.Sequence[SendTransacEmailRequestAttachmentItem],
                    direction="write",
                ),
                "batchId": batch_id,
                "bcc": convert_and_respect_annotation_metadata(
                    object_=bcc, annotation=typing.Sequence[SendTransacEmailRequestBccItem], direction="write"
                ),
                "cc": convert_and_respect_annotation_metadata(
                    object_=cc, annotation=typing.Sequence[SendTransacEmailRequestCcItem], direction="write"
                ),
                "headers": headers,
                "htmlContent": html_content,
                "messageVersions": convert_and_respect_annotation_metadata(
                    object_=message_versions,
                    annotation=typing.Sequence[SendTransacEmailRequestMessageVersionsItem],
                    direction="write",
                ),
                "params": params,
                "replyTo": convert_and_respect_annotation_metadata(
                    object_=reply_to, annotation=SendTransacEmailRequestReplyTo, direction="write"
                ),
                "scheduledAt": scheduled_at,
                "sender": convert_and_respect_annotation_metadata(
                    object_=sender, annotation=SendTransacEmailRequestSender, direction="write"
                ),
                "subject": subject,
                "tags": tags,
                "templateId": template_id,
                "textContent": text_content,
                "to": convert_and_respect_annotation_metadata(
                    object_=to, annotation=typing.Sequence[SendTransacEmailRequestToItem], direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SendTransacEmailResponse,
                    construct_type(
                        type_=SendTransacEmailResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def delete_scheduled_email_by_id(
        self, identifier: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[None]:
        """
        Delete scheduled batch of emails by batchId or single scheduled email by messageId

        Parameters
        ----------
        identifier : str
            The `batchId` of scheduled emails batch (Should be a valid UUIDv4) or the `messageId` of scheduled email.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"smtp/email/{jsonable_encoder(identifier)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_scheduled_email_by_id(
        self,
        identifier: str,
        *,
        start_date: typing.Optional[dt.date] = None,
        end_date: typing.Optional[dt.date] = None,
        sort: typing.Optional[GetScheduledEmailByIdRequestSort] = None,
        status: typing.Optional[GetScheduledEmailByIdRequestStatus] = None,
        limit: typing.Optional[int] = None,
        offset: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[GetScheduledEmailByIdResponse]:
        """
        Fetch scheduled batch of emails by batchId or single scheduled email by messageId (Can retrieve data upto 30 days old)

        Parameters
        ----------
        identifier : str
            The `batchId` of scheduled emails batch (Should be a valid UUIDv4) or the `messageId` of scheduled email.

        start_date : typing.Optional[dt.date]
            Mandatory if `endDate` is used. Starting date (YYYY-MM-DD) from which you want to fetch the list. Can be maximum 30 days older tha current date.

        end_date : typing.Optional[dt.date]
            Mandatory if `startDate` is used. Ending date (YYYY-MM-DD) till which you want to fetch the list. Maximum time period that can be selected is one month.

        sort : typing.Optional[GetScheduledEmailByIdRequestSort]
            Sort the results in the ascending/descending order of record creation. Default order is **descending** if `sort` is not passed. Not valid when identifier is `messageId`.

        status : typing.Optional[GetScheduledEmailByIdRequestStatus]
            Filter the records by `status` of the scheduled email batch or message. Not valid when identifier is `messageId`.

        limit : typing.Optional[int]
            Number of documents returned per page. Not valid when identifier is `messageId`.

        offset : typing.Optional[int]
            Index of the first document on the page.  Not valid when identifier is `messageId`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetScheduledEmailByIdResponse]
            Scheduled email batches
        """
        _response = self._client_wrapper.httpx_client.request(
            f"smtp/emailStatus/{jsonable_encoder(identifier)}",
            method="GET",
            params={
                "startDate": str(start_date) if start_date is not None else None,
                "endDate": str(end_date) if end_date is not None else None,
                "sort": sort,
                "status": status,
                "limit": limit,
                "offset": offset,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetScheduledEmailByIdResponse,
                    construct_type(
                        type_=GetScheduledEmailByIdResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_transac_emails_list(
        self,
        *,
        email: typing.Optional[str] = None,
        template_id: typing.Optional[int] = None,
        message_id: typing.Optional[str] = None,
        start_date: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        sort: typing.Optional[GetTransacEmailsListRequestSort] = None,
        limit: typing.Optional[int] = None,
        offset: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[GetTransacEmailsListResponse]:
        """
        This endpoint will show the list of emails for past 30 days by default. To retrieve emails before that time, please pass startDate and endDate in query filters.

        Parameters
        ----------
        email : typing.Optional[str]
            **Mandatory if templateId and messageId are not passed in query filters.** Email address to which transactional email has been sent.

        template_id : typing.Optional[int]
            **Mandatory if email and messageId are not passed in query filters.** Id of the template that was used to compose transactional email.

        message_id : typing.Optional[str]
            **Mandatory if templateId and email are not passed in query filters.** Message ID of the transactional email sent.

        start_date : typing.Optional[str]
            **Mandatory if endDate is used.** Starting date (YYYY-MM-DD) from which you want to fetch the list. **Maximum time period that can be selected is one month**.

        end_date : typing.Optional[str]
            **Mandatory if startDate is used.** Ending date (YYYY-MM-DD) till which you want to fetch the list. **Maximum time period that can be selected is one month.**

        sort : typing.Optional[GetTransacEmailsListRequestSort]
            Sort the results in the ascending/descending order of record creation. Default order is **descending** if `sort` is not passed

        limit : typing.Optional[int]
            Number of documents returned per page

        offset : typing.Optional[int]
            Index of the first document in the page

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetTransacEmailsListResponse]
            List of transactional emails
        """
        _response = self._client_wrapper.httpx_client.request(
            "smtp/emails",
            method="GET",
            params={
                "email": email,
                "templateId": template_id,
                "messageId": message_id,
                "startDate": start_date,
                "endDate": end_date,
                "sort": sort,
                "limit": limit,
                "offset": offset,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetTransacEmailsListResponse,
                    construct_type(
                        type_=GetTransacEmailsListResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_transac_email_content(
        self, uuid_: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[GetTransacEmailContentResponse]:
        """
        <Note title="How to get uuid?">
        You can get the uuid using either of the following methods:

        Send a GET request to https://api.brevo.com/v3/smtp/emails and pass the message_id in the url. Use your api-key to authenticate the request and you will get your uuid as a response.

        The uuid can also be fetched from the transactional logs page in your Brevo account, from the address URL.
        </Note>

        Parameters
        ----------
        uuid_ : str
            Unique id of the transactional email that has been sent to a particular contact

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetTransacEmailContentResponse]
            Transactional email content
        """
        _response = self._client_wrapper.httpx_client.request(
            f"smtp/emails/{jsonable_encoder(uuid_)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetTransacEmailContentResponse,
                    construct_type(
                        type_=GetTransacEmailContentResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def delete_an_smtp_transactional_log(
        self, identifier: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        identifier : str
            MessageId of the transactional log(s) to delete

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"smtp/log/{jsonable_encoder(identifier)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_aggregated_smtp_report(
        self,
        *,
        start_date: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        days: typing.Optional[int] = None,
        tag: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[GetAggregatedSmtpReportResponse]:
        """
        This endpoint will show the aggregated stats for past 90 days by default if `startDate` and `endDate` OR `days` is not passed. The date range can not exceed 90 days

        Parameters
        ----------
        start_date : typing.Optional[str]
            **Mandatory if endDate is used.** Starting date of the report (YYYY-MM-DD). Must be lower than equal to endDate

        end_date : typing.Optional[str]
            **Mandatory if startDate is used.** Ending date of the report (YYYY-MM-DD). Must be greater than equal to startDate

        days : typing.Optional[int]
            Number of days in the past including today (positive integer). _Not compatible with 'startDate' and 'endDate'_

        tag : typing.Optional[str]
            Tag of the emails

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetAggregatedSmtpReportResponse]
            Aggregated report informations
        """
        _response = self._client_wrapper.httpx_client.request(
            "smtp/statistics/aggregatedReport",
            method="GET",
            params={
                "startDate": start_date,
                "endDate": end_date,
                "days": days,
                "tag": tag,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetAggregatedSmtpReportResponse,
                    construct_type(
                        type_=GetAggregatedSmtpReportResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_email_event_report(
        self,
        *,
        limit: typing.Optional[int] = None,
        offset: typing.Optional[int] = None,
        start_date: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        days: typing.Optional[int] = None,
        email: typing.Optional[str] = None,
        event: typing.Optional[GetEmailEventReportRequestEvent] = None,
        tags: typing.Optional[str] = None,
        message_id: typing.Optional[str] = None,
        template_id: typing.Optional[int] = None,
        sort: typing.Optional[GetEmailEventReportRequestSort] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[GetEmailEventReportResponse]:
        """
        This endpoint will show the aggregated stats for past 30 days by default if `startDate` and `endDate` OR `days` is not passed. The date range can not exceed 90 days

        Parameters
        ----------
        limit : typing.Optional[int]
            Number limitation for the result returned

        offset : typing.Optional[int]
            Beginning point in the list to retrieve from.

        start_date : typing.Optional[str]
            **Mandatory if endDate is used.** Starting date of the report (YYYY-MM-DD). Must be lower than equal to endDate

        end_date : typing.Optional[str]
            **Mandatory if startDate is used.** Ending date of the report (YYYY-MM-DD). Must be greater than equal to startDate

        days : typing.Optional[int]
            Number of days in the past including today (positive integer). _Not compatible with 'startDate' and 'endDate'_

        email : typing.Optional[str]
            Filter the report for a specific email addresses

        event : typing.Optional[GetEmailEventReportRequestEvent]
            Filter the report for a specific event type

        tags : typing.Optional[str]
            Filter the report for tags (serialized and urlencoded array)

        message_id : typing.Optional[str]
            Filter on a specific message id

        template_id : typing.Optional[int]
            Filter on a specific template id

        sort : typing.Optional[GetEmailEventReportRequestSort]
            Sort the results in the ascending/descending order of record creation. Default order is **descending** if `sort` is not passed

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetEmailEventReportResponse]
            Email events report informations
        """
        _response = self._client_wrapper.httpx_client.request(
            "smtp/statistics/events",
            method="GET",
            params={
                "limit": limit,
                "offset": offset,
                "startDate": start_date,
                "endDate": end_date,
                "days": days,
                "email": email,
                "event": event,
                "tags": tags,
                "messageId": message_id,
                "templateId": template_id,
                "sort": sort,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetEmailEventReportResponse,
                    construct_type(
                        type_=GetEmailEventReportResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_smtp_report(
        self,
        *,
        limit: typing.Optional[int] = None,
        offset: typing.Optional[int] = None,
        start_date: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        days: typing.Optional[int] = None,
        tag: typing.Optional[str] = None,
        sort: typing.Optional[GetSmtpReportRequestSort] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[GetSmtpReportResponse]:
        """
        Parameters
        ----------
        limit : typing.Optional[int]
            Number of documents returned per page

        offset : typing.Optional[int]
            Index of the first document on the page

        start_date : typing.Optional[str]
            **Mandatory if endDate is used.** Starting date of the report (YYYY-MM-DD)

        end_date : typing.Optional[str]
            **Mandatory if startDate is used.** Ending date of the report (YYYY-MM-DD)

        days : typing.Optional[int]
            Number of days in the past including today (positive integer). _Not compatible with 'startDate' and 'endDate'_

        tag : typing.Optional[str]
            Tag of the emails

        sort : typing.Optional[GetSmtpReportRequestSort]
            Sort the results in the ascending/descending order of record creation. Default order is **descending** if `sort` is not passed

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetSmtpReportResponse]
            Aggregated report informations
        """
        _response = self._client_wrapper.httpx_client.request(
            "smtp/statistics/reports",
            method="GET",
            params={
                "limit": limit,
                "offset": offset,
                "startDate": start_date,
                "endDate": end_date,
                "days": days,
                "tag": tag,
                "sort": sort,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetSmtpReportResponse,
                    construct_type(
                        type_=GetSmtpReportResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def post_preview_smtp_email_templates(
        self, *, request: typing.Any, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[PostPreviewSmtpEmailTemplatesResponse]:
        """
        Parameters
        ----------
        request : typing.Any

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[PostPreviewSmtpEmailTemplatesResponse]
            successfully fetched template's preview fields
        """
        _response = self._client_wrapper.httpx_client.request(
            "smtp/template/preview",
            method="POST",
            json=request,
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PostPreviewSmtpEmailTemplatesResponse,
                    construct_type(
                        type_=PostPreviewSmtpEmailTemplatesResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_smtp_templates(
        self,
        *,
        template_status: typing.Optional[bool] = None,
        limit: typing.Optional[int] = None,
        offset: typing.Optional[int] = None,
        sort: typing.Optional[GetSmtpTemplatesRequestSort] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[GetSmtpTemplatesResponse]:
        """
        Parameters
        ----------
        template_status : typing.Optional[bool]
            Filter on the status of the template. Active = true, inactive = false

        limit : typing.Optional[int]
            Number of documents returned per page

        offset : typing.Optional[int]
            Index of the first document in the page

        sort : typing.Optional[GetSmtpTemplatesRequestSort]
            Sort the results in the ascending/descending order of record creation. Default order is **descending** if `sort` is not passed

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetSmtpTemplatesResponse]
            transactional email templates informations
        """
        _response = self._client_wrapper.httpx_client.request(
            "smtp/templates",
            method="GET",
            params={
                "templateStatus": template_status,
                "limit": limit,
                "offset": offset,
                "sort": sort,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetSmtpTemplatesResponse,
                    construct_type(
                        type_=GetSmtpTemplatesResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def create_smtp_template(
        self,
        *,
        sender: CreateSmtpTemplateRequestSender,
        subject: str,
        template_name: str,
        attachment_url: typing.Optional[str] = OMIT,
        html_content: typing.Optional[str] = OMIT,
        html_url: typing.Optional[str] = OMIT,
        is_active: typing.Optional[bool] = OMIT,
        reply_to: typing.Optional[str] = OMIT,
        tag: typing.Optional[str] = OMIT,
        to_field: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[CreateSmtpTemplateResponse]:
        """
        Parameters
        ----------
        sender : CreateSmtpTemplateRequestSender
            Sender details including id or email and name (_optional_). Only one of either Sender's email or Sender's ID shall be passed in one request at a time. For example: **{"name":"xyz", "email":"example@abc.com"}** **{"name":"xyz", "id":123}**

        subject : str
            Subject of the template

        template_name : str
            Name of the template

        attachment_url : typing.Optional[str]
            Absolute url of the attachment (**no local file**). Extension allowed: #### xlsx, xls, ods, docx, docm, doc, csv, pdf, txt, gif, jpg, jpeg, png, tif, tiff, rtf, bmp, cgm, css, shtml, html, htm, zip, xml, ppt, pptx, tar, ez, ics, mobi, msg, pub and eps'

        html_content : typing.Optional[str]
            Body of the message (HTML version). The field must have more than 10 characters. **REQUIRED if htmlUrl is empty**

        html_url : typing.Optional[str]
            Url which contents the body of the email message. REQUIRED if htmlContent is empty

        is_active : typing.Optional[bool]
            Status of template. isActive = true means template is active and isActive = false means template is inactive

        reply_to : typing.Optional[str]
            Email on which campaign recipients will be able to reply to

        tag : typing.Optional[str]
            Tag of the template

        to_field : typing.Optional[str]
            To personalize the **To** Field. If you want to include the first name and last name of your recipient, add **{FNAME} {LNAME}**. These contact attributes must already exist in your Brevo account. If input parameter **params** used please use **{{contact.FNAME}} {{contact.LNAME}}** for personalization

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[CreateSmtpTemplateResponse]
            successfully created
        """
        _response = self._client_wrapper.httpx_client.request(
            "smtp/templates",
            method="POST",
            json={
                "attachmentUrl": attachment_url,
                "htmlContent": html_content,
                "htmlUrl": html_url,
                "isActive": is_active,
                "replyTo": reply_to,
                "sender": convert_and_respect_annotation_metadata(
                    object_=sender, annotation=CreateSmtpTemplateRequestSender, direction="write"
                ),
                "subject": subject,
                "tag": tag,
                "templateName": template_name,
                "toField": to_field,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CreateSmtpTemplateResponse,
                    construct_type(
                        type_=CreateSmtpTemplateResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_smtp_template(
        self, template_id: int, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[GetSmtpTemplateOverview]:
        """
        Parameters
        ----------
        template_id : int
            id of the template

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetSmtpTemplateOverview]
            Email template informations
        """
        _response = self._client_wrapper.httpx_client.request(
            f"smtp/templates/{jsonable_encoder(template_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetSmtpTemplateOverview,
                    construct_type(
                        type_=GetSmtpTemplateOverview,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def update_smtp_template(
        self,
        template_id: int,
        *,
        attachment_url: typing.Optional[str] = OMIT,
        html_content: typing.Optional[str] = OMIT,
        html_url: typing.Optional[str] = OMIT,
        is_active: typing.Optional[bool] = OMIT,
        reply_to: typing.Optional[str] = OMIT,
        sender: typing.Optional[UpdateSmtpTemplateRequestSender] = OMIT,
        subject: typing.Optional[str] = OMIT,
        tag: typing.Optional[str] = OMIT,
        template_name: typing.Optional[str] = OMIT,
        to_field: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        template_id : int
            id of the template

        attachment_url : typing.Optional[str]
            Absolute url of the attachment (**no local file**). Extensions allowed: #### xlsx, xls, ods, docx, docm, doc, csv, pdf, txt, gif, jpg, jpeg, png, tif, tiff, rtf, bmp, cgm, css, shtml, html, htm, zip, xml, ppt, pptx, tar, ez, ics, mobi, msg, pub and eps

        html_content : typing.Optional[str]
            **Required if htmlUrl is empty**. If the template is designed using Drag & Drop editor via HTML content, then the design page will not have Drag & Drop editor access for that template. Body of the message (HTML must have more than 10 characters)

        html_url : typing.Optional[str]
            **Required if htmlContent is empty**. URL to the body of the email (HTML)

        is_active : typing.Optional[bool]
            Status of the template. isActive = false means template is inactive, isActive = true means template is active

        reply_to : typing.Optional[str]
            Email on which campaign recipients will be able to reply to

        sender : typing.Optional[UpdateSmtpTemplateRequestSender]
            Sender details including id or email and name (_optional_). Only one of either Sender's email or Sender's ID shall be passed in one request at a time. For example: **{"name":"xyz", "email":"example@abc.com"}** **{"name":"xyz", "id":123}**

        subject : typing.Optional[str]
            Subject of the email

        tag : typing.Optional[str]
            Tag of the template

        template_name : typing.Optional[str]
            Name of the template

        to_field : typing.Optional[str]
            To personalize the **To** Field. If you want to include the first name and last name of your recipient, add **{FNAME} {LNAME}**. These contact attributes must already exist in your Brevo account. If input parameter **params** used please use **{{contact.FNAME}} {{contact.LNAME}}** for personalization

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"smtp/templates/{jsonable_encoder(template_id)}",
            method="PUT",
            json={
                "attachmentUrl": attachment_url,
                "htmlContent": html_content,
                "htmlUrl": html_url,
                "isActive": is_active,
                "replyTo": reply_to,
                "sender": convert_and_respect_annotation_metadata(
                    object_=sender, annotation=UpdateSmtpTemplateRequestSender, direction="write"
                ),
                "subject": subject,
                "tag": tag,
                "templateName": template_name,
                "toField": to_field,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def delete_smtp_template(
        self, template_id: int, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        template_id : int
            id of the template

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"smtp/templates/{jsonable_encoder(template_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def send_test_template(
        self,
        template_id: int,
        *,
        email_to: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        template_id : int
            Id of the template

        email_to : typing.Optional[typing.Sequence[str]]
            List of the email addresses of the recipients whom you wish to send the test mail. _If left empty, the test mail will be sent to your entire test list. You can not send more than 50 test emails per day_.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"smtp/templates/{jsonable_encoder(template_id)}/sendTest",
            method="POST",
            json={
                "emailTo": email_to,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawTransactionalEmailsClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def get_transac_blocked_contacts(
        self,
        *,
        start_date: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        limit: typing.Optional[int] = None,
        offset: typing.Optional[int] = None,
        senders: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        sort: typing.Optional[GetTransacBlockedContactsRequestSort] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[GetTransacBlockedContactsResponse]:
        """
        Parameters
        ----------
        start_date : typing.Optional[str]
            **Mandatory if endDate is used.** Starting date (YYYY-MM-DD) from which you want to fetch the blocked or unsubscribed contacts

        end_date : typing.Optional[str]
            **Mandatory if startDate is used.** Ending date (YYYY-MM-DD) till which you want to fetch the blocked or unsubscribed contacts

        limit : typing.Optional[int]
            Number of documents returned per page

        offset : typing.Optional[int]
            Index of the first document on the page

        senders : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            Comma separated list of emails of the senders from which contacts are blocked or unsubscribed

        sort : typing.Optional[GetTransacBlockedContactsRequestSort]
            Sort the results in the ascending/descending order of record creation. Default order is **descending** if `sort` is not passed

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetTransacBlockedContactsResponse]
            List of blocked or unsubscribed transactional contacts
        """
        _response = await self._client_wrapper.httpx_client.request(
            "smtp/blockedContacts",
            method="GET",
            params={
                "startDate": start_date,
                "endDate": end_date,
                "limit": limit,
                "offset": offset,
                "senders": senders,
                "sort": sort,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetTransacBlockedContactsResponse,
                    construct_type(
                        type_=GetTransacBlockedContactsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def unblock_or_resubscribe_a_transactional_contact(
        self, email: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        email : str
            contact email (urlencoded) to unblock.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"smtp/blockedContacts/{jsonable_encoder(email)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_blocked_domains(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[GetBlockedDomainsResponse]:
        """
        Get the list of blocked domains

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetBlockedDomainsResponse]
            List of blocked domains
        """
        _response = await self._client_wrapper.httpx_client.request(
            "smtp/blockedDomains",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetBlockedDomainsResponse,
                    construct_type(
                        type_=GetBlockedDomainsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def block_new_domain(
        self, *, domain: str, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[None]:
        """
        Blocks a new domain in order to avoid messages being sent to the same

        Parameters
        ----------
        domain : str
            name of the domain to be blocked

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            "smtp/blockedDomains",
            method="POST",
            json={
                "domain": domain,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def delete_blocked_domain(
        self, domain: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[None]:
        """
        Unblocks an existing domain from the list of blocked domains

        Parameters
        ----------
        domain : str
            The name of the domain to be deleted

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"smtp/blockedDomains/{jsonable_encoder(domain)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def delete_hardbounces(
        self,
        *,
        contact_email: typing.Optional[str] = OMIT,
        end_date: typing.Optional[str] = OMIT,
        start_date: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Delete hardbounces. To use carefully (e.g. in case of temporary ISP failures)

        Parameters
        ----------
        contact_email : typing.Optional[str]
            Target a specific email address

        end_date : typing.Optional[str]
            Ending date (YYYY-MM-DD) of the time period for deletion. The hardbounces until this date will be deleted. Must be greater than or equal to the startDate

        start_date : typing.Optional[str]
            Starting date (YYYY-MM-DD) of the time period for deletion. The hardbounces occurred after this date will be deleted. Must be less than or equal to the endDate

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            "smtp/deleteHardbounces",
            method="POST",
            json={
                "contactEmail": contact_email,
                "endDate": end_date,
                "startDate": start_date,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def send_transac_email(
        self,
        *,
        attachment: typing.Optional[typing.Sequence[SendTransacEmailRequestAttachmentItem]] = OMIT,
        batch_id: typing.Optional[str] = OMIT,
        bcc: typing.Optional[typing.Sequence[SendTransacEmailRequestBccItem]] = OMIT,
        cc: typing.Optional[typing.Sequence[SendTransacEmailRequestCcItem]] = OMIT,
        headers: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        html_content: typing.Optional[str] = OMIT,
        message_versions: typing.Optional[typing.Sequence[SendTransacEmailRequestMessageVersionsItem]] = OMIT,
        params: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        reply_to: typing.Optional[SendTransacEmailRequestReplyTo] = OMIT,
        scheduled_at: typing.Optional[dt.datetime] = OMIT,
        sender: typing.Optional[SendTransacEmailRequestSender] = OMIT,
        subject: typing.Optional[str] = OMIT,
        tags: typing.Optional[typing.Sequence[str]] = OMIT,
        template_id: typing.Optional[int] = OMIT,
        text_content: typing.Optional[str] = OMIT,
        to: typing.Optional[typing.Sequence[SendTransacEmailRequestToItem]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[SendTransacEmailResponse]:
        """
        Parameters
        ----------
        attachment : typing.Optional[typing.Sequence[SendTransacEmailRequestAttachmentItem]]
            Array of attachment objects. Each attachment must include either an absolute URL (no local file paths) or base64-encoded content, along with the attachment filename. The `name` field is required when `content` is provided. Supported file extensions: xlsx, xls, ods, docx, docm, doc, csv, pdf, txt, gif, jpg, jpeg, png, tif, tiff, rtf, bmp, cgm, css, shtml, html, htm, zip, xml, ppt, pptx, tar, ez, ics, mobi, msg, pub, eps, odt, mp3, m4a, m4v, wma, ogg, flac, wav, aif, aifc, aiff, mp4, mov, avi, mkv, mpeg, mpg, wmv, pkpass, xlsm. When `templateId` is specified: if the template uses the New Template Language format, both `url` and `content` attachment types are supported; if the template uses the Old Template Language format, the `attachment` parameter is ignored.

        batch_id : typing.Optional[str]
            UUIDv4 identifier for the scheduled batch of transactional emails. If omitted, a valid UUIDv4 batch identifier is automatically generated.

        bcc : typing.Optional[typing.Sequence[SendTransacEmailRequestBccItem]]
            Array of BCC recipient objects. Each object contains an email address and an optional name.

        cc : typing.Optional[typing.Sequence[SendTransacEmailRequestCcItem]]
            Array of CC recipient objects. Each object contains an email address and an optional name.

        headers : typing.Optional[typing.Dict[str, typing.Any]]
            Custom email headers (non-standard headers) to include in the email. The `sender.ip` header can be set to specify the IP address used for sending transactional emails (dedicated IP users only). Header names must use Title-Case-Format (words separated by hyphens with the first letter of each word capitalized). Headers not in this format are automatically converted. Standard email headers are not supported. Example: `{"sender.ip":"1.2.3.4", "X-Mailin-custom":"some_custom_value", "Idempotency-Key":"abc-123"}`

        html_content : typing.Optional[str]
            HTML body content of the email. Required when `templateId` is not provided. Ignored when `templateId` is provided.

        message_versions : typing.Optional[typing.Sequence[SendTransacEmailRequestMessageVersionsItem]]
            Array of message version objects for sending customized email variants. The `templateId` can be customized per version only if a global `templateId` is provided. The `htmlContent` and `textContent` can be customized per version only if at least one of these is present in the global parameters. Global parameters such as `to` (required), `bcc`, `cc`, `replyTo`, and `subject` can be customized per version. Maximum total recipients per API request is 2000. Maximum recipients per message version is 99. Individual `params` objects must not exceed 100 KB. Cumulative `params` across all versions must not exceed 1000 KB. See https://developers.brevo.com/docs/batch-send-transactional-emails for detailed usage instructions.

        params : typing.Optional[typing.Dict[str, typing.Any]]
            Key-value pairs for template variable substitution. Only applicable when the template uses the New Template Language format.

        reply_to : typing.Optional[SendTransacEmailRequestReplyTo]
            Reply-to email address (required) and optional display name. Recipients will use this address when replying to the email.

        scheduled_at : typing.Optional[dt.datetime]
            UTC date-time when the email should be sent (format: YYYY-MM-DDTHH:mm:ss.SSSZ). Include timezone information in the date-time value. Scheduled emails may be delayed by up to 5 minutes.

        sender : typing.Optional[SendTransacEmailRequestSender]
            Sender information. Required when `templateId` is not provided. Specify either an email address (with optional name) or a sender ID. The `name` field is ignored when `id` is provided.

        subject : typing.Optional[str]
            Email subject line. Required when `templateId` is not provided.

        tags : typing.Optional[typing.Sequence[str]]
            Array of tags for categorizing and filtering emails

        template_id : typing.Optional[int]
            Template identifier

        text_content : typing.Optional[str]
            Plain text body content of the email. Ignored when `templateId` is provided.

        to : typing.Optional[typing.Sequence[SendTransacEmailRequestToItem]]
            Array of recipient objects. Each object contains an email address and an optional display name. Required when `messageVersions` is not provided. Ignored when `messageVersions` is provided. Example: `[{"name":"Jimmy", "email":"jimmy@example.com"}, {"name":"Joe", "email":"joe@example.com"}]`

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[SendTransacEmailResponse]
            Transactional email sent successfully
        """
        _response = await self._client_wrapper.httpx_client.request(
            "smtp/email",
            method="POST",
            json={
                "attachment": convert_and_respect_annotation_metadata(
                    object_=attachment,
                    annotation=typing.Sequence[SendTransacEmailRequestAttachmentItem],
                    direction="write",
                ),
                "batchId": batch_id,
                "bcc": convert_and_respect_annotation_metadata(
                    object_=bcc, annotation=typing.Sequence[SendTransacEmailRequestBccItem], direction="write"
                ),
                "cc": convert_and_respect_annotation_metadata(
                    object_=cc, annotation=typing.Sequence[SendTransacEmailRequestCcItem], direction="write"
                ),
                "headers": headers,
                "htmlContent": html_content,
                "messageVersions": convert_and_respect_annotation_metadata(
                    object_=message_versions,
                    annotation=typing.Sequence[SendTransacEmailRequestMessageVersionsItem],
                    direction="write",
                ),
                "params": params,
                "replyTo": convert_and_respect_annotation_metadata(
                    object_=reply_to, annotation=SendTransacEmailRequestReplyTo, direction="write"
                ),
                "scheduledAt": scheduled_at,
                "sender": convert_and_respect_annotation_metadata(
                    object_=sender, annotation=SendTransacEmailRequestSender, direction="write"
                ),
                "subject": subject,
                "tags": tags,
                "templateId": template_id,
                "textContent": text_content,
                "to": convert_and_respect_annotation_metadata(
                    object_=to, annotation=typing.Sequence[SendTransacEmailRequestToItem], direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SendTransacEmailResponse,
                    construct_type(
                        type_=SendTransacEmailResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def delete_scheduled_email_by_id(
        self, identifier: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[None]:
        """
        Delete scheduled batch of emails by batchId or single scheduled email by messageId

        Parameters
        ----------
        identifier : str
            The `batchId` of scheduled emails batch (Should be a valid UUIDv4) or the `messageId` of scheduled email.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"smtp/email/{jsonable_encoder(identifier)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_scheduled_email_by_id(
        self,
        identifier: str,
        *,
        start_date: typing.Optional[dt.date] = None,
        end_date: typing.Optional[dt.date] = None,
        sort: typing.Optional[GetScheduledEmailByIdRequestSort] = None,
        status: typing.Optional[GetScheduledEmailByIdRequestStatus] = None,
        limit: typing.Optional[int] = None,
        offset: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[GetScheduledEmailByIdResponse]:
        """
        Fetch scheduled batch of emails by batchId or single scheduled email by messageId (Can retrieve data upto 30 days old)

        Parameters
        ----------
        identifier : str
            The `batchId` of scheduled emails batch (Should be a valid UUIDv4) or the `messageId` of scheduled email.

        start_date : typing.Optional[dt.date]
            Mandatory if `endDate` is used. Starting date (YYYY-MM-DD) from which you want to fetch the list. Can be maximum 30 days older tha current date.

        end_date : typing.Optional[dt.date]
            Mandatory if `startDate` is used. Ending date (YYYY-MM-DD) till which you want to fetch the list. Maximum time period that can be selected is one month.

        sort : typing.Optional[GetScheduledEmailByIdRequestSort]
            Sort the results in the ascending/descending order of record creation. Default order is **descending** if `sort` is not passed. Not valid when identifier is `messageId`.

        status : typing.Optional[GetScheduledEmailByIdRequestStatus]
            Filter the records by `status` of the scheduled email batch or message. Not valid when identifier is `messageId`.

        limit : typing.Optional[int]
            Number of documents returned per page. Not valid when identifier is `messageId`.

        offset : typing.Optional[int]
            Index of the first document on the page.  Not valid when identifier is `messageId`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetScheduledEmailByIdResponse]
            Scheduled email batches
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"smtp/emailStatus/{jsonable_encoder(identifier)}",
            method="GET",
            params={
                "startDate": str(start_date) if start_date is not None else None,
                "endDate": str(end_date) if end_date is not None else None,
                "sort": sort,
                "status": status,
                "limit": limit,
                "offset": offset,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetScheduledEmailByIdResponse,
                    construct_type(
                        type_=GetScheduledEmailByIdResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_transac_emails_list(
        self,
        *,
        email: typing.Optional[str] = None,
        template_id: typing.Optional[int] = None,
        message_id: typing.Optional[str] = None,
        start_date: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        sort: typing.Optional[GetTransacEmailsListRequestSort] = None,
        limit: typing.Optional[int] = None,
        offset: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[GetTransacEmailsListResponse]:
        """
        This endpoint will show the list of emails for past 30 days by default. To retrieve emails before that time, please pass startDate and endDate in query filters.

        Parameters
        ----------
        email : typing.Optional[str]
            **Mandatory if templateId and messageId are not passed in query filters.** Email address to which transactional email has been sent.

        template_id : typing.Optional[int]
            **Mandatory if email and messageId are not passed in query filters.** Id of the template that was used to compose transactional email.

        message_id : typing.Optional[str]
            **Mandatory if templateId and email are not passed in query filters.** Message ID of the transactional email sent.

        start_date : typing.Optional[str]
            **Mandatory if endDate is used.** Starting date (YYYY-MM-DD) from which you want to fetch the list. **Maximum time period that can be selected is one month**.

        end_date : typing.Optional[str]
            **Mandatory if startDate is used.** Ending date (YYYY-MM-DD) till which you want to fetch the list. **Maximum time period that can be selected is one month.**

        sort : typing.Optional[GetTransacEmailsListRequestSort]
            Sort the results in the ascending/descending order of record creation. Default order is **descending** if `sort` is not passed

        limit : typing.Optional[int]
            Number of documents returned per page

        offset : typing.Optional[int]
            Index of the first document in the page

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetTransacEmailsListResponse]
            List of transactional emails
        """
        _response = await self._client_wrapper.httpx_client.request(
            "smtp/emails",
            method="GET",
            params={
                "email": email,
                "templateId": template_id,
                "messageId": message_id,
                "startDate": start_date,
                "endDate": end_date,
                "sort": sort,
                "limit": limit,
                "offset": offset,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetTransacEmailsListResponse,
                    construct_type(
                        type_=GetTransacEmailsListResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_transac_email_content(
        self, uuid_: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[GetTransacEmailContentResponse]:
        """
        <Note title="How to get uuid?">
        You can get the uuid using either of the following methods:

        Send a GET request to https://api.brevo.com/v3/smtp/emails and pass the message_id in the url. Use your api-key to authenticate the request and you will get your uuid as a response.

        The uuid can also be fetched from the transactional logs page in your Brevo account, from the address URL.
        </Note>

        Parameters
        ----------
        uuid_ : str
            Unique id of the transactional email that has been sent to a particular contact

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetTransacEmailContentResponse]
            Transactional email content
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"smtp/emails/{jsonable_encoder(uuid_)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetTransacEmailContentResponse,
                    construct_type(
                        type_=GetTransacEmailContentResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def delete_an_smtp_transactional_log(
        self, identifier: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        identifier : str
            MessageId of the transactional log(s) to delete

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"smtp/log/{jsonable_encoder(identifier)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_aggregated_smtp_report(
        self,
        *,
        start_date: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        days: typing.Optional[int] = None,
        tag: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[GetAggregatedSmtpReportResponse]:
        """
        This endpoint will show the aggregated stats for past 90 days by default if `startDate` and `endDate` OR `days` is not passed. The date range can not exceed 90 days

        Parameters
        ----------
        start_date : typing.Optional[str]
            **Mandatory if endDate is used.** Starting date of the report (YYYY-MM-DD). Must be lower than equal to endDate

        end_date : typing.Optional[str]
            **Mandatory if startDate is used.** Ending date of the report (YYYY-MM-DD). Must be greater than equal to startDate

        days : typing.Optional[int]
            Number of days in the past including today (positive integer). _Not compatible with 'startDate' and 'endDate'_

        tag : typing.Optional[str]
            Tag of the emails

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetAggregatedSmtpReportResponse]
            Aggregated report informations
        """
        _response = await self._client_wrapper.httpx_client.request(
            "smtp/statistics/aggregatedReport",
            method="GET",
            params={
                "startDate": start_date,
                "endDate": end_date,
                "days": days,
                "tag": tag,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetAggregatedSmtpReportResponse,
                    construct_type(
                        type_=GetAggregatedSmtpReportResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_email_event_report(
        self,
        *,
        limit: typing.Optional[int] = None,
        offset: typing.Optional[int] = None,
        start_date: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        days: typing.Optional[int] = None,
        email: typing.Optional[str] = None,
        event: typing.Optional[GetEmailEventReportRequestEvent] = None,
        tags: typing.Optional[str] = None,
        message_id: typing.Optional[str] = None,
        template_id: typing.Optional[int] = None,
        sort: typing.Optional[GetEmailEventReportRequestSort] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[GetEmailEventReportResponse]:
        """
        This endpoint will show the aggregated stats for past 30 days by default if `startDate` and `endDate` OR `days` is not passed. The date range can not exceed 90 days

        Parameters
        ----------
        limit : typing.Optional[int]
            Number limitation for the result returned

        offset : typing.Optional[int]
            Beginning point in the list to retrieve from.

        start_date : typing.Optional[str]
            **Mandatory if endDate is used.** Starting date of the report (YYYY-MM-DD). Must be lower than equal to endDate

        end_date : typing.Optional[str]
            **Mandatory if startDate is used.** Ending date of the report (YYYY-MM-DD). Must be greater than equal to startDate

        days : typing.Optional[int]
            Number of days in the past including today (positive integer). _Not compatible with 'startDate' and 'endDate'_

        email : typing.Optional[str]
            Filter the report for a specific email addresses

        event : typing.Optional[GetEmailEventReportRequestEvent]
            Filter the report for a specific event type

        tags : typing.Optional[str]
            Filter the report for tags (serialized and urlencoded array)

        message_id : typing.Optional[str]
            Filter on a specific message id

        template_id : typing.Optional[int]
            Filter on a specific template id

        sort : typing.Optional[GetEmailEventReportRequestSort]
            Sort the results in the ascending/descending order of record creation. Default order is **descending** if `sort` is not passed

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetEmailEventReportResponse]
            Email events report informations
        """
        _response = await self._client_wrapper.httpx_client.request(
            "smtp/statistics/events",
            method="GET",
            params={
                "limit": limit,
                "offset": offset,
                "startDate": start_date,
                "endDate": end_date,
                "days": days,
                "email": email,
                "event": event,
                "tags": tags,
                "messageId": message_id,
                "templateId": template_id,
                "sort": sort,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetEmailEventReportResponse,
                    construct_type(
                        type_=GetEmailEventReportResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_smtp_report(
        self,
        *,
        limit: typing.Optional[int] = None,
        offset: typing.Optional[int] = None,
        start_date: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        days: typing.Optional[int] = None,
        tag: typing.Optional[str] = None,
        sort: typing.Optional[GetSmtpReportRequestSort] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[GetSmtpReportResponse]:
        """
        Parameters
        ----------
        limit : typing.Optional[int]
            Number of documents returned per page

        offset : typing.Optional[int]
            Index of the first document on the page

        start_date : typing.Optional[str]
            **Mandatory if endDate is used.** Starting date of the report (YYYY-MM-DD)

        end_date : typing.Optional[str]
            **Mandatory if startDate is used.** Ending date of the report (YYYY-MM-DD)

        days : typing.Optional[int]
            Number of days in the past including today (positive integer). _Not compatible with 'startDate' and 'endDate'_

        tag : typing.Optional[str]
            Tag of the emails

        sort : typing.Optional[GetSmtpReportRequestSort]
            Sort the results in the ascending/descending order of record creation. Default order is **descending** if `sort` is not passed

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetSmtpReportResponse]
            Aggregated report informations
        """
        _response = await self._client_wrapper.httpx_client.request(
            "smtp/statistics/reports",
            method="GET",
            params={
                "limit": limit,
                "offset": offset,
                "startDate": start_date,
                "endDate": end_date,
                "days": days,
                "tag": tag,
                "sort": sort,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetSmtpReportResponse,
                    construct_type(
                        type_=GetSmtpReportResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def post_preview_smtp_email_templates(
        self, *, request: typing.Any, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[PostPreviewSmtpEmailTemplatesResponse]:
        """
        Parameters
        ----------
        request : typing.Any

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[PostPreviewSmtpEmailTemplatesResponse]
            successfully fetched template's preview fields
        """
        _response = await self._client_wrapper.httpx_client.request(
            "smtp/template/preview",
            method="POST",
            json=request,
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PostPreviewSmtpEmailTemplatesResponse,
                    construct_type(
                        type_=PostPreviewSmtpEmailTemplatesResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_smtp_templates(
        self,
        *,
        template_status: typing.Optional[bool] = None,
        limit: typing.Optional[int] = None,
        offset: typing.Optional[int] = None,
        sort: typing.Optional[GetSmtpTemplatesRequestSort] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[GetSmtpTemplatesResponse]:
        """
        Parameters
        ----------
        template_status : typing.Optional[bool]
            Filter on the status of the template. Active = true, inactive = false

        limit : typing.Optional[int]
            Number of documents returned per page

        offset : typing.Optional[int]
            Index of the first document in the page

        sort : typing.Optional[GetSmtpTemplatesRequestSort]
            Sort the results in the ascending/descending order of record creation. Default order is **descending** if `sort` is not passed

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetSmtpTemplatesResponse]
            transactional email templates informations
        """
        _response = await self._client_wrapper.httpx_client.request(
            "smtp/templates",
            method="GET",
            params={
                "templateStatus": template_status,
                "limit": limit,
                "offset": offset,
                "sort": sort,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetSmtpTemplatesResponse,
                    construct_type(
                        type_=GetSmtpTemplatesResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def create_smtp_template(
        self,
        *,
        sender: CreateSmtpTemplateRequestSender,
        subject: str,
        template_name: str,
        attachment_url: typing.Optional[str] = OMIT,
        html_content: typing.Optional[str] = OMIT,
        html_url: typing.Optional[str] = OMIT,
        is_active: typing.Optional[bool] = OMIT,
        reply_to: typing.Optional[str] = OMIT,
        tag: typing.Optional[str] = OMIT,
        to_field: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[CreateSmtpTemplateResponse]:
        """
        Parameters
        ----------
        sender : CreateSmtpTemplateRequestSender
            Sender details including id or email and name (_optional_). Only one of either Sender's email or Sender's ID shall be passed in one request at a time. For example: **{"name":"xyz", "email":"example@abc.com"}** **{"name":"xyz", "id":123}**

        subject : str
            Subject of the template

        template_name : str
            Name of the template

        attachment_url : typing.Optional[str]
            Absolute url of the attachment (**no local file**). Extension allowed: #### xlsx, xls, ods, docx, docm, doc, csv, pdf, txt, gif, jpg, jpeg, png, tif, tiff, rtf, bmp, cgm, css, shtml, html, htm, zip, xml, ppt, pptx, tar, ez, ics, mobi, msg, pub and eps'

        html_content : typing.Optional[str]
            Body of the message (HTML version). The field must have more than 10 characters. **REQUIRED if htmlUrl is empty**

        html_url : typing.Optional[str]
            Url which contents the body of the email message. REQUIRED if htmlContent is empty

        is_active : typing.Optional[bool]
            Status of template. isActive = true means template is active and isActive = false means template is inactive

        reply_to : typing.Optional[str]
            Email on which campaign recipients will be able to reply to

        tag : typing.Optional[str]
            Tag of the template

        to_field : typing.Optional[str]
            To personalize the **To** Field. If you want to include the first name and last name of your recipient, add **{FNAME} {LNAME}**. These contact attributes must already exist in your Brevo account. If input parameter **params** used please use **{{contact.FNAME}} {{contact.LNAME}}** for personalization

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[CreateSmtpTemplateResponse]
            successfully created
        """
        _response = await self._client_wrapper.httpx_client.request(
            "smtp/templates",
            method="POST",
            json={
                "attachmentUrl": attachment_url,
                "htmlContent": html_content,
                "htmlUrl": html_url,
                "isActive": is_active,
                "replyTo": reply_to,
                "sender": convert_and_respect_annotation_metadata(
                    object_=sender, annotation=CreateSmtpTemplateRequestSender, direction="write"
                ),
                "subject": subject,
                "tag": tag,
                "templateName": template_name,
                "toField": to_field,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CreateSmtpTemplateResponse,
                    construct_type(
                        type_=CreateSmtpTemplateResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_smtp_template(
        self, template_id: int, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[GetSmtpTemplateOverview]:
        """
        Parameters
        ----------
        template_id : int
            id of the template

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetSmtpTemplateOverview]
            Email template informations
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"smtp/templates/{jsonable_encoder(template_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetSmtpTemplateOverview,
                    construct_type(
                        type_=GetSmtpTemplateOverview,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def update_smtp_template(
        self,
        template_id: int,
        *,
        attachment_url: typing.Optional[str] = OMIT,
        html_content: typing.Optional[str] = OMIT,
        html_url: typing.Optional[str] = OMIT,
        is_active: typing.Optional[bool] = OMIT,
        reply_to: typing.Optional[str] = OMIT,
        sender: typing.Optional[UpdateSmtpTemplateRequestSender] = OMIT,
        subject: typing.Optional[str] = OMIT,
        tag: typing.Optional[str] = OMIT,
        template_name: typing.Optional[str] = OMIT,
        to_field: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        template_id : int
            id of the template

        attachment_url : typing.Optional[str]
            Absolute url of the attachment (**no local file**). Extensions allowed: #### xlsx, xls, ods, docx, docm, doc, csv, pdf, txt, gif, jpg, jpeg, png, tif, tiff, rtf, bmp, cgm, css, shtml, html, htm, zip, xml, ppt, pptx, tar, ez, ics, mobi, msg, pub and eps

        html_content : typing.Optional[str]
            **Required if htmlUrl is empty**. If the template is designed using Drag & Drop editor via HTML content, then the design page will not have Drag & Drop editor access for that template. Body of the message (HTML must have more than 10 characters)

        html_url : typing.Optional[str]
            **Required if htmlContent is empty**. URL to the body of the email (HTML)

        is_active : typing.Optional[bool]
            Status of the template. isActive = false means template is inactive, isActive = true means template is active

        reply_to : typing.Optional[str]
            Email on which campaign recipients will be able to reply to

        sender : typing.Optional[UpdateSmtpTemplateRequestSender]
            Sender details including id or email and name (_optional_). Only one of either Sender's email or Sender's ID shall be passed in one request at a time. For example: **{"name":"xyz", "email":"example@abc.com"}** **{"name":"xyz", "id":123}**

        subject : typing.Optional[str]
            Subject of the email

        tag : typing.Optional[str]
            Tag of the template

        template_name : typing.Optional[str]
            Name of the template

        to_field : typing.Optional[str]
            To personalize the **To** Field. If you want to include the first name and last name of your recipient, add **{FNAME} {LNAME}**. These contact attributes must already exist in your Brevo account. If input parameter **params** used please use **{{contact.FNAME}} {{contact.LNAME}}** for personalization

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"smtp/templates/{jsonable_encoder(template_id)}",
            method="PUT",
            json={
                "attachmentUrl": attachment_url,
                "htmlContent": html_content,
                "htmlUrl": html_url,
                "isActive": is_active,
                "replyTo": reply_to,
                "sender": convert_and_respect_annotation_metadata(
                    object_=sender, annotation=UpdateSmtpTemplateRequestSender, direction="write"
                ),
                "subject": subject,
                "tag": tag,
                "templateName": template_name,
                "toField": to_field,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def delete_smtp_template(
        self, template_id: int, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        template_id : int
            id of the template

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"smtp/templates/{jsonable_encoder(template_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def send_test_template(
        self,
        template_id: int,
        *,
        email_to: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        template_id : int
            Id of the template

        email_to : typing.Optional[typing.Sequence[str]]
            List of the email addresses of the recipients whom you wish to send the test mail. _If left empty, the test mail will be sent to your entire test list. You can not send more than 50 test emails per day_.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"smtp/templates/{jsonable_encoder(template_id)}/sendTest",
            method="POST",
            json={
                "emailTo": email_to,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)
