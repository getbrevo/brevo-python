# This file was auto-generated by Fern from our API Definition.

import datetime as dt
import typing

from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.request_options import RequestOptions
from ..types.get_smtp_template_overview import GetSmtpTemplateOverview
from .raw_client import AsyncRawTransactionalEmailsClient, RawTransactionalEmailsClient
from .types.create_smtp_template_request_sender import CreateSmtpTemplateRequestSender
from .types.create_smtp_template_response import CreateSmtpTemplateResponse
from .types.get_aggregated_smtp_report_response import GetAggregatedSmtpReportResponse
from .types.get_blocked_domains_response import GetBlockedDomainsResponse
from .types.get_email_event_report_request_event import GetEmailEventReportRequestEvent
from .types.get_email_event_report_request_sort import GetEmailEventReportRequestSort
from .types.get_email_event_report_response import GetEmailEventReportResponse
from .types.get_scheduled_email_by_id_request_sort import GetScheduledEmailByIdRequestSort
from .types.get_scheduled_email_by_id_request_status import GetScheduledEmailByIdRequestStatus
from .types.get_scheduled_email_by_id_response import GetScheduledEmailByIdResponse
from .types.get_smtp_report_request_sort import GetSmtpReportRequestSort
from .types.get_smtp_report_response import GetSmtpReportResponse
from .types.get_smtp_templates_request_sort import GetSmtpTemplatesRequestSort
from .types.get_smtp_templates_response import GetSmtpTemplatesResponse
from .types.get_transac_blocked_contacts_request_sort import GetTransacBlockedContactsRequestSort
from .types.get_transac_blocked_contacts_response import GetTransacBlockedContactsResponse
from .types.get_transac_email_content_response import GetTransacEmailContentResponse
from .types.get_transac_emails_list_request_sort import GetTransacEmailsListRequestSort
from .types.get_transac_emails_list_response import GetTransacEmailsListResponse
from .types.post_preview_smtp_email_templates_response import PostPreviewSmtpEmailTemplatesResponse
from .types.send_transac_email_request_attachment_item import SendTransacEmailRequestAttachmentItem
from .types.send_transac_email_request_bcc_item import SendTransacEmailRequestBccItem
from .types.send_transac_email_request_cc_item import SendTransacEmailRequestCcItem
from .types.send_transac_email_request_message_versions_item import SendTransacEmailRequestMessageVersionsItem
from .types.send_transac_email_request_reply_to import SendTransacEmailRequestReplyTo
from .types.send_transac_email_request_sender import SendTransacEmailRequestSender
from .types.send_transac_email_request_to_item import SendTransacEmailRequestToItem
from .types.send_transac_email_response import SendTransacEmailResponse
from .types.update_smtp_template_request_sender import UpdateSmtpTemplateRequestSender

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class TransactionalEmailsClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._raw_client = RawTransactionalEmailsClient(client_wrapper=client_wrapper)

    @property
    def with_raw_response(self) -> RawTransactionalEmailsClient:
        """
        Retrieves a raw implementation of this client that returns raw responses.

        Returns
        -------
        RawTransactionalEmailsClient
        """
        return self._raw_client

    def get_transac_blocked_contacts(
        self,
        *,
        start_date: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        limit: typing.Optional[int] = None,
        offset: typing.Optional[int] = None,
        senders: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        sort: typing.Optional[GetTransacBlockedContactsRequestSort] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GetTransacBlockedContactsResponse:
        """
        Parameters
        ----------
        start_date : typing.Optional[str]
            **Mandatory if endDate is used.** Starting date (YYYY-MM-DD) from which you want to fetch the blocked or unsubscribed contacts

        end_date : typing.Optional[str]
            **Mandatory if startDate is used.** Ending date (YYYY-MM-DD) till which you want to fetch the blocked or unsubscribed contacts

        limit : typing.Optional[int]
            Number of documents returned per page

        offset : typing.Optional[int]
            Index of the first document on the page

        senders : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            Comma separated list of emails of the senders from which contacts are blocked or unsubscribed

        sort : typing.Optional[GetTransacBlockedContactsRequestSort]
            Sort the results in the ascending/descending order of record creation. Default order is **descending** if `sort` is not passed

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GetTransacBlockedContactsResponse
            List of blocked or unsubscribed transactional contacts

        Examples
        --------
        from brevo import Brevo

        client = Brevo(
            api_key="YOUR_API_KEY",
        )
        client.transactional_emails.get_transac_blocked_contacts()
        """
        _response = self._raw_client.get_transac_blocked_contacts(
            start_date=start_date,
            end_date=end_date,
            limit=limit,
            offset=offset,
            senders=senders,
            sort=sort,
            request_options=request_options,
        )
        return _response.data

    def unblock_or_resubscribe_a_transactional_contact(
        self, email: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> None:
        """
        Parameters
        ----------
        email : str
            contact email (urlencoded) to unblock.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from brevo import Brevo

        client = Brevo(
            api_key="YOUR_API_KEY",
        )
        client.transactional_emails.unblock_or_resubscribe_a_transactional_contact(
            email="email",
        )
        """
        _response = self._raw_client.unblock_or_resubscribe_a_transactional_contact(
            email, request_options=request_options
        )
        return _response.data

    def get_blocked_domains(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> GetBlockedDomainsResponse:
        """
        Get the list of blocked domains

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GetBlockedDomainsResponse
            List of blocked domains

        Examples
        --------
        from brevo import Brevo

        client = Brevo(
            api_key="YOUR_API_KEY",
        )
        client.transactional_emails.get_blocked_domains()
        """
        _response = self._raw_client.get_blocked_domains(request_options=request_options)
        return _response.data

    def block_new_domain(self, *, domain: str, request_options: typing.Optional[RequestOptions] = None) -> None:
        """
        Blocks a new domain in order to avoid messages being sent to the same

        Parameters
        ----------
        domain : str
            name of the domain to be blocked

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from brevo import Brevo

        client = Brevo(
            api_key="YOUR_API_KEY",
        )
        client.transactional_emails.block_new_domain(
            domain="example.com",
        )
        """
        _response = self._raw_client.block_new_domain(domain=domain, request_options=request_options)
        return _response.data

    def delete_blocked_domain(self, domain: str, *, request_options: typing.Optional[RequestOptions] = None) -> None:
        """
        Unblocks an existing domain from the list of blocked domains

        Parameters
        ----------
        domain : str
            The name of the domain to be deleted

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from brevo import Brevo

        client = Brevo(
            api_key="YOUR_API_KEY",
        )
        client.transactional_emails.delete_blocked_domain(
            domain="domain",
        )
        """
        _response = self._raw_client.delete_blocked_domain(domain, request_options=request_options)
        return _response.data

    def delete_hardbounces(
        self,
        *,
        contact_email: typing.Optional[str] = OMIT,
        end_date: typing.Optional[str] = OMIT,
        start_date: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Delete hardbounces. To use carefully (e.g. in case of temporary ISP failures)

        Parameters
        ----------
        contact_email : typing.Optional[str]
            Target a specific email address

        end_date : typing.Optional[str]
            Ending date (YYYY-MM-DD) of the time period for deletion. The hardbounces until this date will be deleted. Must be greater than or equal to the startDate

        start_date : typing.Optional[str]
            Starting date (YYYY-MM-DD) of the time period for deletion. The hardbounces occurred after this date will be deleted. Must be less than or equal to the endDate

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from brevo import Brevo

        client = Brevo(
            api_key="YOUR_API_KEY",
        )
        client.transactional_emails.delete_hardbounces()
        """
        _response = self._raw_client.delete_hardbounces(
            contact_email=contact_email, end_date=end_date, start_date=start_date, request_options=request_options
        )
        return _response.data

    def send_transac_email(
        self,
        *,
        attachment: typing.Optional[typing.Sequence[SendTransacEmailRequestAttachmentItem]] = OMIT,
        batch_id: typing.Optional[str] = OMIT,
        bcc: typing.Optional[typing.Sequence[SendTransacEmailRequestBccItem]] = OMIT,
        cc: typing.Optional[typing.Sequence[SendTransacEmailRequestCcItem]] = OMIT,
        headers: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        html_content: typing.Optional[str] = OMIT,
        message_versions: typing.Optional[typing.Sequence[SendTransacEmailRequestMessageVersionsItem]] = OMIT,
        params: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        reply_to: typing.Optional[SendTransacEmailRequestReplyTo] = OMIT,
        scheduled_at: typing.Optional[dt.datetime] = OMIT,
        sender: typing.Optional[SendTransacEmailRequestSender] = OMIT,
        subject: typing.Optional[str] = OMIT,
        tags: typing.Optional[typing.Sequence[str]] = OMIT,
        template_id: typing.Optional[int] = OMIT,
        text_content: typing.Optional[str] = OMIT,
        to: typing.Optional[typing.Sequence[SendTransacEmailRequestToItem]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> SendTransacEmailResponse:
        """
        Parameters
        ----------
        attachment : typing.Optional[typing.Sequence[SendTransacEmailRequestAttachmentItem]]
            Array of attachment objects. Each attachment must include either an absolute URL (no local file paths) or base64-encoded content, along with the attachment filename. The `name` field is required when `content` is provided. Supported file extensions: xlsx, xls, ods, docx, docm, doc, csv, pdf, txt, gif, jpg, jpeg, png, tif, tiff, rtf, bmp, cgm, css, shtml, html, htm, zip, xml, ppt, pptx, tar, ez, ics, mobi, msg, pub, eps, odt, mp3, m4a, m4v, wma, ogg, flac, wav, aif, aifc, aiff, mp4, mov, avi, mkv, mpeg, mpg, wmv, pkpass, xlsm. When `templateId` is specified: if the template uses the New Template Language format, both `url` and `content` attachment types are supported; if the template uses the Old Template Language format, the `attachment` parameter is ignored.

        batch_id : typing.Optional[str]
            UUIDv4 identifier for the scheduled batch of transactional emails. If omitted, a valid UUIDv4 batch identifier is automatically generated.

        bcc : typing.Optional[typing.Sequence[SendTransacEmailRequestBccItem]]
            Array of BCC recipient objects. Each object contains an email address and an optional name.

        cc : typing.Optional[typing.Sequence[SendTransacEmailRequestCcItem]]
            Array of CC recipient objects. Each object contains an email address and an optional name.

        headers : typing.Optional[typing.Dict[str, typing.Any]]
            Custom email headers (non-standard headers) to include in the email. The `sender.ip` header can be set to specify the IP address used for sending transactional emails (dedicated IP users only). Header names must use Title-Case-Format (words separated by hyphens with the first letter of each word capitalized). Headers not in this format are automatically converted. Standard email headers are not supported. Example: `{"sender.ip":"1.2.3.4", "X-Mailin-custom":"some_custom_value", "Idempotency-Key":"abc-123"}`

        html_content : typing.Optional[str]
            HTML body content of the email. Required when `templateId` is not provided. Ignored when `templateId` is provided.

        message_versions : typing.Optional[typing.Sequence[SendTransacEmailRequestMessageVersionsItem]]
            Array of message version objects for sending customized email variants. The `templateId` can be customized per version only if a global `templateId` is provided. The `htmlContent` and `textContent` can be customized per version only if at least one of these is present in the global parameters. Global parameters such as `to` (required), `bcc`, `cc`, `replyTo`, and `subject` can be customized per version. Maximum total recipients per API request is 2000. Maximum recipients per message version is 99. Individual `params` objects must not exceed 100 KB. Cumulative `params` across all versions must not exceed 1000 KB. See https://developers.brevo.com/docs/batch-send-transactional-emails for detailed usage instructions.

        params : typing.Optional[typing.Dict[str, typing.Any]]
            Key-value pairs for template variable substitution. Only applicable when the template uses the New Template Language format.

        reply_to : typing.Optional[SendTransacEmailRequestReplyTo]
            Reply-to email address (required) and optional display name. Recipients will use this address when replying to the email.

        scheduled_at : typing.Optional[dt.datetime]
            UTC date-time when the email should be sent (format: YYYY-MM-DDTHH:mm:ss.SSSZ). Include timezone information in the date-time value. Scheduled emails may be delayed by up to 5 minutes.

        sender : typing.Optional[SendTransacEmailRequestSender]
            Sender information. Required when `templateId` is not provided. Specify either an email address (with optional name) or a sender ID. The `name` field is ignored when `id` is provided.

        subject : typing.Optional[str]
            Email subject line. Required when `templateId` is not provided.

        tags : typing.Optional[typing.Sequence[str]]
            Array of tags for categorizing and filtering emails

        template_id : typing.Optional[int]
            Template identifier

        text_content : typing.Optional[str]
            Plain text body content of the email. Ignored when `templateId` is provided.

        to : typing.Optional[typing.Sequence[SendTransacEmailRequestToItem]]
            Array of recipient objects. Each object contains an email address and an optional display name. Required when `messageVersions` is not provided. Ignored when `messageVersions` is provided. Example: `[{"name":"Jimmy", "email":"jimmy@example.com"}, {"name":"Joe", "email":"joe@example.com"}]`

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SendTransacEmailResponse
            Transactional email sent successfully

        Examples
        --------
        from brevo import Brevo
        from brevo.transactional_emails import (
            SendTransacEmailRequestSender,
            SendTransacEmailRequestToItem,
        )

        client = Brevo(
            api_key="YOUR_API_KEY",
        )
        client.transactional_emails.send_transac_email(
            html_content="<html><head></head><body><p>Hello,</p>This is my first transactional email sent from Brevo.</p></body></html>",
            sender=SendTransacEmailRequestSender(
                email="hello@brevo.com",
                name="Alex from Brevo",
            ),
            subject="Hello from Brevo!",
            to=[
                SendTransacEmailRequestToItem(
                    email="johndoe@example.com",
                    name="John Doe",
                )
            ],
        )
        """
        _response = self._raw_client.send_transac_email(
            attachment=attachment,
            batch_id=batch_id,
            bcc=bcc,
            cc=cc,
            headers=headers,
            html_content=html_content,
            message_versions=message_versions,
            params=params,
            reply_to=reply_to,
            scheduled_at=scheduled_at,
            sender=sender,
            subject=subject,
            tags=tags,
            template_id=template_id,
            text_content=text_content,
            to=to,
            request_options=request_options,
        )
        return _response.data

    def delete_scheduled_email_by_id(
        self, identifier: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> None:
        """
        Delete scheduled batch of emails by batchId or single scheduled email by messageId

        Parameters
        ----------
        identifier : str
            The `batchId` of scheduled emails batch (Should be a valid UUIDv4) or the `messageId` of scheduled email.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from brevo import Brevo

        client = Brevo(
            api_key="YOUR_API_KEY",
        )
        client.transactional_emails.delete_scheduled_email_by_id(
            identifier="4320f270-a4e3-4a2e-b591-edfe30a5e627",
        )
        """
        _response = self._raw_client.delete_scheduled_email_by_id(identifier, request_options=request_options)
        return _response.data

    def get_scheduled_email_by_id(
        self,
        identifier: str,
        *,
        start_date: typing.Optional[dt.date] = None,
        end_date: typing.Optional[dt.date] = None,
        sort: typing.Optional[GetScheduledEmailByIdRequestSort] = None,
        status: typing.Optional[GetScheduledEmailByIdRequestStatus] = None,
        limit: typing.Optional[int] = None,
        offset: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GetScheduledEmailByIdResponse:
        """
        Fetch scheduled batch of emails by batchId or single scheduled email by messageId (Can retrieve data upto 30 days old)

        Parameters
        ----------
        identifier : str
            The `batchId` of scheduled emails batch (Should be a valid UUIDv4) or the `messageId` of scheduled email.

        start_date : typing.Optional[dt.date]
            Mandatory if `endDate` is used. Starting date (YYYY-MM-DD) from which you want to fetch the list. Can be maximum 30 days older tha current date.

        end_date : typing.Optional[dt.date]
            Mandatory if `startDate` is used. Ending date (YYYY-MM-DD) till which you want to fetch the list. Maximum time period that can be selected is one month.

        sort : typing.Optional[GetScheduledEmailByIdRequestSort]
            Sort the results in the ascending/descending order of record creation. Default order is **descending** if `sort` is not passed. Not valid when identifier is `messageId`.

        status : typing.Optional[GetScheduledEmailByIdRequestStatus]
            Filter the records by `status` of the scheduled email batch or message. Not valid when identifier is `messageId`.

        limit : typing.Optional[int]
            Number of documents returned per page. Not valid when identifier is `messageId`.

        offset : typing.Optional[int]
            Index of the first document on the page.  Not valid when identifier is `messageId`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GetScheduledEmailByIdResponse
            Scheduled email batches

        Examples
        --------
        import datetime

        from brevo import Brevo

        client = Brevo(
            api_key="YOUR_API_KEY",
        )
        client.transactional_emails.get_scheduled_email_by_id(
            identifier="4320f270-a4e3-4a2e-b591-edfe30a5e627",
            start_date=datetime.date.fromisoformat(
                "2022-02-02",
            ),
            end_date=datetime.date.fromisoformat(
                "2022-03-02",
            ),
        )
        """
        _response = self._raw_client.get_scheduled_email_by_id(
            identifier,
            start_date=start_date,
            end_date=end_date,
            sort=sort,
            status=status,
            limit=limit,
            offset=offset,
            request_options=request_options,
        )
        return _response.data

    def get_transac_emails_list(
        self,
        *,
        email: typing.Optional[str] = None,
        template_id: typing.Optional[int] = None,
        message_id: typing.Optional[str] = None,
        start_date: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        sort: typing.Optional[GetTransacEmailsListRequestSort] = None,
        limit: typing.Optional[int] = None,
        offset: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GetTransacEmailsListResponse:
        """
        This endpoint will show the list of emails for past 30 days by default. To retrieve emails before that time, please pass startDate and endDate in query filters.

        Parameters
        ----------
        email : typing.Optional[str]
            **Mandatory if templateId and messageId are not passed in query filters.** Email address to which transactional email has been sent.

        template_id : typing.Optional[int]
            **Mandatory if email and messageId are not passed in query filters.** Id of the template that was used to compose transactional email.

        message_id : typing.Optional[str]
            **Mandatory if templateId and email are not passed in query filters.** Message ID of the transactional email sent.

        start_date : typing.Optional[str]
            **Mandatory if endDate is used.** Starting date (YYYY-MM-DD) from which you want to fetch the list. **Maximum time period that can be selected is one month**.

        end_date : typing.Optional[str]
            **Mandatory if startDate is used.** Ending date (YYYY-MM-DD) till which you want to fetch the list. **Maximum time period that can be selected is one month.**

        sort : typing.Optional[GetTransacEmailsListRequestSort]
            Sort the results in the ascending/descending order of record creation. Default order is **descending** if `sort` is not passed

        limit : typing.Optional[int]
            Number of documents returned per page

        offset : typing.Optional[int]
            Index of the first document in the page

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GetTransacEmailsListResponse
            List of transactional emails

        Examples
        --------
        from brevo import Brevo

        client = Brevo(
            api_key="YOUR_API_KEY",
        )
        client.transactional_emails.get_transac_emails_list()
        """
        _response = self._raw_client.get_transac_emails_list(
            email=email,
            template_id=template_id,
            message_id=message_id,
            start_date=start_date,
            end_date=end_date,
            sort=sort,
            limit=limit,
            offset=offset,
            request_options=request_options,
        )
        return _response.data

    def get_transac_email_content(
        self, uuid_: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> GetTransacEmailContentResponse:
        """
        <Note title="How to get uuid?">
        You can get the uuid using either of the following methods:

        Send a GET request to https://api.brevo.com/v3/smtp/emails and pass the message_id in the url. Use your api-key to authenticate the request and you will get your uuid as a response.

        The uuid can also be fetched from the transactional logs page in your Brevo account, from the address URL.
        </Note>

        Parameters
        ----------
        uuid_ : str
            Unique id of the transactional email that has been sent to a particular contact

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GetTransacEmailContentResponse
            Transactional email content

        Examples
        --------
        from brevo import Brevo

        client = Brevo(
            api_key="YOUR_API_KEY",
        )
        client.transactional_emails.get_transac_email_content(
            uuid_="uuid",
        )
        """
        _response = self._raw_client.get_transac_email_content(uuid_, request_options=request_options)
        return _response.data

    def delete_an_smtp_transactional_log(
        self, identifier: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> None:
        """
        Parameters
        ----------
        identifier : str
            MessageId of the transactional log(s) to delete

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from brevo import Brevo

        client = Brevo(
            api_key="YOUR_API_KEY",
        )
        client.transactional_emails.delete_an_smtp_transactional_log(
            identifier="identifier",
        )
        """
        _response = self._raw_client.delete_an_smtp_transactional_log(identifier, request_options=request_options)
        return _response.data

    def get_aggregated_smtp_report(
        self,
        *,
        start_date: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        days: typing.Optional[int] = None,
        tag: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GetAggregatedSmtpReportResponse:
        """
        This endpoint will show the aggregated stats for past 90 days by default if `startDate` and `endDate` OR `days` is not passed. The date range can not exceed 90 days

        Parameters
        ----------
        start_date : typing.Optional[str]
            **Mandatory if endDate is used.** Starting date of the report (YYYY-MM-DD). Must be lower than equal to endDate

        end_date : typing.Optional[str]
            **Mandatory if startDate is used.** Ending date of the report (YYYY-MM-DD). Must be greater than equal to startDate

        days : typing.Optional[int]
            Number of days in the past including today (positive integer). _Not compatible with 'startDate' and 'endDate'_

        tag : typing.Optional[str]
            Tag of the emails

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GetAggregatedSmtpReportResponse
            Aggregated report informations

        Examples
        --------
        from brevo import Brevo

        client = Brevo(
            api_key="YOUR_API_KEY",
        )
        client.transactional_emails.get_aggregated_smtp_report()
        """
        _response = self._raw_client.get_aggregated_smtp_report(
            start_date=start_date, end_date=end_date, days=days, tag=tag, request_options=request_options
        )
        return _response.data

    def get_email_event_report(
        self,
        *,
        limit: typing.Optional[int] = None,
        offset: typing.Optional[int] = None,
        start_date: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        days: typing.Optional[int] = None,
        email: typing.Optional[str] = None,
        event: typing.Optional[GetEmailEventReportRequestEvent] = None,
        tags: typing.Optional[str] = None,
        message_id: typing.Optional[str] = None,
        template_id: typing.Optional[int] = None,
        sort: typing.Optional[GetEmailEventReportRequestSort] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GetEmailEventReportResponse:
        """
        This endpoint will show the aggregated stats for past 30 days by default if `startDate` and `endDate` OR `days` is not passed. The date range can not exceed 90 days

        Parameters
        ----------
        limit : typing.Optional[int]
            Number limitation for the result returned

        offset : typing.Optional[int]
            Beginning point in the list to retrieve from.

        start_date : typing.Optional[str]
            **Mandatory if endDate is used.** Starting date of the report (YYYY-MM-DD). Must be lower than equal to endDate

        end_date : typing.Optional[str]
            **Mandatory if startDate is used.** Ending date of the report (YYYY-MM-DD). Must be greater than equal to startDate

        days : typing.Optional[int]
            Number of days in the past including today (positive integer). _Not compatible with 'startDate' and 'endDate'_

        email : typing.Optional[str]
            Filter the report for a specific email addresses

        event : typing.Optional[GetEmailEventReportRequestEvent]
            Filter the report for a specific event type

        tags : typing.Optional[str]
            Filter the report for tags (serialized and urlencoded array)

        message_id : typing.Optional[str]
            Filter on a specific message id

        template_id : typing.Optional[int]
            Filter on a specific template id

        sort : typing.Optional[GetEmailEventReportRequestSort]
            Sort the results in the ascending/descending order of record creation. Default order is **descending** if `sort` is not passed

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GetEmailEventReportResponse
            Email events report informations

        Examples
        --------
        from brevo import Brevo

        client = Brevo(
            api_key="YOUR_API_KEY",
        )
        client.transactional_emails.get_email_event_report()
        """
        _response = self._raw_client.get_email_event_report(
            limit=limit,
            offset=offset,
            start_date=start_date,
            end_date=end_date,
            days=days,
            email=email,
            event=event,
            tags=tags,
            message_id=message_id,
            template_id=template_id,
            sort=sort,
            request_options=request_options,
        )
        return _response.data

    def get_smtp_report(
        self,
        *,
        limit: typing.Optional[int] = None,
        offset: typing.Optional[int] = None,
        start_date: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        days: typing.Optional[int] = None,
        tag: typing.Optional[str] = None,
        sort: typing.Optional[GetSmtpReportRequestSort] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GetSmtpReportResponse:
        """
        Parameters
        ----------
        limit : typing.Optional[int]
            Number of documents returned per page

        offset : typing.Optional[int]
            Index of the first document on the page

        start_date : typing.Optional[str]
            **Mandatory if endDate is used.** Starting date of the report (YYYY-MM-DD)

        end_date : typing.Optional[str]
            **Mandatory if startDate is used.** Ending date of the report (YYYY-MM-DD)

        days : typing.Optional[int]
            Number of days in the past including today (positive integer). _Not compatible with 'startDate' and 'endDate'_

        tag : typing.Optional[str]
            Tag of the emails

        sort : typing.Optional[GetSmtpReportRequestSort]
            Sort the results in the ascending/descending order of record creation. Default order is **descending** if `sort` is not passed

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GetSmtpReportResponse
            Aggregated report informations

        Examples
        --------
        from brevo import Brevo

        client = Brevo(
            api_key="YOUR_API_KEY",
        )
        client.transactional_emails.get_smtp_report()
        """
        _response = self._raw_client.get_smtp_report(
            limit=limit,
            offset=offset,
            start_date=start_date,
            end_date=end_date,
            days=days,
            tag=tag,
            sort=sort,
            request_options=request_options,
        )
        return _response.data

    def post_preview_smtp_email_templates(
        self, *, request: typing.Any, request_options: typing.Optional[RequestOptions] = None
    ) -> PostPreviewSmtpEmailTemplatesResponse:
        """
        Parameters
        ----------
        request : typing.Any

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        PostPreviewSmtpEmailTemplatesResponse
            successfully fetched template's preview fields

        Examples
        --------
        from brevo import Brevo

        client = Brevo(
            api_key="YOUR_API_KEY",
        )
        client.transactional_emails.post_preview_smtp_email_templates(
            request={"key": "value"},
        )
        """
        _response = self._raw_client.post_preview_smtp_email_templates(request=request, request_options=request_options)
        return _response.data

    def get_smtp_templates(
        self,
        *,
        template_status: typing.Optional[bool] = None,
        limit: typing.Optional[int] = None,
        offset: typing.Optional[int] = None,
        sort: typing.Optional[GetSmtpTemplatesRequestSort] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GetSmtpTemplatesResponse:
        """
        Parameters
        ----------
        template_status : typing.Optional[bool]
            Filter on the status of the template. Active = true, inactive = false

        limit : typing.Optional[int]
            Number of documents returned per page

        offset : typing.Optional[int]
            Index of the first document in the page

        sort : typing.Optional[GetSmtpTemplatesRequestSort]
            Sort the results in the ascending/descending order of record creation. Default order is **descending** if `sort` is not passed

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GetSmtpTemplatesResponse
            transactional email templates informations

        Examples
        --------
        from brevo import Brevo

        client = Brevo(
            api_key="YOUR_API_KEY",
        )
        client.transactional_emails.get_smtp_templates()
        """
        _response = self._raw_client.get_smtp_templates(
            template_status=template_status, limit=limit, offset=offset, sort=sort, request_options=request_options
        )
        return _response.data

    def create_smtp_template(
        self,
        *,
        sender: CreateSmtpTemplateRequestSender,
        subject: str,
        template_name: str,
        attachment_url: typing.Optional[str] = OMIT,
        html_content: typing.Optional[str] = OMIT,
        html_url: typing.Optional[str] = OMIT,
        is_active: typing.Optional[bool] = OMIT,
        reply_to: typing.Optional[str] = OMIT,
        tag: typing.Optional[str] = OMIT,
        to_field: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CreateSmtpTemplateResponse:
        """
        Parameters
        ----------
        sender : CreateSmtpTemplateRequestSender
            Sender details including id or email and name (_optional_). Only one of either Sender's email or Sender's ID shall be passed in one request at a time. For example: **{"name":"xyz", "email":"example@abc.com"}** **{"name":"xyz", "id":123}**

        subject : str
            Subject of the template

        template_name : str
            Name of the template

        attachment_url : typing.Optional[str]
            Absolute url of the attachment (**no local file**). Extension allowed: #### xlsx, xls, ods, docx, docm, doc, csv, pdf, txt, gif, jpg, jpeg, png, tif, tiff, rtf, bmp, cgm, css, shtml, html, htm, zip, xml, ppt, pptx, tar, ez, ics, mobi, msg, pub and eps'

        html_content : typing.Optional[str]
            Body of the message (HTML version). The field must have more than 10 characters. **REQUIRED if htmlUrl is empty**

        html_url : typing.Optional[str]
            Url which contents the body of the email message. REQUIRED if htmlContent is empty

        is_active : typing.Optional[bool]
            Status of template. isActive = true means template is active and isActive = false means template is inactive

        reply_to : typing.Optional[str]
            Email on which campaign recipients will be able to reply to

        tag : typing.Optional[str]
            Tag of the template

        to_field : typing.Optional[str]
            To personalize the **To** Field. If you want to include the first name and last name of your recipient, add **{FNAME} {LNAME}**. These contact attributes must already exist in your Brevo account. If input parameter **params** used please use **{{contact.FNAME}} {{contact.LNAME}}** for personalization

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CreateSmtpTemplateResponse
            successfully created

        Examples
        --------
        from brevo import Brevo
        from brevo.transactional_emails import CreateSmtpTemplateRequestSender

        client = Brevo(
            api_key="YOUR_API_KEY",
        )
        client.transactional_emails.create_smtp_template(
            sender=CreateSmtpTemplateRequestSender(),
            subject="Thanks for your purchase !",
            template_name="Order Confirmation - EN",
        )
        """
        _response = self._raw_client.create_smtp_template(
            sender=sender,
            subject=subject,
            template_name=template_name,
            attachment_url=attachment_url,
            html_content=html_content,
            html_url=html_url,
            is_active=is_active,
            reply_to=reply_to,
            tag=tag,
            to_field=to_field,
            request_options=request_options,
        )
        return _response.data

    def get_smtp_template(
        self, template_id: int, *, request_options: typing.Optional[RequestOptions] = None
    ) -> GetSmtpTemplateOverview:
        """
        Parameters
        ----------
        template_id : int
            id of the template

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GetSmtpTemplateOverview
            Email template informations

        Examples
        --------
        from brevo import Brevo

        client = Brevo(
            api_key="YOUR_API_KEY",
        )
        client.transactional_emails.get_smtp_template(
            template_id=1000000,
        )
        """
        _response = self._raw_client.get_smtp_template(template_id, request_options=request_options)
        return _response.data

    def update_smtp_template(
        self,
        template_id: int,
        *,
        attachment_url: typing.Optional[str] = OMIT,
        html_content: typing.Optional[str] = OMIT,
        html_url: typing.Optional[str] = OMIT,
        is_active: typing.Optional[bool] = OMIT,
        reply_to: typing.Optional[str] = OMIT,
        sender: typing.Optional[UpdateSmtpTemplateRequestSender] = OMIT,
        subject: typing.Optional[str] = OMIT,
        tag: typing.Optional[str] = OMIT,
        template_name: typing.Optional[str] = OMIT,
        to_field: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        template_id : int
            id of the template

        attachment_url : typing.Optional[str]
            Absolute url of the attachment (**no local file**). Extensions allowed: #### xlsx, xls, ods, docx, docm, doc, csv, pdf, txt, gif, jpg, jpeg, png, tif, tiff, rtf, bmp, cgm, css, shtml, html, htm, zip, xml, ppt, pptx, tar, ez, ics, mobi, msg, pub and eps

        html_content : typing.Optional[str]
            **Required if htmlUrl is empty**. If the template is designed using Drag & Drop editor via HTML content, then the design page will not have Drag & Drop editor access for that template. Body of the message (HTML must have more than 10 characters)

        html_url : typing.Optional[str]
            **Required if htmlContent is empty**. URL to the body of the email (HTML)

        is_active : typing.Optional[bool]
            Status of the template. isActive = false means template is inactive, isActive = true means template is active

        reply_to : typing.Optional[str]
            Email on which campaign recipients will be able to reply to

        sender : typing.Optional[UpdateSmtpTemplateRequestSender]
            Sender details including id or email and name (_optional_). Only one of either Sender's email or Sender's ID shall be passed in one request at a time. For example: **{"name":"xyz", "email":"example@abc.com"}** **{"name":"xyz", "id":123}**

        subject : typing.Optional[str]
            Subject of the email

        tag : typing.Optional[str]
            Tag of the template

        template_name : typing.Optional[str]
            Name of the template

        to_field : typing.Optional[str]
            To personalize the **To** Field. If you want to include the first name and last name of your recipient, add **{FNAME} {LNAME}**. These contact attributes must already exist in your Brevo account. If input parameter **params** used please use **{{contact.FNAME}} {{contact.LNAME}}** for personalization

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from brevo import Brevo

        client = Brevo(
            api_key="YOUR_API_KEY",
        )
        client.transactional_emails.update_smtp_template(
            template_id=1000000,
        )
        """
        _response = self._raw_client.update_smtp_template(
            template_id,
            attachment_url=attachment_url,
            html_content=html_content,
            html_url=html_url,
            is_active=is_active,
            reply_to=reply_to,
            sender=sender,
            subject=subject,
            tag=tag,
            template_name=template_name,
            to_field=to_field,
            request_options=request_options,
        )
        return _response.data

    def delete_smtp_template(
        self, template_id: int, *, request_options: typing.Optional[RequestOptions] = None
    ) -> None:
        """
        Parameters
        ----------
        template_id : int
            id of the template

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from brevo import Brevo

        client = Brevo(
            api_key="YOUR_API_KEY",
        )
        client.transactional_emails.delete_smtp_template(
            template_id=1000000,
        )
        """
        _response = self._raw_client.delete_smtp_template(template_id, request_options=request_options)
        return _response.data

    def send_test_template(
        self,
        template_id: int,
        *,
        email_to: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        template_id : int
            Id of the template

        email_to : typing.Optional[typing.Sequence[str]]
            List of the email addresses of the recipients whom you wish to send the test mail. _If left empty, the test mail will be sent to your entire test list. You can not send more than 50 test emails per day_.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from brevo import Brevo

        client = Brevo(
            api_key="YOUR_API_KEY",
        )
        client.transactional_emails.send_test_template(
            template_id=1000000,
        )
        """
        _response = self._raw_client.send_test_template(template_id, email_to=email_to, request_options=request_options)
        return _response.data


class AsyncTransactionalEmailsClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._raw_client = AsyncRawTransactionalEmailsClient(client_wrapper=client_wrapper)

    @property
    def with_raw_response(self) -> AsyncRawTransactionalEmailsClient:
        """
        Retrieves a raw implementation of this client that returns raw responses.

        Returns
        -------
        AsyncRawTransactionalEmailsClient
        """
        return self._raw_client

    async def get_transac_blocked_contacts(
        self,
        *,
        start_date: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        limit: typing.Optional[int] = None,
        offset: typing.Optional[int] = None,
        senders: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        sort: typing.Optional[GetTransacBlockedContactsRequestSort] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GetTransacBlockedContactsResponse:
        """
        Parameters
        ----------
        start_date : typing.Optional[str]
            **Mandatory if endDate is used.** Starting date (YYYY-MM-DD) from which you want to fetch the blocked or unsubscribed contacts

        end_date : typing.Optional[str]
            **Mandatory if startDate is used.** Ending date (YYYY-MM-DD) till which you want to fetch the blocked or unsubscribed contacts

        limit : typing.Optional[int]
            Number of documents returned per page

        offset : typing.Optional[int]
            Index of the first document on the page

        senders : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            Comma separated list of emails of the senders from which contacts are blocked or unsubscribed

        sort : typing.Optional[GetTransacBlockedContactsRequestSort]
            Sort the results in the ascending/descending order of record creation. Default order is **descending** if `sort` is not passed

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GetTransacBlockedContactsResponse
            List of blocked or unsubscribed transactional contacts

        Examples
        --------
        import asyncio

        from brevo import AsyncBrevo

        client = AsyncBrevo(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.transactional_emails.get_transac_blocked_contacts()


        asyncio.run(main())
        """
        _response = await self._raw_client.get_transac_blocked_contacts(
            start_date=start_date,
            end_date=end_date,
            limit=limit,
            offset=offset,
            senders=senders,
            sort=sort,
            request_options=request_options,
        )
        return _response.data

    async def unblock_or_resubscribe_a_transactional_contact(
        self, email: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> None:
        """
        Parameters
        ----------
        email : str
            contact email (urlencoded) to unblock.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from brevo import AsyncBrevo

        client = AsyncBrevo(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.transactional_emails.unblock_or_resubscribe_a_transactional_contact(
                email="email",
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.unblock_or_resubscribe_a_transactional_contact(
            email, request_options=request_options
        )
        return _response.data

    async def get_blocked_domains(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> GetBlockedDomainsResponse:
        """
        Get the list of blocked domains

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GetBlockedDomainsResponse
            List of blocked domains

        Examples
        --------
        import asyncio

        from brevo import AsyncBrevo

        client = AsyncBrevo(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.transactional_emails.get_blocked_domains()


        asyncio.run(main())
        """
        _response = await self._raw_client.get_blocked_domains(request_options=request_options)
        return _response.data

    async def block_new_domain(self, *, domain: str, request_options: typing.Optional[RequestOptions] = None) -> None:
        """
        Blocks a new domain in order to avoid messages being sent to the same

        Parameters
        ----------
        domain : str
            name of the domain to be blocked

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from brevo import AsyncBrevo

        client = AsyncBrevo(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.transactional_emails.block_new_domain(
                domain="example.com",
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.block_new_domain(domain=domain, request_options=request_options)
        return _response.data

    async def delete_blocked_domain(
        self, domain: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> None:
        """
        Unblocks an existing domain from the list of blocked domains

        Parameters
        ----------
        domain : str
            The name of the domain to be deleted

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from brevo import AsyncBrevo

        client = AsyncBrevo(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.transactional_emails.delete_blocked_domain(
                domain="domain",
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.delete_blocked_domain(domain, request_options=request_options)
        return _response.data

    async def delete_hardbounces(
        self,
        *,
        contact_email: typing.Optional[str] = OMIT,
        end_date: typing.Optional[str] = OMIT,
        start_date: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Delete hardbounces. To use carefully (e.g. in case of temporary ISP failures)

        Parameters
        ----------
        contact_email : typing.Optional[str]
            Target a specific email address

        end_date : typing.Optional[str]
            Ending date (YYYY-MM-DD) of the time period for deletion. The hardbounces until this date will be deleted. Must be greater than or equal to the startDate

        start_date : typing.Optional[str]
            Starting date (YYYY-MM-DD) of the time period for deletion. The hardbounces occurred after this date will be deleted. Must be less than or equal to the endDate

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from brevo import AsyncBrevo

        client = AsyncBrevo(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.transactional_emails.delete_hardbounces()


        asyncio.run(main())
        """
        _response = await self._raw_client.delete_hardbounces(
            contact_email=contact_email, end_date=end_date, start_date=start_date, request_options=request_options
        )
        return _response.data

    async def send_transac_email(
        self,
        *,
        attachment: typing.Optional[typing.Sequence[SendTransacEmailRequestAttachmentItem]] = OMIT,
        batch_id: typing.Optional[str] = OMIT,
        bcc: typing.Optional[typing.Sequence[SendTransacEmailRequestBccItem]] = OMIT,
        cc: typing.Optional[typing.Sequence[SendTransacEmailRequestCcItem]] = OMIT,
        headers: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        html_content: typing.Optional[str] = OMIT,
        message_versions: typing.Optional[typing.Sequence[SendTransacEmailRequestMessageVersionsItem]] = OMIT,
        params: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        reply_to: typing.Optional[SendTransacEmailRequestReplyTo] = OMIT,
        scheduled_at: typing.Optional[dt.datetime] = OMIT,
        sender: typing.Optional[SendTransacEmailRequestSender] = OMIT,
        subject: typing.Optional[str] = OMIT,
        tags: typing.Optional[typing.Sequence[str]] = OMIT,
        template_id: typing.Optional[int] = OMIT,
        text_content: typing.Optional[str] = OMIT,
        to: typing.Optional[typing.Sequence[SendTransacEmailRequestToItem]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> SendTransacEmailResponse:
        """
        Parameters
        ----------
        attachment : typing.Optional[typing.Sequence[SendTransacEmailRequestAttachmentItem]]
            Array of attachment objects. Each attachment must include either an absolute URL (no local file paths) or base64-encoded content, along with the attachment filename. The `name` field is required when `content` is provided. Supported file extensions: xlsx, xls, ods, docx, docm, doc, csv, pdf, txt, gif, jpg, jpeg, png, tif, tiff, rtf, bmp, cgm, css, shtml, html, htm, zip, xml, ppt, pptx, tar, ez, ics, mobi, msg, pub, eps, odt, mp3, m4a, m4v, wma, ogg, flac, wav, aif, aifc, aiff, mp4, mov, avi, mkv, mpeg, mpg, wmv, pkpass, xlsm. When `templateId` is specified: if the template uses the New Template Language format, both `url` and `content` attachment types are supported; if the template uses the Old Template Language format, the `attachment` parameter is ignored.

        batch_id : typing.Optional[str]
            UUIDv4 identifier for the scheduled batch of transactional emails. If omitted, a valid UUIDv4 batch identifier is automatically generated.

        bcc : typing.Optional[typing.Sequence[SendTransacEmailRequestBccItem]]
            Array of BCC recipient objects. Each object contains an email address and an optional name.

        cc : typing.Optional[typing.Sequence[SendTransacEmailRequestCcItem]]
            Array of CC recipient objects. Each object contains an email address and an optional name.

        headers : typing.Optional[typing.Dict[str, typing.Any]]
            Custom email headers (non-standard headers) to include in the email. The `sender.ip` header can be set to specify the IP address used for sending transactional emails (dedicated IP users only). Header names must use Title-Case-Format (words separated by hyphens with the first letter of each word capitalized). Headers not in this format are automatically converted. Standard email headers are not supported. Example: `{"sender.ip":"1.2.3.4", "X-Mailin-custom":"some_custom_value", "Idempotency-Key":"abc-123"}`

        html_content : typing.Optional[str]
            HTML body content of the email. Required when `templateId` is not provided. Ignored when `templateId` is provided.

        message_versions : typing.Optional[typing.Sequence[SendTransacEmailRequestMessageVersionsItem]]
            Array of message version objects for sending customized email variants. The `templateId` can be customized per version only if a global `templateId` is provided. The `htmlContent` and `textContent` can be customized per version only if at least one of these is present in the global parameters. Global parameters such as `to` (required), `bcc`, `cc`, `replyTo`, and `subject` can be customized per version. Maximum total recipients per API request is 2000. Maximum recipients per message version is 99. Individual `params` objects must not exceed 100 KB. Cumulative `params` across all versions must not exceed 1000 KB. See https://developers.brevo.com/docs/batch-send-transactional-emails for detailed usage instructions.

        params : typing.Optional[typing.Dict[str, typing.Any]]
            Key-value pairs for template variable substitution. Only applicable when the template uses the New Template Language format.

        reply_to : typing.Optional[SendTransacEmailRequestReplyTo]
            Reply-to email address (required) and optional display name. Recipients will use this address when replying to the email.

        scheduled_at : typing.Optional[dt.datetime]
            UTC date-time when the email should be sent (format: YYYY-MM-DDTHH:mm:ss.SSSZ). Include timezone information in the date-time value. Scheduled emails may be delayed by up to 5 minutes.

        sender : typing.Optional[SendTransacEmailRequestSender]
            Sender information. Required when `templateId` is not provided. Specify either an email address (with optional name) or a sender ID. The `name` field is ignored when `id` is provided.

        subject : typing.Optional[str]
            Email subject line. Required when `templateId` is not provided.

        tags : typing.Optional[typing.Sequence[str]]
            Array of tags for categorizing and filtering emails

        template_id : typing.Optional[int]
            Template identifier

        text_content : typing.Optional[str]
            Plain text body content of the email. Ignored when `templateId` is provided.

        to : typing.Optional[typing.Sequence[SendTransacEmailRequestToItem]]
            Array of recipient objects. Each object contains an email address and an optional display name. Required when `messageVersions` is not provided. Ignored when `messageVersions` is provided. Example: `[{"name":"Jimmy", "email":"jimmy@example.com"}, {"name":"Joe", "email":"joe@example.com"}]`

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SendTransacEmailResponse
            Transactional email sent successfully

        Examples
        --------
        import asyncio

        from brevo import AsyncBrevo
        from brevo.transactional_emails import (
            SendTransacEmailRequestSender,
            SendTransacEmailRequestToItem,
        )

        client = AsyncBrevo(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.transactional_emails.send_transac_email(
                html_content="<html><head></head><body><p>Hello,</p>This is my first transactional email sent from Brevo.</p></body></html>",
                sender=SendTransacEmailRequestSender(
                    email="hello@brevo.com",
                    name="Alex from Brevo",
                ),
                subject="Hello from Brevo!",
                to=[
                    SendTransacEmailRequestToItem(
                        email="johndoe@example.com",
                        name="John Doe",
                    )
                ],
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.send_transac_email(
            attachment=attachment,
            batch_id=batch_id,
            bcc=bcc,
            cc=cc,
            headers=headers,
            html_content=html_content,
            message_versions=message_versions,
            params=params,
            reply_to=reply_to,
            scheduled_at=scheduled_at,
            sender=sender,
            subject=subject,
            tags=tags,
            template_id=template_id,
            text_content=text_content,
            to=to,
            request_options=request_options,
        )
        return _response.data

    async def delete_scheduled_email_by_id(
        self, identifier: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> None:
        """
        Delete scheduled batch of emails by batchId or single scheduled email by messageId

        Parameters
        ----------
        identifier : str
            The `batchId` of scheduled emails batch (Should be a valid UUIDv4) or the `messageId` of scheduled email.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from brevo import AsyncBrevo

        client = AsyncBrevo(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.transactional_emails.delete_scheduled_email_by_id(
                identifier="4320f270-a4e3-4a2e-b591-edfe30a5e627",
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.delete_scheduled_email_by_id(identifier, request_options=request_options)
        return _response.data

    async def get_scheduled_email_by_id(
        self,
        identifier: str,
        *,
        start_date: typing.Optional[dt.date] = None,
        end_date: typing.Optional[dt.date] = None,
        sort: typing.Optional[GetScheduledEmailByIdRequestSort] = None,
        status: typing.Optional[GetScheduledEmailByIdRequestStatus] = None,
        limit: typing.Optional[int] = None,
        offset: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GetScheduledEmailByIdResponse:
        """
        Fetch scheduled batch of emails by batchId or single scheduled email by messageId (Can retrieve data upto 30 days old)

        Parameters
        ----------
        identifier : str
            The `batchId` of scheduled emails batch (Should be a valid UUIDv4) or the `messageId` of scheduled email.

        start_date : typing.Optional[dt.date]
            Mandatory if `endDate` is used. Starting date (YYYY-MM-DD) from which you want to fetch the list. Can be maximum 30 days older tha current date.

        end_date : typing.Optional[dt.date]
            Mandatory if `startDate` is used. Ending date (YYYY-MM-DD) till which you want to fetch the list. Maximum time period that can be selected is one month.

        sort : typing.Optional[GetScheduledEmailByIdRequestSort]
            Sort the results in the ascending/descending order of record creation. Default order is **descending** if `sort` is not passed. Not valid when identifier is `messageId`.

        status : typing.Optional[GetScheduledEmailByIdRequestStatus]
            Filter the records by `status` of the scheduled email batch or message. Not valid when identifier is `messageId`.

        limit : typing.Optional[int]
            Number of documents returned per page. Not valid when identifier is `messageId`.

        offset : typing.Optional[int]
            Index of the first document on the page.  Not valid when identifier is `messageId`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GetScheduledEmailByIdResponse
            Scheduled email batches

        Examples
        --------
        import asyncio
        import datetime

        from brevo import AsyncBrevo

        client = AsyncBrevo(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.transactional_emails.get_scheduled_email_by_id(
                identifier="4320f270-a4e3-4a2e-b591-edfe30a5e627",
                start_date=datetime.date.fromisoformat(
                    "2022-02-02",
                ),
                end_date=datetime.date.fromisoformat(
                    "2022-03-02",
                ),
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.get_scheduled_email_by_id(
            identifier,
            start_date=start_date,
            end_date=end_date,
            sort=sort,
            status=status,
            limit=limit,
            offset=offset,
            request_options=request_options,
        )
        return _response.data

    async def get_transac_emails_list(
        self,
        *,
        email: typing.Optional[str] = None,
        template_id: typing.Optional[int] = None,
        message_id: typing.Optional[str] = None,
        start_date: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        sort: typing.Optional[GetTransacEmailsListRequestSort] = None,
        limit: typing.Optional[int] = None,
        offset: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GetTransacEmailsListResponse:
        """
        This endpoint will show the list of emails for past 30 days by default. To retrieve emails before that time, please pass startDate and endDate in query filters.

        Parameters
        ----------
        email : typing.Optional[str]
            **Mandatory if templateId and messageId are not passed in query filters.** Email address to which transactional email has been sent.

        template_id : typing.Optional[int]
            **Mandatory if email and messageId are not passed in query filters.** Id of the template that was used to compose transactional email.

        message_id : typing.Optional[str]
            **Mandatory if templateId and email are not passed in query filters.** Message ID of the transactional email sent.

        start_date : typing.Optional[str]
            **Mandatory if endDate is used.** Starting date (YYYY-MM-DD) from which you want to fetch the list. **Maximum time period that can be selected is one month**.

        end_date : typing.Optional[str]
            **Mandatory if startDate is used.** Ending date (YYYY-MM-DD) till which you want to fetch the list. **Maximum time period that can be selected is one month.**

        sort : typing.Optional[GetTransacEmailsListRequestSort]
            Sort the results in the ascending/descending order of record creation. Default order is **descending** if `sort` is not passed

        limit : typing.Optional[int]
            Number of documents returned per page

        offset : typing.Optional[int]
            Index of the first document in the page

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GetTransacEmailsListResponse
            List of transactional emails

        Examples
        --------
        import asyncio

        from brevo import AsyncBrevo

        client = AsyncBrevo(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.transactional_emails.get_transac_emails_list()


        asyncio.run(main())
        """
        _response = await self._raw_client.get_transac_emails_list(
            email=email,
            template_id=template_id,
            message_id=message_id,
            start_date=start_date,
            end_date=end_date,
            sort=sort,
            limit=limit,
            offset=offset,
            request_options=request_options,
        )
        return _response.data

    async def get_transac_email_content(
        self, uuid_: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> GetTransacEmailContentResponse:
        """
        <Note title="How to get uuid?">
        You can get the uuid using either of the following methods:

        Send a GET request to https://api.brevo.com/v3/smtp/emails and pass the message_id in the url. Use your api-key to authenticate the request and you will get your uuid as a response.

        The uuid can also be fetched from the transactional logs page in your Brevo account, from the address URL.
        </Note>

        Parameters
        ----------
        uuid_ : str
            Unique id of the transactional email that has been sent to a particular contact

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GetTransacEmailContentResponse
            Transactional email content

        Examples
        --------
        import asyncio

        from brevo import AsyncBrevo

        client = AsyncBrevo(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.transactional_emails.get_transac_email_content(
                uuid_="uuid",
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.get_transac_email_content(uuid_, request_options=request_options)
        return _response.data

    async def delete_an_smtp_transactional_log(
        self, identifier: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> None:
        """
        Parameters
        ----------
        identifier : str
            MessageId of the transactional log(s) to delete

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from brevo import AsyncBrevo

        client = AsyncBrevo(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.transactional_emails.delete_an_smtp_transactional_log(
                identifier="identifier",
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.delete_an_smtp_transactional_log(identifier, request_options=request_options)
        return _response.data

    async def get_aggregated_smtp_report(
        self,
        *,
        start_date: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        days: typing.Optional[int] = None,
        tag: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GetAggregatedSmtpReportResponse:
        """
        This endpoint will show the aggregated stats for past 90 days by default if `startDate` and `endDate` OR `days` is not passed. The date range can not exceed 90 days

        Parameters
        ----------
        start_date : typing.Optional[str]
            **Mandatory if endDate is used.** Starting date of the report (YYYY-MM-DD). Must be lower than equal to endDate

        end_date : typing.Optional[str]
            **Mandatory if startDate is used.** Ending date of the report (YYYY-MM-DD). Must be greater than equal to startDate

        days : typing.Optional[int]
            Number of days in the past including today (positive integer). _Not compatible with 'startDate' and 'endDate'_

        tag : typing.Optional[str]
            Tag of the emails

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GetAggregatedSmtpReportResponse
            Aggregated report informations

        Examples
        --------
        import asyncio

        from brevo import AsyncBrevo

        client = AsyncBrevo(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.transactional_emails.get_aggregated_smtp_report()


        asyncio.run(main())
        """
        _response = await self._raw_client.get_aggregated_smtp_report(
            start_date=start_date, end_date=end_date, days=days, tag=tag, request_options=request_options
        )
        return _response.data

    async def get_email_event_report(
        self,
        *,
        limit: typing.Optional[int] = None,
        offset: typing.Optional[int] = None,
        start_date: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        days: typing.Optional[int] = None,
        email: typing.Optional[str] = None,
        event: typing.Optional[GetEmailEventReportRequestEvent] = None,
        tags: typing.Optional[str] = None,
        message_id: typing.Optional[str] = None,
        template_id: typing.Optional[int] = None,
        sort: typing.Optional[GetEmailEventReportRequestSort] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GetEmailEventReportResponse:
        """
        This endpoint will show the aggregated stats for past 30 days by default if `startDate` and `endDate` OR `days` is not passed. The date range can not exceed 90 days

        Parameters
        ----------
        limit : typing.Optional[int]
            Number limitation for the result returned

        offset : typing.Optional[int]
            Beginning point in the list to retrieve from.

        start_date : typing.Optional[str]
            **Mandatory if endDate is used.** Starting date of the report (YYYY-MM-DD). Must be lower than equal to endDate

        end_date : typing.Optional[str]
            **Mandatory if startDate is used.** Ending date of the report (YYYY-MM-DD). Must be greater than equal to startDate

        days : typing.Optional[int]
            Number of days in the past including today (positive integer). _Not compatible with 'startDate' and 'endDate'_

        email : typing.Optional[str]
            Filter the report for a specific email addresses

        event : typing.Optional[GetEmailEventReportRequestEvent]
            Filter the report for a specific event type

        tags : typing.Optional[str]
            Filter the report for tags (serialized and urlencoded array)

        message_id : typing.Optional[str]
            Filter on a specific message id

        template_id : typing.Optional[int]
            Filter on a specific template id

        sort : typing.Optional[GetEmailEventReportRequestSort]
            Sort the results in the ascending/descending order of record creation. Default order is **descending** if `sort` is not passed

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GetEmailEventReportResponse
            Email events report informations

        Examples
        --------
        import asyncio

        from brevo import AsyncBrevo

        client = AsyncBrevo(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.transactional_emails.get_email_event_report()


        asyncio.run(main())
        """
        _response = await self._raw_client.get_email_event_report(
            limit=limit,
            offset=offset,
            start_date=start_date,
            end_date=end_date,
            days=days,
            email=email,
            event=event,
            tags=tags,
            message_id=message_id,
            template_id=template_id,
            sort=sort,
            request_options=request_options,
        )
        return _response.data

    async def get_smtp_report(
        self,
        *,
        limit: typing.Optional[int] = None,
        offset: typing.Optional[int] = None,
        start_date: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        days: typing.Optional[int] = None,
        tag: typing.Optional[str] = None,
        sort: typing.Optional[GetSmtpReportRequestSort] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GetSmtpReportResponse:
        """
        Parameters
        ----------
        limit : typing.Optional[int]
            Number of documents returned per page

        offset : typing.Optional[int]
            Index of the first document on the page

        start_date : typing.Optional[str]
            **Mandatory if endDate is used.** Starting date of the report (YYYY-MM-DD)

        end_date : typing.Optional[str]
            **Mandatory if startDate is used.** Ending date of the report (YYYY-MM-DD)

        days : typing.Optional[int]
            Number of days in the past including today (positive integer). _Not compatible with 'startDate' and 'endDate'_

        tag : typing.Optional[str]
            Tag of the emails

        sort : typing.Optional[GetSmtpReportRequestSort]
            Sort the results in the ascending/descending order of record creation. Default order is **descending** if `sort` is not passed

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GetSmtpReportResponse
            Aggregated report informations

        Examples
        --------
        import asyncio

        from brevo import AsyncBrevo

        client = AsyncBrevo(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.transactional_emails.get_smtp_report()


        asyncio.run(main())
        """
        _response = await self._raw_client.get_smtp_report(
            limit=limit,
            offset=offset,
            start_date=start_date,
            end_date=end_date,
            days=days,
            tag=tag,
            sort=sort,
            request_options=request_options,
        )
        return _response.data

    async def post_preview_smtp_email_templates(
        self, *, request: typing.Any, request_options: typing.Optional[RequestOptions] = None
    ) -> PostPreviewSmtpEmailTemplatesResponse:
        """
        Parameters
        ----------
        request : typing.Any

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        PostPreviewSmtpEmailTemplatesResponse
            successfully fetched template's preview fields

        Examples
        --------
        import asyncio

        from brevo import AsyncBrevo

        client = AsyncBrevo(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.transactional_emails.post_preview_smtp_email_templates(
                request={"key": "value"},
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.post_preview_smtp_email_templates(
            request=request, request_options=request_options
        )
        return _response.data

    async def get_smtp_templates(
        self,
        *,
        template_status: typing.Optional[bool] = None,
        limit: typing.Optional[int] = None,
        offset: typing.Optional[int] = None,
        sort: typing.Optional[GetSmtpTemplatesRequestSort] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GetSmtpTemplatesResponse:
        """
        Parameters
        ----------
        template_status : typing.Optional[bool]
            Filter on the status of the template. Active = true, inactive = false

        limit : typing.Optional[int]
            Number of documents returned per page

        offset : typing.Optional[int]
            Index of the first document in the page

        sort : typing.Optional[GetSmtpTemplatesRequestSort]
            Sort the results in the ascending/descending order of record creation. Default order is **descending** if `sort` is not passed

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GetSmtpTemplatesResponse
            transactional email templates informations

        Examples
        --------
        import asyncio

        from brevo import AsyncBrevo

        client = AsyncBrevo(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.transactional_emails.get_smtp_templates()


        asyncio.run(main())
        """
        _response = await self._raw_client.get_smtp_templates(
            template_status=template_status, limit=limit, offset=offset, sort=sort, request_options=request_options
        )
        return _response.data

    async def create_smtp_template(
        self,
        *,
        sender: CreateSmtpTemplateRequestSender,
        subject: str,
        template_name: str,
        attachment_url: typing.Optional[str] = OMIT,
        html_content: typing.Optional[str] = OMIT,
        html_url: typing.Optional[str] = OMIT,
        is_active: typing.Optional[bool] = OMIT,
        reply_to: typing.Optional[str] = OMIT,
        tag: typing.Optional[str] = OMIT,
        to_field: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CreateSmtpTemplateResponse:
        """
        Parameters
        ----------
        sender : CreateSmtpTemplateRequestSender
            Sender details including id or email and name (_optional_). Only one of either Sender's email or Sender's ID shall be passed in one request at a time. For example: **{"name":"xyz", "email":"example@abc.com"}** **{"name":"xyz", "id":123}**

        subject : str
            Subject of the template

        template_name : str
            Name of the template

        attachment_url : typing.Optional[str]
            Absolute url of the attachment (**no local file**). Extension allowed: #### xlsx, xls, ods, docx, docm, doc, csv, pdf, txt, gif, jpg, jpeg, png, tif, tiff, rtf, bmp, cgm, css, shtml, html, htm, zip, xml, ppt, pptx, tar, ez, ics, mobi, msg, pub and eps'

        html_content : typing.Optional[str]
            Body of the message (HTML version). The field must have more than 10 characters. **REQUIRED if htmlUrl is empty**

        html_url : typing.Optional[str]
            Url which contents the body of the email message. REQUIRED if htmlContent is empty

        is_active : typing.Optional[bool]
            Status of template. isActive = true means template is active and isActive = false means template is inactive

        reply_to : typing.Optional[str]
            Email on which campaign recipients will be able to reply to

        tag : typing.Optional[str]
            Tag of the template

        to_field : typing.Optional[str]
            To personalize the **To** Field. If you want to include the first name and last name of your recipient, add **{FNAME} {LNAME}**. These contact attributes must already exist in your Brevo account. If input parameter **params** used please use **{{contact.FNAME}} {{contact.LNAME}}** for personalization

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CreateSmtpTemplateResponse
            successfully created

        Examples
        --------
        import asyncio

        from brevo import AsyncBrevo
        from brevo.transactional_emails import CreateSmtpTemplateRequestSender

        client = AsyncBrevo(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.transactional_emails.create_smtp_template(
                sender=CreateSmtpTemplateRequestSender(),
                subject="Thanks for your purchase !",
                template_name="Order Confirmation - EN",
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.create_smtp_template(
            sender=sender,
            subject=subject,
            template_name=template_name,
            attachment_url=attachment_url,
            html_content=html_content,
            html_url=html_url,
            is_active=is_active,
            reply_to=reply_to,
            tag=tag,
            to_field=to_field,
            request_options=request_options,
        )
        return _response.data

    async def get_smtp_template(
        self, template_id: int, *, request_options: typing.Optional[RequestOptions] = None
    ) -> GetSmtpTemplateOverview:
        """
        Parameters
        ----------
        template_id : int
            id of the template

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GetSmtpTemplateOverview
            Email template informations

        Examples
        --------
        import asyncio

        from brevo import AsyncBrevo

        client = AsyncBrevo(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.transactional_emails.get_smtp_template(
                template_id=1000000,
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.get_smtp_template(template_id, request_options=request_options)
        return _response.data

    async def update_smtp_template(
        self,
        template_id: int,
        *,
        attachment_url: typing.Optional[str] = OMIT,
        html_content: typing.Optional[str] = OMIT,
        html_url: typing.Optional[str] = OMIT,
        is_active: typing.Optional[bool] = OMIT,
        reply_to: typing.Optional[str] = OMIT,
        sender: typing.Optional[UpdateSmtpTemplateRequestSender] = OMIT,
        subject: typing.Optional[str] = OMIT,
        tag: typing.Optional[str] = OMIT,
        template_name: typing.Optional[str] = OMIT,
        to_field: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        template_id : int
            id of the template

        attachment_url : typing.Optional[str]
            Absolute url of the attachment (**no local file**). Extensions allowed: #### xlsx, xls, ods, docx, docm, doc, csv, pdf, txt, gif, jpg, jpeg, png, tif, tiff, rtf, bmp, cgm, css, shtml, html, htm, zip, xml, ppt, pptx, tar, ez, ics, mobi, msg, pub and eps

        html_content : typing.Optional[str]
            **Required if htmlUrl is empty**. If the template is designed using Drag & Drop editor via HTML content, then the design page will not have Drag & Drop editor access for that template. Body of the message (HTML must have more than 10 characters)

        html_url : typing.Optional[str]
            **Required if htmlContent is empty**. URL to the body of the email (HTML)

        is_active : typing.Optional[bool]
            Status of the template. isActive = false means template is inactive, isActive = true means template is active

        reply_to : typing.Optional[str]
            Email on which campaign recipients will be able to reply to

        sender : typing.Optional[UpdateSmtpTemplateRequestSender]
            Sender details including id or email and name (_optional_). Only one of either Sender's email or Sender's ID shall be passed in one request at a time. For example: **{"name":"xyz", "email":"example@abc.com"}** **{"name":"xyz", "id":123}**

        subject : typing.Optional[str]
            Subject of the email

        tag : typing.Optional[str]
            Tag of the template

        template_name : typing.Optional[str]
            Name of the template

        to_field : typing.Optional[str]
            To personalize the **To** Field. If you want to include the first name and last name of your recipient, add **{FNAME} {LNAME}**. These contact attributes must already exist in your Brevo account. If input parameter **params** used please use **{{contact.FNAME}} {{contact.LNAME}}** for personalization

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from brevo import AsyncBrevo

        client = AsyncBrevo(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.transactional_emails.update_smtp_template(
                template_id=1000000,
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.update_smtp_template(
            template_id,
            attachment_url=attachment_url,
            html_content=html_content,
            html_url=html_url,
            is_active=is_active,
            reply_to=reply_to,
            sender=sender,
            subject=subject,
            tag=tag,
            template_name=template_name,
            to_field=to_field,
            request_options=request_options,
        )
        return _response.data

    async def delete_smtp_template(
        self, template_id: int, *, request_options: typing.Optional[RequestOptions] = None
    ) -> None:
        """
        Parameters
        ----------
        template_id : int
            id of the template

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from brevo import AsyncBrevo

        client = AsyncBrevo(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.transactional_emails.delete_smtp_template(
                template_id=1000000,
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.delete_smtp_template(template_id, request_options=request_options)
        return _response.data

    async def send_test_template(
        self,
        template_id: int,
        *,
        email_to: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        template_id : int
            Id of the template

        email_to : typing.Optional[typing.Sequence[str]]
            List of the email addresses of the recipients whom you wish to send the test mail. _If left empty, the test mail will be sent to your entire test list. You can not send more than 50 test emails per day_.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from brevo import AsyncBrevo

        client = AsyncBrevo(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.transactional_emails.send_test_template(
                template_id=1000000,
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.send_test_template(
            template_id, email_to=email_to, request_options=request_options
        )
        return _response.data
