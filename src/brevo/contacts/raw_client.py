# This file was auto-generated by Fern from our API Definition.

import typing
from json.decoder import JSONDecodeError

from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.http_response import AsyncHttpResponse, HttpResponse
from ..core.jsonable_encoder import jsonable_encoder
from ..core.request_options import RequestOptions
from ..core.serialization import convert_and_respect_annotation_metadata
from ..core.unchecked_base_model import construct_type
from ..errors.bad_request_error import BadRequestError
from ..errors.method_not_allowed_error import MethodNotAllowedError
from ..errors.not_found_error import NotFoundError
from ..errors.too_early_error import TooEarlyError
from ..errors.too_many_requests_error import TooManyRequestsError
from ..types.contact_error_model import ContactErrorModel
from ..types.error_model import ErrorModel
from ..types.get_contacts import GetContacts
from ..types.get_folder import GetFolder
from ..types.post_contact_info import PostContactInfo
from .types.add_contact_to_list_request_body import AddContactToListRequestBody
from .types.create_attribute_request_attribute_category import CreateAttributeRequestAttributeCategory
from .types.create_attribute_request_enumeration_item import CreateAttributeRequestEnumerationItem
from .types.create_attribute_request_type import CreateAttributeRequestType
from .types.create_contact_request_attributes_value import CreateContactRequestAttributesValue
from .types.create_contact_response import CreateContactResponse
from .types.create_doi_contact_request_attributes_value import CreateDoiContactRequestAttributesValue
from .types.create_folder_response import CreateFolderResponse
from .types.create_list_response import CreateListResponse
from .types.delete_attribute_request_attribute_category import DeleteAttributeRequestAttributeCategory
from .types.delete_contact_request_identifier import DeleteContactRequestIdentifier
from .types.delete_contact_request_identifier_type import DeleteContactRequestIdentifierType
from .types.get_attributes_response import GetAttributesResponse
from .types.get_contact_info_request_identifier import GetContactInfoRequestIdentifier
from .types.get_contact_info_request_identifier_type import GetContactInfoRequestIdentifierType
from .types.get_contact_info_response import GetContactInfoResponse
from .types.get_contact_stats_request_identifier import GetContactStatsRequestIdentifier
from .types.get_contact_stats_response import GetContactStatsResponse
from .types.get_contacts_from_list_request_sort import GetContactsFromListRequestSort
from .types.get_contacts_request_sort import GetContactsRequestSort
from .types.get_folder_lists_request_sort import GetFolderListsRequestSort
from .types.get_folder_lists_response import GetFolderListsResponse
from .types.get_folders_request_sort import GetFoldersRequestSort
from .types.get_folders_response import GetFoldersResponse
from .types.get_list_response import GetListResponse
from .types.get_lists_request_sort import GetListsRequestSort
from .types.get_lists_response import GetListsResponse
from .types.get_segments_request_sort import GetSegmentsRequestSort
from .types.get_segments_response import GetSegmentsResponse
from .types.import_contacts_request_json_body_item import ImportContactsRequestJsonBodyItem
from .types.import_contacts_request_new_list import ImportContactsRequestNewList
from .types.import_contacts_response import ImportContactsResponse
from .types.remove_contact_from_list_request_body import RemoveContactFromListRequestBody
from .types.request_contact_export_request_custom_contact_filter import RequestContactExportRequestCustomContactFilter
from .types.request_contact_export_response import RequestContactExportResponse
from .types.update_attribute_request_attribute_category import UpdateAttributeRequestAttributeCategory
from .types.update_attribute_request_enumeration_item import UpdateAttributeRequestEnumerationItem
from .types.update_batch_contacts_request_contacts_item import UpdateBatchContactsRequestContactsItem
from .types.update_contact_request_attributes_value import UpdateContactRequestAttributesValue
from .types.update_contact_request_identifier import UpdateContactRequestIdentifier
from .types.update_contact_request_identifier_type import UpdateContactRequestIdentifierType

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawContactsClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def get_contacts(
        self,
        *,
        limit: typing.Optional[int] = None,
        offset: typing.Optional[int] = None,
        modified_since: typing.Optional[str] = None,
        created_since: typing.Optional[str] = None,
        sort: typing.Optional[GetContactsRequestSort] = None,
        segment_id: typing.Optional[int] = None,
        list_ids: typing.Optional[typing.Union[int, typing.Sequence[int]]] = None,
        filter: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[GetContacts]:
        """
        <Note title="Follow this format when passing a SMS phone number as an attribute">
        Accepted Number Formats

        91xxxxxxxxxx
        +91xxxxxxxxxx
        0091xxxxxxxxxx
        </Note>

        Parameters
        ----------
        limit : typing.Optional[int]
            Number of documents per page

        offset : typing.Optional[int]
            Index of the first document of the page

        modified_since : typing.Optional[str]
            Filter (urlencoded) the contacts modified after a given UTC date-time (YYYY-MM-DDTHH:mm:ss.SSSZ). **Prefer to pass your timezone in date-time format for accurate result.**

        created_since : typing.Optional[str]
            Filter (urlencoded) the contacts created after a given UTC date-time (YYYY-MM-DDTHH:mm:ss.SSSZ). **Prefer to pass your timezone in date-time format for accurate result.**

        sort : typing.Optional[GetContactsRequestSort]
            Sort the results in the ascending/descending order of record creation. Default order is **descending** if `sort` is not passed

        segment_id : typing.Optional[int]
            Id of the segment. **Either listIds or segmentId can be passed.**

        list_ids : typing.Optional[typing.Union[int, typing.Sequence[int]]]
            Ids of the list. **Either listIds or segmentId can be passed.**

        filter : typing.Optional[str]
            Filter the contacts on the basis of attributes. **Allowed operator: equals. For multiple-choice options, the filter will apply an AND condition between the options. For category attributes, the filter will work with both id and value. (e.g. filter=equals(FIRSTNAME,"Antoine"), filter=equals(B1, true), filter=equals(DOB, "1989-11-23"), filter=equals(GENDER, "1"), filter=equals(GENDER, "MALE"), filter=equals(COUNTRY,"USA, INDIA")**

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetContacts]
            All contacts listed
        """
        _response = self._client_wrapper.httpx_client.request(
            "contacts",
            method="GET",
            params={
                "limit": limit,
                "offset": offset,
                "modifiedSince": modified_since,
                "createdSince": created_since,
                "sort": sort,
                "segmentId": segment_id,
                "listIds": list_ids,
                "filter": filter,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetContacts,
                    construct_type(
                        type_=GetContacts,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorModel,
                        construct_type(
                            type_=ErrorModel,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def create_contact(
        self,
        *,
        attributes: typing.Optional[typing.Dict[str, CreateContactRequestAttributesValue]] = OMIT,
        email: typing.Optional[str] = OMIT,
        email_blacklisted: typing.Optional[bool] = OMIT,
        ext_id: typing.Optional[str] = OMIT,
        list_ids: typing.Optional[typing.Sequence[int]] = OMIT,
        sms_blacklisted: typing.Optional[bool] = OMIT,
        smtp_blacklist_sender: typing.Optional[typing.Sequence[str]] = OMIT,
        update_enabled: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[CreateContactResponse]:
        """
        Creates new contacts on Brevo. Contacts can be created by passing either - <br><br> 1. email address of the contact (email_id),  <br> 2. phone number of the contact (to be passed as "SMS" field in "attributes" along with proper country code), For example- {"SMS":"+91xxxxxxxxxx"} or {"SMS":"0091xxxxxxxxxx"} <br> 3. ext_id <br>

        Parameters
        ----------
        attributes : typing.Optional[typing.Dict[str, CreateContactRequestAttributesValue]]
            Pass the set of attributes and their values. The attribute's parameter should be passed in capital letter while creating a contact. Values that don't match the attribute type (e.g. text or string in a date attribute) will be ignored. **These attributes must be present in your Brevo account**. For eg: **{"FNAME":"Elly", "LNAME":"Roger", "COUNTRIES": ["India","China"]}**

        email : typing.Optional[str]
            Email address of the user. **Mandatory if "ext_id"  & "SMS" field is not passed.**

        email_blacklisted : typing.Optional[bool]
            Set this field to blacklist the contact for emails (emailBlacklisted = true)

        ext_id : typing.Optional[str]
            Pass your own Id to create a contact.

        list_ids : typing.Optional[typing.Sequence[int]]
            Ids of the lists to add the contact to

        sms_blacklisted : typing.Optional[bool]
            Set this field to blacklist the contact for SMS (smsBlacklisted = true)

        smtp_blacklist_sender : typing.Optional[typing.Sequence[str]]
            transactional email forbidden sender for contact. Use only for email Contact ( only available if updateEnabled = true )

        update_enabled : typing.Optional[bool]
            Facilitate to update the existing contact in the same request (updateEnabled = true)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[CreateContactResponse]
            Contact created
        """
        _response = self._client_wrapper.httpx_client.request(
            "contacts",
            method="POST",
            json={
                "attributes": convert_and_respect_annotation_metadata(
                    object_=attributes,
                    annotation=typing.Dict[str, CreateContactRequestAttributesValue],
                    direction="write",
                ),
                "email": email,
                "emailBlacklisted": email_blacklisted,
                "ext_id": ext_id,
                "listIds": list_ids,
                "smsBlacklisted": sms_blacklisted,
                "smtpBlacklistSender": smtp_blacklist_sender,
                "updateEnabled": update_enabled,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CreateContactResponse,
                    construct_type(
                        type_=CreateContactResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 425:
                raise TooEarlyError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ContactErrorModel,
                        construct_type(
                            type_=ContactErrorModel,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_attributes(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[GetAttributesResponse]:
        """
        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetAttributesResponse]
            Attributes listed
        """
        _response = self._client_wrapper.httpx_client.request(
            "contacts/attributes",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetAttributesResponse,
                    construct_type(
                        type_=GetAttributesResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def create_attribute(
        self,
        attribute_category: CreateAttributeRequestAttributeCategory,
        attribute_name: str,
        *,
        enumeration: typing.Optional[typing.Sequence[CreateAttributeRequestEnumerationItem]] = OMIT,
        is_recurring: typing.Optional[bool] = OMIT,
        multi_category_options: typing.Optional[typing.Sequence[str]] = OMIT,
        type: typing.Optional[CreateAttributeRequestType] = OMIT,
        value: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        attribute_category : CreateAttributeRequestAttributeCategory
            Category of the attribute

        attribute_name : str
            Name of the attribute

        enumeration : typing.Optional[typing.Sequence[CreateAttributeRequestEnumerationItem]]
            List of values and labels that the attribute can take. **Use only if the attribute's category is "category"**. None of the category options can exceed max 200 characters. For example: **[{"value":1, "label":"male"}, {"value":2, "label":"female"}]**

        is_recurring : typing.Optional[bool]
            Type of the attribute. **Use only if the attribute's category is 'calculated' or 'global'**

        multi_category_options : typing.Optional[typing.Sequence[str]]
            List of options you want to add for multiple-choice attribute. **Use only if the attribute's category is "normal" and attribute's type is "multiple-choice". None of the multicategory options can exceed max 200 characters.** For example: **["USA","INDIA"]**

        type : typing.Optional[CreateAttributeRequestType]
            Type of the attribute. **Use only if the attribute's category is 'normal', 'category' or 'transactional'** Type **user and multiple-choice** is only available if the category is **normal** attribute Type **id** is only available if the category is **transactional** attribute Type **category** is only available if the category is **category** attribute

        value : typing.Optional[str]
            Value of the attribute. **Use only if the attribute's category is 'calculated' or 'global'**

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"contacts/attributes/{jsonable_encoder(attribute_category)}/{jsonable_encoder(attribute_name)}",
            method="POST",
            json={
                "enumeration": convert_and_respect_annotation_metadata(
                    object_=enumeration,
                    annotation=typing.Sequence[CreateAttributeRequestEnumerationItem],
                    direction="write",
                ),
                "isRecurring": is_recurring,
                "multiCategoryOptions": multi_category_options,
                "type": type,
                "value": value,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def update_attribute(
        self,
        attribute_category: UpdateAttributeRequestAttributeCategory,
        attribute_name: str,
        *,
        enumeration: typing.Optional[typing.Sequence[UpdateAttributeRequestEnumerationItem]] = OMIT,
        multi_category_options: typing.Optional[typing.Sequence[str]] = OMIT,
        value: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        attribute_category : UpdateAttributeRequestAttributeCategory
            Category of the attribute

        attribute_name : str
            Name of the existing attribute

        enumeration : typing.Optional[typing.Sequence[UpdateAttributeRequestEnumerationItem]]
            List of the values and labels that the attribute can take. **Use only if the attribute's category is "category"** None of the category options can exceed max 200 characters. For example, **[{"value":1, "label":"male"}, {"value":2, "label":"female"}]**

        multi_category_options : typing.Optional[typing.Sequence[str]]
            Use this option to add multiple-choice attributes options only if the attribute's category is "normal". **This option is specifically designed for updating multiple-choice attributes. None of the multicategory options can exceed max 200 characters.**. For example: **["USA","INDIA"]**

        value : typing.Optional[str]
            Value of the attribute to update. **Use only if the attribute's category is 'calculated' or 'global'**

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"contacts/attributes/{jsonable_encoder(attribute_category)}/{jsonable_encoder(attribute_name)}",
            method="PUT",
            json={
                "enumeration": convert_and_respect_annotation_metadata(
                    object_=enumeration,
                    annotation=typing.Sequence[UpdateAttributeRequestEnumerationItem],
                    direction="write",
                ),
                "multiCategoryOptions": multi_category_options,
                "value": value,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def delete_attribute(
        self,
        attribute_category: DeleteAttributeRequestAttributeCategory,
        attribute_name: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        attribute_category : DeleteAttributeRequestAttributeCategory
            Category of the attribute

        attribute_name : str
            Name of the existing attribute

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"contacts/attributes/{jsonable_encoder(attribute_category)}/{jsonable_encoder(attribute_name)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def delete_multi_attribute_options(
        self,
        multiple_choice_attribute: str,
        multiple_choice_attribute_option: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        multiple_choice_attribute : str
            Name of the existing multiple-choice attribute

        multiple_choice_attribute_option : str
            Name of the existing multiple-choice attribute option that you want to delete

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"contacts/attributes/multiple-choice/{jsonable_encoder(multiple_choice_attribute)}/{jsonable_encoder(multiple_choice_attribute_option)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def update_batch_contacts(
        self,
        *,
        contacts: typing.Optional[typing.Sequence[UpdateBatchContactsRequestContactsItem]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        contacts : typing.Optional[typing.Sequence[UpdateBatchContactsRequestContactsItem]]
            List of contacts to be updated

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            "contacts/batch",
            method="POST",
            json={
                "contacts": convert_and_respect_annotation_metadata(
                    object_=contacts,
                    annotation=typing.Sequence[UpdateBatchContactsRequestContactsItem],
                    direction="write",
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def create_doi_contact(
        self,
        *,
        email: str,
        include_list_ids: typing.Sequence[int],
        redirection_url: str,
        template_id: int,
        attributes: typing.Optional[typing.Dict[str, CreateDoiContactRequestAttributesValue]] = OMIT,
        exclude_list_ids: typing.Optional[typing.Sequence[int]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        <Note title="How to use attributes param?">
        attributes param in this endpoint is an object containing key-value pairs where values can be either a string, integer, array, or boolean. You can create key-value pairs with these four datatypes. When a value is an array, it should be an array of strings.
        </Note>

        Parameters
        ----------
        email : str
            Email address where the confirmation email will be sent. This email address will be the identifier for all other contact attributes.

        include_list_ids : typing.Sequence[int]
            Lists under user account where contact should be added

        redirection_url : str
            URL of the web page that user will be redirected to after clicking on the double opt in URL. When editing your DOI template you can reference this URL by using the tag **{{ params.DOIurl }}**.

        template_id : int
            Id of the Double opt-in (DOI) template

        attributes : typing.Optional[typing.Dict[str, CreateDoiContactRequestAttributesValue]]
            Pass the set of attributes and their values. **These attributes must be present in your Brevo account**. For eg. **{'FNAME':'Elly', 'LNAME':'Roger', 'COUNTRIES': ['India','China']}**

        exclude_list_ids : typing.Optional[typing.Sequence[int]]
            Lists under user account where contact should not be added

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            "contacts/doubleOptinConfirmation",
            method="POST",
            json={
                "attributes": convert_and_respect_annotation_metadata(
                    object_=attributes,
                    annotation=typing.Dict[str, CreateDoiContactRequestAttributesValue],
                    direction="write",
                ),
                "email": email,
                "excludeListIds": exclude_list_ids,
                "includeListIds": include_list_ids,
                "redirectionUrl": redirection_url,
                "templateId": template_id,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def request_contact_export(
        self,
        *,
        custom_contact_filter: RequestContactExportRequestCustomContactFilter,
        disable_notification: typing.Optional[bool] = OMIT,
        export_attributes: typing.Optional[typing.Sequence[str]] = OMIT,
        export_mandatory_attributes: typing.Optional[bool] = OMIT,
        export_metadata: typing.Optional[typing.Sequence[str]] = OMIT,
        export_date_in_utc: typing.Optional[bool] = OMIT,
        export_subscription_status: typing.Optional[typing.Sequence[str]] = OMIT,
        notify_url: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[RequestContactExportResponse]:
        """
        It returns the background process ID which on completion calls the notify URL that you have set in the input. File will be available in csv.

        Parameters
        ----------
        custom_contact_filter : RequestContactExportRequestCustomContactFilter
            Set the filter for the contacts to be exported.

        disable_notification : typing.Optional[bool]
            To avoid generating the email notification upon contact export, pass **true**

        export_attributes : typing.Optional[typing.Sequence[str]]
            List of all the attributes that you want to export. **These attributes must be present in your contact database. It is required if exportMandatoryAttributes is set false. ** For example: **['fname', 'lname', 'email']**

        export_mandatory_attributes : typing.Optional[bool]
            To export mandatory attributes like EMAIL, ADDED_TIME, MODIFIED_TIME

        export_metadata : typing.Optional[typing.Sequence[str]]
            Export metadata of contacts such as _listIds, ADDED_TIME, MODIFIED_TIME.

        export_date_in_utc : typing.Optional[bool]
            Specifies whether the date fields createdAt, modifiedAt in the exported data should be returned in UTC format.

        export_subscription_status : typing.Optional[typing.Sequence[str]]
            Export subscription status of contacts for email & sms marketting. Pass email_marketing to obtain the marketing email subscription status & sms_marketing to retrieve the marketing SMS status of the contact.

        notify_url : typing.Optional[str]
            Webhook that will be called once the export process is finished. For reference, https://help.brevo.com/hc/en-us/articles/360007666479

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[RequestContactExportResponse]
            process id created
        """
        _response = self._client_wrapper.httpx_client.request(
            "contacts/export",
            method="POST",
            json={
                "customContactFilter": convert_and_respect_annotation_metadata(
                    object_=custom_contact_filter,
                    annotation=RequestContactExportRequestCustomContactFilter,
                    direction="write",
                ),
                "disableNotification": disable_notification,
                "exportAttributes": export_attributes,
                "exportMandatoryAttributes": export_mandatory_attributes,
                "exportMetadata": export_metadata,
                "exportDateInUTC": export_date_in_utc,
                "exportSubscriptionStatus": export_subscription_status,
                "notifyUrl": notify_url,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    RequestContactExportResponse,
                    construct_type(
                        type_=RequestContactExportResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorModel,
                        construct_type(
                            type_=ErrorModel,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_folders(
        self,
        *,
        limit: typing.Optional[int] = None,
        offset: typing.Optional[int] = None,
        sort: typing.Optional[GetFoldersRequestSort] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[GetFoldersResponse]:
        """
        <Note>
        Ongoing changes for this endpoint

        We're dropping support for the response attributes totalSubscribers and totalBlacklisted.

        These are non breaking changes.

        The default value for the attributes will be 0.

        The uniqueSubscribers field is deprecated
        </Note>

        Parameters
        ----------
        limit : typing.Optional[int]
            Number of documents per page

        offset : typing.Optional[int]
            Index of the first document of the page

        sort : typing.Optional[GetFoldersRequestSort]
            Sort the results in the ascending/descending order of record creation. Default order is **descending** if `sort` is not passed

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetFoldersResponse]
            Folders informations
        """
        _response = self._client_wrapper.httpx_client.request(
            "contacts/folders",
            method="GET",
            params={
                "limit": limit,
                "offset": offset,
                "sort": sort,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetFoldersResponse,
                    construct_type(
                        type_=GetFoldersResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def create_folder(
        self, *, name: typing.Optional[str] = OMIT, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[CreateFolderResponse]:
        """
        Parameters
        ----------
        name : typing.Optional[str]
            Name of the folder

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[CreateFolderResponse]
            successfully created
        """
        _response = self._client_wrapper.httpx_client.request(
            "contacts/folders",
            method="POST",
            json={
                "name": name,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CreateFolderResponse,
                    construct_type(
                        type_=CreateFolderResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_folder(
        self, folder_id: int, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[GetFolder]:
        """
        <Note>
        Ongoing changes for this endpoint.

        We're dropping support for the response attributes totalSubscribers and totalBlacklisted.

        These are non breaking changes. The default value for the attributes will be 0.
        </Note>

        Parameters
        ----------
        folder_id : int
            id of the folder

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetFolder]
            Folder details
        """
        _response = self._client_wrapper.httpx_client.request(
            f"contacts/folders/{jsonable_encoder(folder_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetFolder,
                    construct_type(
                        type_=GetFolder,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def update_folder(
        self,
        folder_id: int,
        *,
        name: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        folder_id : int
            Id of the folder

        name : typing.Optional[str]
            Name of the folder

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"contacts/folders/{jsonable_encoder(folder_id)}",
            method="PUT",
            json={
                "name": name,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def delete_folder(
        self, folder_id: int, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        folder_id : int
            Id of the folder

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"contacts/folders/{jsonable_encoder(folder_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_folder_lists(
        self,
        folder_id: int,
        *,
        limit: typing.Optional[int] = None,
        offset: typing.Optional[int] = None,
        sort: typing.Optional[GetFolderListsRequestSort] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[GetFolderListsResponse]:
        """
        <Note>
        Ongoing changes for this endpoint.

        We're dropping support for the response attributes totalSubscribers and totalBlacklisted.

        These are non breaking changes. The default value for the attributes will be 0.
        </Note>

        Parameters
        ----------
        folder_id : int
            Id of the folder

        limit : typing.Optional[int]
            Number of documents per page

        offset : typing.Optional[int]
            Index of the first document of the page

        sort : typing.Optional[GetFolderListsRequestSort]
            Sort the results in the ascending/descending order of record creation. Default order is **descending** if `sort` is not passed

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetFolderListsResponse]
            Folder's Lists details
        """
        _response = self._client_wrapper.httpx_client.request(
            f"contacts/folders/{jsonable_encoder(folder_id)}/lists",
            method="GET",
            params={
                "limit": limit,
                "offset": offset,
                "sort": sort,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetFolderListsResponse,
                    construct_type(
                        type_=GetFolderListsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def import_contacts(
        self,
        *,
        disable_notification: typing.Optional[bool] = OMIT,
        email_blacklist: typing.Optional[bool] = OMIT,
        empty_contacts_attributes: typing.Optional[bool] = OMIT,
        file_body: typing.Optional[str] = OMIT,
        file_url: typing.Optional[str] = OMIT,
        json_body: typing.Optional[typing.Sequence[ImportContactsRequestJsonBodyItem]] = OMIT,
        list_ids: typing.Optional[typing.Sequence[int]] = OMIT,
        new_list: typing.Optional[ImportContactsRequestNewList] = OMIT,
        notify_url: typing.Optional[str] = OMIT,
        sms_blacklist: typing.Optional[bool] = OMIT,
        update_existing_contacts: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[ImportContactsResponse]:
        """
        It returns the background process ID which on completion calls the notify URL that you have set in the input. **Note**: - Any contact attribute that doesn't exist in your account will be ignored at import end.

        Parameters
        ----------
        disable_notification : typing.Optional[bool]
            To disable email notification

        email_blacklist : typing.Optional[bool]
            To blacklist all the contacts for email

        empty_contacts_attributes : typing.Optional[bool]
            To facilitate the choice to erase any attribute of the existing contacts with empty value. emptyContactsAttributes = true means the empty fields in your import will erase any attribute that currently contain data in Brevo, & emptyContactsAttributes = false means the empty fields will not affect your existing data ( **only available if `updateExistingContacts` set to true **)

        file_body : typing.Optional[str]
            **Mandatory if fileUrl and jsonBody is not defined.** CSV content to be imported. Use semicolon to separate multiple attributes. **Maximum allowed file body size is 10MB** . However we recommend a safe limit of around 8 MB to avoid the issues caused due to increase of file body size while parsing. Please use fileUrl instead to import bigger files.

        file_url : typing.Optional[str]
            **Mandatory if fileBody and jsonBody is not defined.** URL of the file to be imported (**no local file**). Possible file formats: #### .txt, .csv, .json

        json_body : typing.Optional[typing.Sequence[ImportContactsRequestJsonBodyItem]]
            **Mandatory if fileUrl and fileBody is not defined.** JSON content to be imported. **Maximum allowed json body size is 10MB** . However we recommend a safe limit of around 8 MB to avoid the issues caused due to increase of json body size while parsing. Please use fileUrl instead to import bigger files.

        list_ids : typing.Optional[typing.Sequence[int]]
            **Mandatory if newList is not defined.** Ids of the lists in which the contacts shall be imported. For example, **[2, 4, 7]**.

        new_list : typing.Optional[ImportContactsRequestNewList]
            To create a new list and import the contacts into it, pass the listName and an optional folderId.

        notify_url : typing.Optional[str]
            URL that will be called once the import process is finished. For reference, https://help.brevo.com/hc/en-us/articles/360007666479

        sms_blacklist : typing.Optional[bool]
            To blacklist all the contacts for sms

        update_existing_contacts : typing.Optional[bool]
            To facilitate the choice to update the existing contacts

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ImportContactsResponse]
            process id created
        """
        _response = self._client_wrapper.httpx_client.request(
            "contacts/import",
            method="POST",
            json={
                "disableNotification": disable_notification,
                "emailBlacklist": email_blacklist,
                "emptyContactsAttributes": empty_contacts_attributes,
                "fileBody": file_body,
                "fileUrl": file_url,
                "jsonBody": convert_and_respect_annotation_metadata(
                    object_=json_body, annotation=typing.Sequence[ImportContactsRequestJsonBodyItem], direction="write"
                ),
                "listIds": list_ids,
                "newList": convert_and_respect_annotation_metadata(
                    object_=new_list, annotation=ImportContactsRequestNewList, direction="write"
                ),
                "notifyUrl": notify_url,
                "smsBlacklist": sms_blacklist,
                "updateExistingContacts": update_existing_contacts,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ImportContactsResponse,
                    construct_type(
                        type_=ImportContactsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_lists(
        self,
        *,
        limit: typing.Optional[int] = None,
        offset: typing.Optional[int] = None,
        sort: typing.Optional[GetListsRequestSort] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[GetListsResponse]:
        """
        <Note>
        Ongoing changes for this endpoint.

        We're dropping support for the response attributes totalSubscribers and totalBlacklisted.

        These are non breaking changes. The default value for the attributes will be 0.
        </Note>

        Parameters
        ----------
        limit : typing.Optional[int]
            Number of documents per page

        offset : typing.Optional[int]
            Index of the first document of the page

        sort : typing.Optional[GetListsRequestSort]
            Sort the results in the ascending/descending order of record creation. Default order is **descending** if `sort` is not passed

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetListsResponse]
            Lists informations
        """
        _response = self._client_wrapper.httpx_client.request(
            "contacts/lists",
            method="GET",
            params={
                "limit": limit,
                "offset": offset,
                "sort": sort,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetListsResponse,
                    construct_type(
                        type_=GetListsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def create_list(
        self, *, folder_id: int, name: str, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[CreateListResponse]:
        """
        Parameters
        ----------
        folder_id : int
            Id of the parent folder in which this list is to be created

        name : str
            Name of the list

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[CreateListResponse]
            successfully created
        """
        _response = self._client_wrapper.httpx_client.request(
            "contacts/lists",
            method="POST",
            json={
                "folderId": folder_id,
                "name": name,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CreateListResponse,
                    construct_type(
                        type_=CreateListResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_list(
        self,
        list_id: int,
        *,
        start_date: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[GetListResponse]:
        """
        Parameters
        ----------
        list_id : int
            Id of the list

        start_date : typing.Optional[str]
            **Mandatory if endDate is used**. Ending (urlencoded) UTC date-time (YYYY-MM-DDTHH:mm:ss.SSSZ) to aggregate the sent email campaigns for a specific list id. **Prefer to pass your timezone in date-time format for accurate result**

        end_date : typing.Optional[str]
            **Mandatory if startDate is used**. Ending (urlencoded) UTC date-time (YYYY-MM-DDTHH:mm:ss.SSSZ) to aggregate the sent email campaigns for a specific list id. **Prefer to pass your timezone in date-time format for accurate result**

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetListResponse]
            List informations
        """
        _response = self._client_wrapper.httpx_client.request(
            f"contacts/lists/{jsonable_encoder(list_id)}",
            method="GET",
            params={
                "startDate": start_date,
                "endDate": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetListResponse,
                    construct_type(
                        type_=GetListResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def update_list(
        self,
        list_id: int,
        *,
        folder_id: typing.Optional[int] = OMIT,
        name: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        list_id : int
            Id of the list

        folder_id : typing.Optional[int]
            Id of the folder in which the list is to be moved. Either of the two parameters (name, folderId) can be updated at a time.

        name : typing.Optional[str]
            Name of the list. Either of the two parameters (name, folderId) can be updated at a time.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"contacts/lists/{jsonable_encoder(list_id)}",
            method="PUT",
            json={
                "folderId": folder_id,
                "name": name,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def delete_list(
        self, list_id: int, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        list_id : int
            Id of the list

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"contacts/lists/{jsonable_encoder(list_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_contacts_from_list(
        self,
        list_id: int,
        *,
        modified_since: typing.Optional[str] = None,
        limit: typing.Optional[int] = None,
        offset: typing.Optional[int] = None,
        sort: typing.Optional[GetContactsFromListRequestSort] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[GetContacts]:
        """
        Parameters
        ----------
        list_id : int
            Id of the list

        modified_since : typing.Optional[str]
            Filter (urlencoded) the contacts modified after a given UTC date-time (YYYY-MM-DDTHH:mm:ss.SSSZ). **Prefer to pass your timezone in date-time format for accurate result.**

        limit : typing.Optional[int]
            Number of documents per page

        offset : typing.Optional[int]
            Index of the first document of the page

        sort : typing.Optional[GetContactsFromListRequestSort]
            Sort the results in the ascending/descending order of record creation. Default order is **descending** if `sort` is not passed

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetContacts]
            Contact informations
        """
        _response = self._client_wrapper.httpx_client.request(
            f"contacts/lists/{jsonable_encoder(list_id)}/contacts",
            method="GET",
            params={
                "modifiedSince": modified_since,
                "limit": limit,
                "offset": offset,
                "sort": sort,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetContacts,
                    construct_type(
                        type_=GetContacts,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def add_contact_to_list(
        self,
        list_id: int,
        *,
        request: AddContactToListRequestBody,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[PostContactInfo]:
        """
        Parameters
        ----------
        list_id : int
            Id of the list

        request : AddContactToListRequestBody

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[PostContactInfo]
            All contacts have been added successfully to the list with details of failed ones
        """
        _response = self._client_wrapper.httpx_client.request(
            f"contacts/lists/{jsonable_encoder(list_id)}/contacts/add",
            method="POST",
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=AddContactToListRequestBody, direction="write"
            ),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PostContactInfo,
                    construct_type(
                        type_=PostContactInfo,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def remove_contact_from_list(
        self,
        list_id: int,
        *,
        request: RemoveContactFromListRequestBody,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[PostContactInfo]:
        """
        Parameters
        ----------
        list_id : int
            Id of the list

        request : RemoveContactFromListRequestBody

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[PostContactInfo]
            All contacts have been removed successfully from the list with details of failed ones
        """
        _response = self._client_wrapper.httpx_client.request(
            f"contacts/lists/{jsonable_encoder(list_id)}/contacts/remove",
            method="POST",
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=RemoveContactFromListRequestBody, direction="write"
            ),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PostContactInfo,
                    construct_type(
                        type_=PostContactInfo,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_segments(
        self,
        *,
        limit: typing.Optional[int] = None,
        offset: typing.Optional[int] = None,
        sort: typing.Optional[GetSegmentsRequestSort] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[GetSegmentsResponse]:
        """
        Parameters
        ----------
        limit : typing.Optional[int]
            Number of documents per page

        offset : typing.Optional[int]
            Index of the first document of the page

        sort : typing.Optional[GetSegmentsRequestSort]
            Sort the results in the ascending/descending order of record creation. Default order is **descending** if `sort` is not passed

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetSegmentsResponse]
            Segments informations
        """
        _response = self._client_wrapper.httpx_client.request(
            "contacts/segments",
            method="GET",
            params={
                "limit": limit,
                "offset": offset,
                "sort": sort,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetSegmentsResponse,
                    construct_type(
                        type_=GetSegmentsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_contact_info(
        self,
        identifier: GetContactInfoRequestIdentifier,
        *,
        identifier_type: typing.Optional[GetContactInfoRequestIdentifierType] = None,
        start_date: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[GetContactInfoResponse]:
        """
        <Note title="Follow this format when passing a SMS phone number as an attribute">
        Accepted Number Formats

        91xxxxxxxxxx
        +91xxxxxxxxxx
        0091xxxxxxxxxx
        </Note>

        There are 2 ways to get a contact <br><br> Option 1- https://api.brevo.com/v3/contacts/{identifier} <br><br> Option 2- https://api.brevo.com/v3/contacts/{identifier}?identifierType={} <br> <br> Option 1 only works if identifierType is email_id (for EMAIL), phone_id (for SMS) or contact_id (for ID of the contact),where you can directly pass the value of EMAIL, SMS and ID of the contact.   <br><br> Option 2 works for all identifierType, use email_id for EMAIL attribute, phone_id for SMS attribute, contact_id for ID of the contact, ext_id for EXT_ID attribute, whatsapp_id for WHATSAPP attribute, landline_number_id for LANDLINE_NUMBER attribute <br><br>Along with the contact details, this endpoint will show the statistics of contact for the recent 90 days by default. To fetch the earlier statistics, please use Get contact campaign stats ``https://developers.brevo.com/reference/contacts-7#getcontactstats`` endpoint with the appropriate date ranges.

        Parameters
        ----------
        identifier : GetContactInfoRequestIdentifier
            Email (urlencoded) OR ID of the contact OR its SMS attribute value OR EXT_ID attribute (urlencoded)

        identifier_type : typing.Optional[GetContactInfoRequestIdentifierType]
            email_id for Email, phone_id for SMS attribute, contact_id for ID of the contact, ext_id for EXT_ID attribute, whatsapp_id for WHATSAPP attribute, landline_number_id for LANDLINE_NUMBER attribute

        start_date : typing.Optional[str]
            **Mandatory if endDate is used.** Starting date (YYYY-MM-DD) of the statistic events specific to campaigns. Must be lower than equal to endDate

        end_date : typing.Optional[str]
            **Mandatory if startDate is used.** Ending date (YYYY-MM-DD) of the statistic events specific to campaigns. Must be greater than equal to startDate.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetContactInfoResponse]
            Contact informations
        """
        _response = self._client_wrapper.httpx_client.request(
            f"contacts/{jsonable_encoder(identifier)}",
            method="GET",
            params={
                "identifierType": identifier_type,
                "startDate": start_date,
                "endDate": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetContactInfoResponse,
                    construct_type(
                        type_=GetContactInfoResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def update_contact(
        self,
        identifier: UpdateContactRequestIdentifier,
        *,
        identifier_type: typing.Optional[UpdateContactRequestIdentifierType] = None,
        attributes: typing.Optional[typing.Dict[str, UpdateContactRequestAttributesValue]] = OMIT,
        email_blacklisted: typing.Optional[bool] = OMIT,
        ext_id: typing.Optional[str] = OMIT,
        list_ids: typing.Optional[typing.Sequence[int]] = OMIT,
        sms_blacklisted: typing.Optional[bool] = OMIT,
        smtp_blacklist_sender: typing.Optional[typing.Sequence[str]] = OMIT,
        unlink_list_ids: typing.Optional[typing.Sequence[int]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        There are 2 ways to update a contact <br><br> Option 1- https://api.brevo.com/v3/contacts/{identifier} <br><br> Option 2- https://api.brevo.com/v3/contacts/{identifier}?identifierType={} <br> <br> Option 1 only works if identifierType is email_id (for EMAIL) or contact_id (for ID of the contact),where you can directly pass the value of EMAIL and ID of the contact.   <br><br> Option 2 works for all identifierType, use email_id for EMAIL attribute, contact_id for ID of the contact, ext_id for EXT_ID attribute, phone_id for SMS attribute, whatsapp_id for WHATSAPP attribute, landline_number_id for LANDLINE attribute

        Parameters
        ----------
        identifier : UpdateContactRequestIdentifier
            Email (urlencoded) OR ID of the contact OR EXT_ID attribute (urlencoded) OR its SMS attribute value OR its WHATSAPP attribute value OR its LANDLINE attribute value

        identifier_type : typing.Optional[UpdateContactRequestIdentifierType]
            email_id for Email, contact_id for ID of the contact, ext_id for EXT_ID attribute, phone_id for SMS attribute, whatsapp_id for WHATSAPP attribute, landline_number_id for LANDLINE attribute

        attributes : typing.Optional[typing.Dict[str, UpdateContactRequestAttributesValue]]
            Pass the set of attributes to be updated. **These attributes must be present in your account**. To update existing email address of a contact with the new one please pass EMAIL in attributes. For example, **{ "EMAIL":"newemail@domain.com", "FNAME":"Ellie", "LNAME":"Roger", "COUNTRIES":["India","China"]}**. The attribute's parameter should be passed in capital letter while updating a contact. Values that don't match the attribute type (e.g. text or string in a date attribute) will be ignored .Keep in mind transactional attributes can be updated the same way as normal attributes. Mobile Number in **SMS** field should be passed with proper country code. For example: **{"SMS":"+91xxxxxxxxxx"} or {"SMS":"0091xxxxxxxxxx"}**

        email_blacklisted : typing.Optional[bool]
            Set/unset this field to blacklist/allow the contact for emails (emailBlacklisted = true)

        ext_id : typing.Optional[str]
            Pass your own Id to update ext_id of a contact.

        list_ids : typing.Optional[typing.Sequence[int]]
            Ids of the lists to add the contact to

        sms_blacklisted : typing.Optional[bool]
            Set/unset this field to blacklist/allow the contact for SMS (smsBlacklisted = true)

        smtp_blacklist_sender : typing.Optional[typing.Sequence[str]]
            transactional email forbidden sender for contact. Use only for email Contact

        unlink_list_ids : typing.Optional[typing.Sequence[int]]
            Ids of the lists to remove the contact from

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"contacts/{jsonable_encoder(identifier)}",
            method="PUT",
            params={
                "identifierType": identifier_type,
            },
            json={
                "attributes": convert_and_respect_annotation_metadata(
                    object_=attributes,
                    annotation=typing.Dict[str, UpdateContactRequestAttributesValue],
                    direction="write",
                ),
                "emailBlacklisted": email_blacklisted,
                "ext_id": ext_id,
                "listIds": list_ids,
                "smsBlacklisted": sms_blacklisted,
                "smtpBlacklistSender": smtp_blacklist_sender,
                "unlinkListIds": unlink_list_ids,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 425:
                raise TooEarlyError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ContactErrorModel,
                        construct_type(
                            type_=ContactErrorModel,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def delete_contact(
        self,
        identifier: DeleteContactRequestIdentifier,
        *,
        identifier_type: typing.Optional[DeleteContactRequestIdentifierType] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        There are 2 ways to delete a contact <br><br> Option 1- https://api.brevo.com/v3/contacts/{identifier} <br><br> Option 2- https://api.brevo.com/v3/contacts/{identifier}?identifierType={} <br> <br> Option 1 only works if identifierType is email_id (for EMAIL) or contact_id (for ID of the contact),where you can directly pass the value of EMAIL and ID of the contact.   <br><br> Option 2 works for all identifierType, use email_id for EMAIL attribute, contact_id for ID of the contact, ext_id for EXT_ID attribute, phone_id for SMS attribute, whatsapp_id for WHATSAPP attribute, landline_number_id for LANDLINE_NUMBER attribute.

        Parameters
        ----------
        identifier : DeleteContactRequestIdentifier
            Email (urlencoded) OR ID of the contact OR EXT_ID attribute (urlencoded)

        identifier_type : typing.Optional[DeleteContactRequestIdentifierType]
            email_id for Email, contact_id for ID of the contact, ext_id for EXT_ID attribute, phone_id for SMS attribute, whatsapp_id for WHATSAPP attribute, landline_number_id for LANDLINE_NUMBER attribute

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"contacts/{jsonable_encoder(identifier)}",
            method="DELETE",
            params={
                "identifierType": identifier_type,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 405:
                raise MethodNotAllowedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorModel,
                        construct_type(
                            type_=ErrorModel,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_contact_stats(
        self,
        identifier: GetContactStatsRequestIdentifier,
        *,
        start_date: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[GetContactStatsResponse]:
        """
        Parameters
        ----------
        identifier : GetContactStatsRequestIdentifier
            Email (urlencoded) OR ID of the contact

        start_date : typing.Optional[str]
            **Mandatory if endDate is used.** Starting date (YYYY-MM-DD) of the statistic events specific to campaigns. Must be lower than equal to endDate

        end_date : typing.Optional[str]
            **Mandatory if startDate is used.** Ending date (YYYY-MM-DD) of the statistic events specific to campaigns. Must be greater than equal to startDate. Maximum difference between startDate and endDate should not be greater than 90 days

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetContactStatsResponse]
            Contact campaign statistics informations
        """
        _response = self._client_wrapper.httpx_client.request(
            f"contacts/{jsonable_encoder(identifier)}/campaignStats",
            method="GET",
            params={
                "startDate": start_date,
                "endDate": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetContactStatsResponse,
                    construct_type(
                        type_=GetContactStatsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawContactsClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def get_contacts(
        self,
        *,
        limit: typing.Optional[int] = None,
        offset: typing.Optional[int] = None,
        modified_since: typing.Optional[str] = None,
        created_since: typing.Optional[str] = None,
        sort: typing.Optional[GetContactsRequestSort] = None,
        segment_id: typing.Optional[int] = None,
        list_ids: typing.Optional[typing.Union[int, typing.Sequence[int]]] = None,
        filter: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[GetContacts]:
        """
        <Note title="Follow this format when passing a SMS phone number as an attribute">
        Accepted Number Formats

        91xxxxxxxxxx
        +91xxxxxxxxxx
        0091xxxxxxxxxx
        </Note>

        Parameters
        ----------
        limit : typing.Optional[int]
            Number of documents per page

        offset : typing.Optional[int]
            Index of the first document of the page

        modified_since : typing.Optional[str]
            Filter (urlencoded) the contacts modified after a given UTC date-time (YYYY-MM-DDTHH:mm:ss.SSSZ). **Prefer to pass your timezone in date-time format for accurate result.**

        created_since : typing.Optional[str]
            Filter (urlencoded) the contacts created after a given UTC date-time (YYYY-MM-DDTHH:mm:ss.SSSZ). **Prefer to pass your timezone in date-time format for accurate result.**

        sort : typing.Optional[GetContactsRequestSort]
            Sort the results in the ascending/descending order of record creation. Default order is **descending** if `sort` is not passed

        segment_id : typing.Optional[int]
            Id of the segment. **Either listIds or segmentId can be passed.**

        list_ids : typing.Optional[typing.Union[int, typing.Sequence[int]]]
            Ids of the list. **Either listIds or segmentId can be passed.**

        filter : typing.Optional[str]
            Filter the contacts on the basis of attributes. **Allowed operator: equals. For multiple-choice options, the filter will apply an AND condition between the options. For category attributes, the filter will work with both id and value. (e.g. filter=equals(FIRSTNAME,"Antoine"), filter=equals(B1, true), filter=equals(DOB, "1989-11-23"), filter=equals(GENDER, "1"), filter=equals(GENDER, "MALE"), filter=equals(COUNTRY,"USA, INDIA")**

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetContacts]
            All contacts listed
        """
        _response = await self._client_wrapper.httpx_client.request(
            "contacts",
            method="GET",
            params={
                "limit": limit,
                "offset": offset,
                "modifiedSince": modified_since,
                "createdSince": created_since,
                "sort": sort,
                "segmentId": segment_id,
                "listIds": list_ids,
                "filter": filter,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetContacts,
                    construct_type(
                        type_=GetContacts,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorModel,
                        construct_type(
                            type_=ErrorModel,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def create_contact(
        self,
        *,
        attributes: typing.Optional[typing.Dict[str, CreateContactRequestAttributesValue]] = OMIT,
        email: typing.Optional[str] = OMIT,
        email_blacklisted: typing.Optional[bool] = OMIT,
        ext_id: typing.Optional[str] = OMIT,
        list_ids: typing.Optional[typing.Sequence[int]] = OMIT,
        sms_blacklisted: typing.Optional[bool] = OMIT,
        smtp_blacklist_sender: typing.Optional[typing.Sequence[str]] = OMIT,
        update_enabled: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[CreateContactResponse]:
        """
        Creates new contacts on Brevo. Contacts can be created by passing either - <br><br> 1. email address of the contact (email_id),  <br> 2. phone number of the contact (to be passed as "SMS" field in "attributes" along with proper country code), For example- {"SMS":"+91xxxxxxxxxx"} or {"SMS":"0091xxxxxxxxxx"} <br> 3. ext_id <br>

        Parameters
        ----------
        attributes : typing.Optional[typing.Dict[str, CreateContactRequestAttributesValue]]
            Pass the set of attributes and their values. The attribute's parameter should be passed in capital letter while creating a contact. Values that don't match the attribute type (e.g. text or string in a date attribute) will be ignored. **These attributes must be present in your Brevo account**. For eg: **{"FNAME":"Elly", "LNAME":"Roger", "COUNTRIES": ["India","China"]}**

        email : typing.Optional[str]
            Email address of the user. **Mandatory if "ext_id"  & "SMS" field is not passed.**

        email_blacklisted : typing.Optional[bool]
            Set this field to blacklist the contact for emails (emailBlacklisted = true)

        ext_id : typing.Optional[str]
            Pass your own Id to create a contact.

        list_ids : typing.Optional[typing.Sequence[int]]
            Ids of the lists to add the contact to

        sms_blacklisted : typing.Optional[bool]
            Set this field to blacklist the contact for SMS (smsBlacklisted = true)

        smtp_blacklist_sender : typing.Optional[typing.Sequence[str]]
            transactional email forbidden sender for contact. Use only for email Contact ( only available if updateEnabled = true )

        update_enabled : typing.Optional[bool]
            Facilitate to update the existing contact in the same request (updateEnabled = true)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[CreateContactResponse]
            Contact created
        """
        _response = await self._client_wrapper.httpx_client.request(
            "contacts",
            method="POST",
            json={
                "attributes": convert_and_respect_annotation_metadata(
                    object_=attributes,
                    annotation=typing.Dict[str, CreateContactRequestAttributesValue],
                    direction="write",
                ),
                "email": email,
                "emailBlacklisted": email_blacklisted,
                "ext_id": ext_id,
                "listIds": list_ids,
                "smsBlacklisted": sms_blacklisted,
                "smtpBlacklistSender": smtp_blacklist_sender,
                "updateEnabled": update_enabled,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CreateContactResponse,
                    construct_type(
                        type_=CreateContactResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 425:
                raise TooEarlyError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ContactErrorModel,
                        construct_type(
                            type_=ContactErrorModel,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_attributes(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[GetAttributesResponse]:
        """
        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetAttributesResponse]
            Attributes listed
        """
        _response = await self._client_wrapper.httpx_client.request(
            "contacts/attributes",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetAttributesResponse,
                    construct_type(
                        type_=GetAttributesResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def create_attribute(
        self,
        attribute_category: CreateAttributeRequestAttributeCategory,
        attribute_name: str,
        *,
        enumeration: typing.Optional[typing.Sequence[CreateAttributeRequestEnumerationItem]] = OMIT,
        is_recurring: typing.Optional[bool] = OMIT,
        multi_category_options: typing.Optional[typing.Sequence[str]] = OMIT,
        type: typing.Optional[CreateAttributeRequestType] = OMIT,
        value: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        attribute_category : CreateAttributeRequestAttributeCategory
            Category of the attribute

        attribute_name : str
            Name of the attribute

        enumeration : typing.Optional[typing.Sequence[CreateAttributeRequestEnumerationItem]]
            List of values and labels that the attribute can take. **Use only if the attribute's category is "category"**. None of the category options can exceed max 200 characters. For example: **[{"value":1, "label":"male"}, {"value":2, "label":"female"}]**

        is_recurring : typing.Optional[bool]
            Type of the attribute. **Use only if the attribute's category is 'calculated' or 'global'**

        multi_category_options : typing.Optional[typing.Sequence[str]]
            List of options you want to add for multiple-choice attribute. **Use only if the attribute's category is "normal" and attribute's type is "multiple-choice". None of the multicategory options can exceed max 200 characters.** For example: **["USA","INDIA"]**

        type : typing.Optional[CreateAttributeRequestType]
            Type of the attribute. **Use only if the attribute's category is 'normal', 'category' or 'transactional'** Type **user and multiple-choice** is only available if the category is **normal** attribute Type **id** is only available if the category is **transactional** attribute Type **category** is only available if the category is **category** attribute

        value : typing.Optional[str]
            Value of the attribute. **Use only if the attribute's category is 'calculated' or 'global'**

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"contacts/attributes/{jsonable_encoder(attribute_category)}/{jsonable_encoder(attribute_name)}",
            method="POST",
            json={
                "enumeration": convert_and_respect_annotation_metadata(
                    object_=enumeration,
                    annotation=typing.Sequence[CreateAttributeRequestEnumerationItem],
                    direction="write",
                ),
                "isRecurring": is_recurring,
                "multiCategoryOptions": multi_category_options,
                "type": type,
                "value": value,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def update_attribute(
        self,
        attribute_category: UpdateAttributeRequestAttributeCategory,
        attribute_name: str,
        *,
        enumeration: typing.Optional[typing.Sequence[UpdateAttributeRequestEnumerationItem]] = OMIT,
        multi_category_options: typing.Optional[typing.Sequence[str]] = OMIT,
        value: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        attribute_category : UpdateAttributeRequestAttributeCategory
            Category of the attribute

        attribute_name : str
            Name of the existing attribute

        enumeration : typing.Optional[typing.Sequence[UpdateAttributeRequestEnumerationItem]]
            List of the values and labels that the attribute can take. **Use only if the attribute's category is "category"** None of the category options can exceed max 200 characters. For example, **[{"value":1, "label":"male"}, {"value":2, "label":"female"}]**

        multi_category_options : typing.Optional[typing.Sequence[str]]
            Use this option to add multiple-choice attributes options only if the attribute's category is "normal". **This option is specifically designed for updating multiple-choice attributes. None of the multicategory options can exceed max 200 characters.**. For example: **["USA","INDIA"]**

        value : typing.Optional[str]
            Value of the attribute to update. **Use only if the attribute's category is 'calculated' or 'global'**

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"contacts/attributes/{jsonable_encoder(attribute_category)}/{jsonable_encoder(attribute_name)}",
            method="PUT",
            json={
                "enumeration": convert_and_respect_annotation_metadata(
                    object_=enumeration,
                    annotation=typing.Sequence[UpdateAttributeRequestEnumerationItem],
                    direction="write",
                ),
                "multiCategoryOptions": multi_category_options,
                "value": value,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def delete_attribute(
        self,
        attribute_category: DeleteAttributeRequestAttributeCategory,
        attribute_name: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        attribute_category : DeleteAttributeRequestAttributeCategory
            Category of the attribute

        attribute_name : str
            Name of the existing attribute

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"contacts/attributes/{jsonable_encoder(attribute_category)}/{jsonable_encoder(attribute_name)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def delete_multi_attribute_options(
        self,
        multiple_choice_attribute: str,
        multiple_choice_attribute_option: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        multiple_choice_attribute : str
            Name of the existing multiple-choice attribute

        multiple_choice_attribute_option : str
            Name of the existing multiple-choice attribute option that you want to delete

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"contacts/attributes/multiple-choice/{jsonable_encoder(multiple_choice_attribute)}/{jsonable_encoder(multiple_choice_attribute_option)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def update_batch_contacts(
        self,
        *,
        contacts: typing.Optional[typing.Sequence[UpdateBatchContactsRequestContactsItem]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        contacts : typing.Optional[typing.Sequence[UpdateBatchContactsRequestContactsItem]]
            List of contacts to be updated

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            "contacts/batch",
            method="POST",
            json={
                "contacts": convert_and_respect_annotation_metadata(
                    object_=contacts,
                    annotation=typing.Sequence[UpdateBatchContactsRequestContactsItem],
                    direction="write",
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def create_doi_contact(
        self,
        *,
        email: str,
        include_list_ids: typing.Sequence[int],
        redirection_url: str,
        template_id: int,
        attributes: typing.Optional[typing.Dict[str, CreateDoiContactRequestAttributesValue]] = OMIT,
        exclude_list_ids: typing.Optional[typing.Sequence[int]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        <Note title="How to use attributes param?">
        attributes param in this endpoint is an object containing key-value pairs where values can be either a string, integer, array, or boolean. You can create key-value pairs with these four datatypes. When a value is an array, it should be an array of strings.
        </Note>

        Parameters
        ----------
        email : str
            Email address where the confirmation email will be sent. This email address will be the identifier for all other contact attributes.

        include_list_ids : typing.Sequence[int]
            Lists under user account where contact should be added

        redirection_url : str
            URL of the web page that user will be redirected to after clicking on the double opt in URL. When editing your DOI template you can reference this URL by using the tag **{{ params.DOIurl }}**.

        template_id : int
            Id of the Double opt-in (DOI) template

        attributes : typing.Optional[typing.Dict[str, CreateDoiContactRequestAttributesValue]]
            Pass the set of attributes and their values. **These attributes must be present in your Brevo account**. For eg. **{'FNAME':'Elly', 'LNAME':'Roger', 'COUNTRIES': ['India','China']}**

        exclude_list_ids : typing.Optional[typing.Sequence[int]]
            Lists under user account where contact should not be added

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            "contacts/doubleOptinConfirmation",
            method="POST",
            json={
                "attributes": convert_and_respect_annotation_metadata(
                    object_=attributes,
                    annotation=typing.Dict[str, CreateDoiContactRequestAttributesValue],
                    direction="write",
                ),
                "email": email,
                "excludeListIds": exclude_list_ids,
                "includeListIds": include_list_ids,
                "redirectionUrl": redirection_url,
                "templateId": template_id,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def request_contact_export(
        self,
        *,
        custom_contact_filter: RequestContactExportRequestCustomContactFilter,
        disable_notification: typing.Optional[bool] = OMIT,
        export_attributes: typing.Optional[typing.Sequence[str]] = OMIT,
        export_mandatory_attributes: typing.Optional[bool] = OMIT,
        export_metadata: typing.Optional[typing.Sequence[str]] = OMIT,
        export_date_in_utc: typing.Optional[bool] = OMIT,
        export_subscription_status: typing.Optional[typing.Sequence[str]] = OMIT,
        notify_url: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[RequestContactExportResponse]:
        """
        It returns the background process ID which on completion calls the notify URL that you have set in the input. File will be available in csv.

        Parameters
        ----------
        custom_contact_filter : RequestContactExportRequestCustomContactFilter
            Set the filter for the contacts to be exported.

        disable_notification : typing.Optional[bool]
            To avoid generating the email notification upon contact export, pass **true**

        export_attributes : typing.Optional[typing.Sequence[str]]
            List of all the attributes that you want to export. **These attributes must be present in your contact database. It is required if exportMandatoryAttributes is set false. ** For example: **['fname', 'lname', 'email']**

        export_mandatory_attributes : typing.Optional[bool]
            To export mandatory attributes like EMAIL, ADDED_TIME, MODIFIED_TIME

        export_metadata : typing.Optional[typing.Sequence[str]]
            Export metadata of contacts such as _listIds, ADDED_TIME, MODIFIED_TIME.

        export_date_in_utc : typing.Optional[bool]
            Specifies whether the date fields createdAt, modifiedAt in the exported data should be returned in UTC format.

        export_subscription_status : typing.Optional[typing.Sequence[str]]
            Export subscription status of contacts for email & sms marketting. Pass email_marketing to obtain the marketing email subscription status & sms_marketing to retrieve the marketing SMS status of the contact.

        notify_url : typing.Optional[str]
            Webhook that will be called once the export process is finished. For reference, https://help.brevo.com/hc/en-us/articles/360007666479

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[RequestContactExportResponse]
            process id created
        """
        _response = await self._client_wrapper.httpx_client.request(
            "contacts/export",
            method="POST",
            json={
                "customContactFilter": convert_and_respect_annotation_metadata(
                    object_=custom_contact_filter,
                    annotation=RequestContactExportRequestCustomContactFilter,
                    direction="write",
                ),
                "disableNotification": disable_notification,
                "exportAttributes": export_attributes,
                "exportMandatoryAttributes": export_mandatory_attributes,
                "exportMetadata": export_metadata,
                "exportDateInUTC": export_date_in_utc,
                "exportSubscriptionStatus": export_subscription_status,
                "notifyUrl": notify_url,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    RequestContactExportResponse,
                    construct_type(
                        type_=RequestContactExportResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorModel,
                        construct_type(
                            type_=ErrorModel,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_folders(
        self,
        *,
        limit: typing.Optional[int] = None,
        offset: typing.Optional[int] = None,
        sort: typing.Optional[GetFoldersRequestSort] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[GetFoldersResponse]:
        """
        <Note>
        Ongoing changes for this endpoint

        We're dropping support for the response attributes totalSubscribers and totalBlacklisted.

        These are non breaking changes.

        The default value for the attributes will be 0.

        The uniqueSubscribers field is deprecated
        </Note>

        Parameters
        ----------
        limit : typing.Optional[int]
            Number of documents per page

        offset : typing.Optional[int]
            Index of the first document of the page

        sort : typing.Optional[GetFoldersRequestSort]
            Sort the results in the ascending/descending order of record creation. Default order is **descending** if `sort` is not passed

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetFoldersResponse]
            Folders informations
        """
        _response = await self._client_wrapper.httpx_client.request(
            "contacts/folders",
            method="GET",
            params={
                "limit": limit,
                "offset": offset,
                "sort": sort,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetFoldersResponse,
                    construct_type(
                        type_=GetFoldersResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def create_folder(
        self, *, name: typing.Optional[str] = OMIT, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[CreateFolderResponse]:
        """
        Parameters
        ----------
        name : typing.Optional[str]
            Name of the folder

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[CreateFolderResponse]
            successfully created
        """
        _response = await self._client_wrapper.httpx_client.request(
            "contacts/folders",
            method="POST",
            json={
                "name": name,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CreateFolderResponse,
                    construct_type(
                        type_=CreateFolderResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_folder(
        self, folder_id: int, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[GetFolder]:
        """
        <Note>
        Ongoing changes for this endpoint.

        We're dropping support for the response attributes totalSubscribers and totalBlacklisted.

        These are non breaking changes. The default value for the attributes will be 0.
        </Note>

        Parameters
        ----------
        folder_id : int
            id of the folder

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetFolder]
            Folder details
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"contacts/folders/{jsonable_encoder(folder_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetFolder,
                    construct_type(
                        type_=GetFolder,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def update_folder(
        self,
        folder_id: int,
        *,
        name: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        folder_id : int
            Id of the folder

        name : typing.Optional[str]
            Name of the folder

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"contacts/folders/{jsonable_encoder(folder_id)}",
            method="PUT",
            json={
                "name": name,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def delete_folder(
        self, folder_id: int, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        folder_id : int
            Id of the folder

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"contacts/folders/{jsonable_encoder(folder_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_folder_lists(
        self,
        folder_id: int,
        *,
        limit: typing.Optional[int] = None,
        offset: typing.Optional[int] = None,
        sort: typing.Optional[GetFolderListsRequestSort] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[GetFolderListsResponse]:
        """
        <Note>
        Ongoing changes for this endpoint.

        We're dropping support for the response attributes totalSubscribers and totalBlacklisted.

        These are non breaking changes. The default value for the attributes will be 0.
        </Note>

        Parameters
        ----------
        folder_id : int
            Id of the folder

        limit : typing.Optional[int]
            Number of documents per page

        offset : typing.Optional[int]
            Index of the first document of the page

        sort : typing.Optional[GetFolderListsRequestSort]
            Sort the results in the ascending/descending order of record creation. Default order is **descending** if `sort` is not passed

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetFolderListsResponse]
            Folder's Lists details
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"contacts/folders/{jsonable_encoder(folder_id)}/lists",
            method="GET",
            params={
                "limit": limit,
                "offset": offset,
                "sort": sort,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetFolderListsResponse,
                    construct_type(
                        type_=GetFolderListsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def import_contacts(
        self,
        *,
        disable_notification: typing.Optional[bool] = OMIT,
        email_blacklist: typing.Optional[bool] = OMIT,
        empty_contacts_attributes: typing.Optional[bool] = OMIT,
        file_body: typing.Optional[str] = OMIT,
        file_url: typing.Optional[str] = OMIT,
        json_body: typing.Optional[typing.Sequence[ImportContactsRequestJsonBodyItem]] = OMIT,
        list_ids: typing.Optional[typing.Sequence[int]] = OMIT,
        new_list: typing.Optional[ImportContactsRequestNewList] = OMIT,
        notify_url: typing.Optional[str] = OMIT,
        sms_blacklist: typing.Optional[bool] = OMIT,
        update_existing_contacts: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[ImportContactsResponse]:
        """
        It returns the background process ID which on completion calls the notify URL that you have set in the input. **Note**: - Any contact attribute that doesn't exist in your account will be ignored at import end.

        Parameters
        ----------
        disable_notification : typing.Optional[bool]
            To disable email notification

        email_blacklist : typing.Optional[bool]
            To blacklist all the contacts for email

        empty_contacts_attributes : typing.Optional[bool]
            To facilitate the choice to erase any attribute of the existing contacts with empty value. emptyContactsAttributes = true means the empty fields in your import will erase any attribute that currently contain data in Brevo, & emptyContactsAttributes = false means the empty fields will not affect your existing data ( **only available if `updateExistingContacts` set to true **)

        file_body : typing.Optional[str]
            **Mandatory if fileUrl and jsonBody is not defined.** CSV content to be imported. Use semicolon to separate multiple attributes. **Maximum allowed file body size is 10MB** . However we recommend a safe limit of around 8 MB to avoid the issues caused due to increase of file body size while parsing. Please use fileUrl instead to import bigger files.

        file_url : typing.Optional[str]
            **Mandatory if fileBody and jsonBody is not defined.** URL of the file to be imported (**no local file**). Possible file formats: #### .txt, .csv, .json

        json_body : typing.Optional[typing.Sequence[ImportContactsRequestJsonBodyItem]]
            **Mandatory if fileUrl and fileBody is not defined.** JSON content to be imported. **Maximum allowed json body size is 10MB** . However we recommend a safe limit of around 8 MB to avoid the issues caused due to increase of json body size while parsing. Please use fileUrl instead to import bigger files.

        list_ids : typing.Optional[typing.Sequence[int]]
            **Mandatory if newList is not defined.** Ids of the lists in which the contacts shall be imported. For example, **[2, 4, 7]**.

        new_list : typing.Optional[ImportContactsRequestNewList]
            To create a new list and import the contacts into it, pass the listName and an optional folderId.

        notify_url : typing.Optional[str]
            URL that will be called once the import process is finished. For reference, https://help.brevo.com/hc/en-us/articles/360007666479

        sms_blacklist : typing.Optional[bool]
            To blacklist all the contacts for sms

        update_existing_contacts : typing.Optional[bool]
            To facilitate the choice to update the existing contacts

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ImportContactsResponse]
            process id created
        """
        _response = await self._client_wrapper.httpx_client.request(
            "contacts/import",
            method="POST",
            json={
                "disableNotification": disable_notification,
                "emailBlacklist": email_blacklist,
                "emptyContactsAttributes": empty_contacts_attributes,
                "fileBody": file_body,
                "fileUrl": file_url,
                "jsonBody": convert_and_respect_annotation_metadata(
                    object_=json_body, annotation=typing.Sequence[ImportContactsRequestJsonBodyItem], direction="write"
                ),
                "listIds": list_ids,
                "newList": convert_and_respect_annotation_metadata(
                    object_=new_list, annotation=ImportContactsRequestNewList, direction="write"
                ),
                "notifyUrl": notify_url,
                "smsBlacklist": sms_blacklist,
                "updateExistingContacts": update_existing_contacts,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ImportContactsResponse,
                    construct_type(
                        type_=ImportContactsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_lists(
        self,
        *,
        limit: typing.Optional[int] = None,
        offset: typing.Optional[int] = None,
        sort: typing.Optional[GetListsRequestSort] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[GetListsResponse]:
        """
        <Note>
        Ongoing changes for this endpoint.

        We're dropping support for the response attributes totalSubscribers and totalBlacklisted.

        These are non breaking changes. The default value for the attributes will be 0.
        </Note>

        Parameters
        ----------
        limit : typing.Optional[int]
            Number of documents per page

        offset : typing.Optional[int]
            Index of the first document of the page

        sort : typing.Optional[GetListsRequestSort]
            Sort the results in the ascending/descending order of record creation. Default order is **descending** if `sort` is not passed

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetListsResponse]
            Lists informations
        """
        _response = await self._client_wrapper.httpx_client.request(
            "contacts/lists",
            method="GET",
            params={
                "limit": limit,
                "offset": offset,
                "sort": sort,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetListsResponse,
                    construct_type(
                        type_=GetListsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def create_list(
        self, *, folder_id: int, name: str, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[CreateListResponse]:
        """
        Parameters
        ----------
        folder_id : int
            Id of the parent folder in which this list is to be created

        name : str
            Name of the list

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[CreateListResponse]
            successfully created
        """
        _response = await self._client_wrapper.httpx_client.request(
            "contacts/lists",
            method="POST",
            json={
                "folderId": folder_id,
                "name": name,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CreateListResponse,
                    construct_type(
                        type_=CreateListResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_list(
        self,
        list_id: int,
        *,
        start_date: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[GetListResponse]:
        """
        Parameters
        ----------
        list_id : int
            Id of the list

        start_date : typing.Optional[str]
            **Mandatory if endDate is used**. Ending (urlencoded) UTC date-time (YYYY-MM-DDTHH:mm:ss.SSSZ) to aggregate the sent email campaigns for a specific list id. **Prefer to pass your timezone in date-time format for accurate result**

        end_date : typing.Optional[str]
            **Mandatory if startDate is used**. Ending (urlencoded) UTC date-time (YYYY-MM-DDTHH:mm:ss.SSSZ) to aggregate the sent email campaigns for a specific list id. **Prefer to pass your timezone in date-time format for accurate result**

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetListResponse]
            List informations
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"contacts/lists/{jsonable_encoder(list_id)}",
            method="GET",
            params={
                "startDate": start_date,
                "endDate": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetListResponse,
                    construct_type(
                        type_=GetListResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def update_list(
        self,
        list_id: int,
        *,
        folder_id: typing.Optional[int] = OMIT,
        name: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        list_id : int
            Id of the list

        folder_id : typing.Optional[int]
            Id of the folder in which the list is to be moved. Either of the two parameters (name, folderId) can be updated at a time.

        name : typing.Optional[str]
            Name of the list. Either of the two parameters (name, folderId) can be updated at a time.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"contacts/lists/{jsonable_encoder(list_id)}",
            method="PUT",
            json={
                "folderId": folder_id,
                "name": name,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def delete_list(
        self, list_id: int, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        list_id : int
            Id of the list

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"contacts/lists/{jsonable_encoder(list_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_contacts_from_list(
        self,
        list_id: int,
        *,
        modified_since: typing.Optional[str] = None,
        limit: typing.Optional[int] = None,
        offset: typing.Optional[int] = None,
        sort: typing.Optional[GetContactsFromListRequestSort] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[GetContacts]:
        """
        Parameters
        ----------
        list_id : int
            Id of the list

        modified_since : typing.Optional[str]
            Filter (urlencoded) the contacts modified after a given UTC date-time (YYYY-MM-DDTHH:mm:ss.SSSZ). **Prefer to pass your timezone in date-time format for accurate result.**

        limit : typing.Optional[int]
            Number of documents per page

        offset : typing.Optional[int]
            Index of the first document of the page

        sort : typing.Optional[GetContactsFromListRequestSort]
            Sort the results in the ascending/descending order of record creation. Default order is **descending** if `sort` is not passed

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetContacts]
            Contact informations
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"contacts/lists/{jsonable_encoder(list_id)}/contacts",
            method="GET",
            params={
                "modifiedSince": modified_since,
                "limit": limit,
                "offset": offset,
                "sort": sort,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetContacts,
                    construct_type(
                        type_=GetContacts,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def add_contact_to_list(
        self,
        list_id: int,
        *,
        request: AddContactToListRequestBody,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[PostContactInfo]:
        """
        Parameters
        ----------
        list_id : int
            Id of the list

        request : AddContactToListRequestBody

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[PostContactInfo]
            All contacts have been added successfully to the list with details of failed ones
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"contacts/lists/{jsonable_encoder(list_id)}/contacts/add",
            method="POST",
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=AddContactToListRequestBody, direction="write"
            ),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PostContactInfo,
                    construct_type(
                        type_=PostContactInfo,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def remove_contact_from_list(
        self,
        list_id: int,
        *,
        request: RemoveContactFromListRequestBody,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[PostContactInfo]:
        """
        Parameters
        ----------
        list_id : int
            Id of the list

        request : RemoveContactFromListRequestBody

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[PostContactInfo]
            All contacts have been removed successfully from the list with details of failed ones
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"contacts/lists/{jsonable_encoder(list_id)}/contacts/remove",
            method="POST",
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=RemoveContactFromListRequestBody, direction="write"
            ),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PostContactInfo,
                    construct_type(
                        type_=PostContactInfo,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_segments(
        self,
        *,
        limit: typing.Optional[int] = None,
        offset: typing.Optional[int] = None,
        sort: typing.Optional[GetSegmentsRequestSort] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[GetSegmentsResponse]:
        """
        Parameters
        ----------
        limit : typing.Optional[int]
            Number of documents per page

        offset : typing.Optional[int]
            Index of the first document of the page

        sort : typing.Optional[GetSegmentsRequestSort]
            Sort the results in the ascending/descending order of record creation. Default order is **descending** if `sort` is not passed

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetSegmentsResponse]
            Segments informations
        """
        _response = await self._client_wrapper.httpx_client.request(
            "contacts/segments",
            method="GET",
            params={
                "limit": limit,
                "offset": offset,
                "sort": sort,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetSegmentsResponse,
                    construct_type(
                        type_=GetSegmentsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_contact_info(
        self,
        identifier: GetContactInfoRequestIdentifier,
        *,
        identifier_type: typing.Optional[GetContactInfoRequestIdentifierType] = None,
        start_date: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[GetContactInfoResponse]:
        """
        <Note title="Follow this format when passing a SMS phone number as an attribute">
        Accepted Number Formats

        91xxxxxxxxxx
        +91xxxxxxxxxx
        0091xxxxxxxxxx
        </Note>

        There are 2 ways to get a contact <br><br> Option 1- https://api.brevo.com/v3/contacts/{identifier} <br><br> Option 2- https://api.brevo.com/v3/contacts/{identifier}?identifierType={} <br> <br> Option 1 only works if identifierType is email_id (for EMAIL), phone_id (for SMS) or contact_id (for ID of the contact),where you can directly pass the value of EMAIL, SMS and ID of the contact.   <br><br> Option 2 works for all identifierType, use email_id for EMAIL attribute, phone_id for SMS attribute, contact_id for ID of the contact, ext_id for EXT_ID attribute, whatsapp_id for WHATSAPP attribute, landline_number_id for LANDLINE_NUMBER attribute <br><br>Along with the contact details, this endpoint will show the statistics of contact for the recent 90 days by default. To fetch the earlier statistics, please use Get contact campaign stats ``https://developers.brevo.com/reference/contacts-7#getcontactstats`` endpoint with the appropriate date ranges.

        Parameters
        ----------
        identifier : GetContactInfoRequestIdentifier
            Email (urlencoded) OR ID of the contact OR its SMS attribute value OR EXT_ID attribute (urlencoded)

        identifier_type : typing.Optional[GetContactInfoRequestIdentifierType]
            email_id for Email, phone_id for SMS attribute, contact_id for ID of the contact, ext_id for EXT_ID attribute, whatsapp_id for WHATSAPP attribute, landline_number_id for LANDLINE_NUMBER attribute

        start_date : typing.Optional[str]
            **Mandatory if endDate is used.** Starting date (YYYY-MM-DD) of the statistic events specific to campaigns. Must be lower than equal to endDate

        end_date : typing.Optional[str]
            **Mandatory if startDate is used.** Ending date (YYYY-MM-DD) of the statistic events specific to campaigns. Must be greater than equal to startDate.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetContactInfoResponse]
            Contact informations
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"contacts/{jsonable_encoder(identifier)}",
            method="GET",
            params={
                "identifierType": identifier_type,
                "startDate": start_date,
                "endDate": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetContactInfoResponse,
                    construct_type(
                        type_=GetContactInfoResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def update_contact(
        self,
        identifier: UpdateContactRequestIdentifier,
        *,
        identifier_type: typing.Optional[UpdateContactRequestIdentifierType] = None,
        attributes: typing.Optional[typing.Dict[str, UpdateContactRequestAttributesValue]] = OMIT,
        email_blacklisted: typing.Optional[bool] = OMIT,
        ext_id: typing.Optional[str] = OMIT,
        list_ids: typing.Optional[typing.Sequence[int]] = OMIT,
        sms_blacklisted: typing.Optional[bool] = OMIT,
        smtp_blacklist_sender: typing.Optional[typing.Sequence[str]] = OMIT,
        unlink_list_ids: typing.Optional[typing.Sequence[int]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        There are 2 ways to update a contact <br><br> Option 1- https://api.brevo.com/v3/contacts/{identifier} <br><br> Option 2- https://api.brevo.com/v3/contacts/{identifier}?identifierType={} <br> <br> Option 1 only works if identifierType is email_id (for EMAIL) or contact_id (for ID of the contact),where you can directly pass the value of EMAIL and ID of the contact.   <br><br> Option 2 works for all identifierType, use email_id for EMAIL attribute, contact_id for ID of the contact, ext_id for EXT_ID attribute, phone_id for SMS attribute, whatsapp_id for WHATSAPP attribute, landline_number_id for LANDLINE attribute

        Parameters
        ----------
        identifier : UpdateContactRequestIdentifier
            Email (urlencoded) OR ID of the contact OR EXT_ID attribute (urlencoded) OR its SMS attribute value OR its WHATSAPP attribute value OR its LANDLINE attribute value

        identifier_type : typing.Optional[UpdateContactRequestIdentifierType]
            email_id for Email, contact_id for ID of the contact, ext_id for EXT_ID attribute, phone_id for SMS attribute, whatsapp_id for WHATSAPP attribute, landline_number_id for LANDLINE attribute

        attributes : typing.Optional[typing.Dict[str, UpdateContactRequestAttributesValue]]
            Pass the set of attributes to be updated. **These attributes must be present in your account**. To update existing email address of a contact with the new one please pass EMAIL in attributes. For example, **{ "EMAIL":"newemail@domain.com", "FNAME":"Ellie", "LNAME":"Roger", "COUNTRIES":["India","China"]}**. The attribute's parameter should be passed in capital letter while updating a contact. Values that don't match the attribute type (e.g. text or string in a date attribute) will be ignored .Keep in mind transactional attributes can be updated the same way as normal attributes. Mobile Number in **SMS** field should be passed with proper country code. For example: **{"SMS":"+91xxxxxxxxxx"} or {"SMS":"0091xxxxxxxxxx"}**

        email_blacklisted : typing.Optional[bool]
            Set/unset this field to blacklist/allow the contact for emails (emailBlacklisted = true)

        ext_id : typing.Optional[str]
            Pass your own Id to update ext_id of a contact.

        list_ids : typing.Optional[typing.Sequence[int]]
            Ids of the lists to add the contact to

        sms_blacklisted : typing.Optional[bool]
            Set/unset this field to blacklist/allow the contact for SMS (smsBlacklisted = true)

        smtp_blacklist_sender : typing.Optional[typing.Sequence[str]]
            transactional email forbidden sender for contact. Use only for email Contact

        unlink_list_ids : typing.Optional[typing.Sequence[int]]
            Ids of the lists to remove the contact from

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"contacts/{jsonable_encoder(identifier)}",
            method="PUT",
            params={
                "identifierType": identifier_type,
            },
            json={
                "attributes": convert_and_respect_annotation_metadata(
                    object_=attributes,
                    annotation=typing.Dict[str, UpdateContactRequestAttributesValue],
                    direction="write",
                ),
                "emailBlacklisted": email_blacklisted,
                "ext_id": ext_id,
                "listIds": list_ids,
                "smsBlacklisted": sms_blacklisted,
                "smtpBlacklistSender": smtp_blacklist_sender,
                "unlinkListIds": unlink_list_ids,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 425:
                raise TooEarlyError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ContactErrorModel,
                        construct_type(
                            type_=ContactErrorModel,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def delete_contact(
        self,
        identifier: DeleteContactRequestIdentifier,
        *,
        identifier_type: typing.Optional[DeleteContactRequestIdentifierType] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        There are 2 ways to delete a contact <br><br> Option 1- https://api.brevo.com/v3/contacts/{identifier} <br><br> Option 2- https://api.brevo.com/v3/contacts/{identifier}?identifierType={} <br> <br> Option 1 only works if identifierType is email_id (for EMAIL) or contact_id (for ID of the contact),where you can directly pass the value of EMAIL and ID of the contact.   <br><br> Option 2 works for all identifierType, use email_id for EMAIL attribute, contact_id for ID of the contact, ext_id for EXT_ID attribute, phone_id for SMS attribute, whatsapp_id for WHATSAPP attribute, landline_number_id for LANDLINE_NUMBER attribute.

        Parameters
        ----------
        identifier : DeleteContactRequestIdentifier
            Email (urlencoded) OR ID of the contact OR EXT_ID attribute (urlencoded)

        identifier_type : typing.Optional[DeleteContactRequestIdentifierType]
            email_id for Email, contact_id for ID of the contact, ext_id for EXT_ID attribute, phone_id for SMS attribute, whatsapp_id for WHATSAPP attribute, landline_number_id for LANDLINE_NUMBER attribute

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"contacts/{jsonable_encoder(identifier)}",
            method="DELETE",
            params={
                "identifierType": identifier_type,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 405:
                raise MethodNotAllowedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorModel,
                        construct_type(
                            type_=ErrorModel,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_contact_stats(
        self,
        identifier: GetContactStatsRequestIdentifier,
        *,
        start_date: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[GetContactStatsResponse]:
        """
        Parameters
        ----------
        identifier : GetContactStatsRequestIdentifier
            Email (urlencoded) OR ID of the contact

        start_date : typing.Optional[str]
            **Mandatory if endDate is used.** Starting date (YYYY-MM-DD) of the statistic events specific to campaigns. Must be lower than equal to endDate

        end_date : typing.Optional[str]
            **Mandatory if startDate is used.** Ending date (YYYY-MM-DD) of the statistic events specific to campaigns. Must be greater than equal to startDate. Maximum difference between startDate and endDate should not be greater than 90 days

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetContactStatsResponse]
            Contact campaign statistics informations
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"contacts/{jsonable_encoder(identifier)}/campaignStats",
            method="GET",
            params={
                "startDate": start_date,
                "endDate": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetContactStatsResponse,
                    construct_type(
                        type_=GetContactStatsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)
