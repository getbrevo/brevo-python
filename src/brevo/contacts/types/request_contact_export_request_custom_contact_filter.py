# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
import typing_extensions
from ...core.pydantic_utilities import IS_PYDANTIC_V2
from ...core.serialization import FieldMetadata
from ...core.unchecked_base_model import UncheckedBaseModel
from .request_contact_export_request_custom_contact_filter_action_for_contacts import (
    RequestContactExportRequestCustomContactFilterActionForContacts,
)
from .request_contact_export_request_custom_contact_filter_action_for_email_campaigns import (
    RequestContactExportRequestCustomContactFilterActionForEmailCampaigns,
)
from .request_contact_export_request_custom_contact_filter_action_for_sms_campaigns import (
    RequestContactExportRequestCustomContactFilterActionForSmsCampaigns,
)


class RequestContactExportRequestCustomContactFilter(UncheckedBaseModel):
    """
    Set the filter for the contacts to be exported.
    """

    action_for_contacts: typing_extensions.Annotated[
        typing.Optional[RequestContactExportRequestCustomContactFilterActionForContacts],
        FieldMetadata(alias="actionForContacts"),
        pydantic.Field(
            alias="actionForContacts",
            description="**Mandatory if neither actionForEmailCampaigns nor actionForSmsCampaigns is passed.** This will export the contacts on the basis of provided action applied on contacts as per the list id. * **allContacts** - Fetch the list of all contacts for a particular list. * **subscribed & unsubscribed** - Fetch the list of subscribed / unsubscribed (blacklisted via any means) contacts for a particular list. * **unsubscribedPerList** - Fetch the list of contacts that are unsubscribed from a particular list only.",
        ),
    ] = None
    action_for_email_campaigns: typing_extensions.Annotated[
        typing.Optional[RequestContactExportRequestCustomContactFilterActionForEmailCampaigns],
        FieldMetadata(alias="actionForEmailCampaigns"),
        pydantic.Field(
            alias="actionForEmailCampaigns",
            description="**Mandatory if neither actionForContacts nor actionForSmsCampaigns is passed.** This will export the contacts on the basis of provided action applied on email campaigns. * **openers & nonOpeners** - emailCampaignId is mandatory. Fetch the list of readers / non-readers for a particular email campaign. * **clickers & nonClickers** - emailCampaignId is mandatory. Fetch the list of clickers / non-clickers for a particular email campaign. * **unsubscribed** - emailCampaignId is mandatory. Fetch the list of all unsubscribed (blacklisted via any means) contacts for a particular email campaign. * **hardBounces & softBounces** - emailCampaignId is optional. Fetch the list of hard bounces / soft bounces for a particular / all email campaign(s).",
        ),
    ] = None
    action_for_sms_campaigns: typing_extensions.Annotated[
        typing.Optional[RequestContactExportRequestCustomContactFilterActionForSmsCampaigns],
        FieldMetadata(alias="actionForSmsCampaigns"),
        pydantic.Field(
            alias="actionForSmsCampaigns",
            description="**Mandatory if neither actionForContacts nor actionForEmailCampaigns is passed.** This will export the contacts on the basis of provided action applied on sms campaigns. * **unsubscribed** - Fetch the list of all unsubscribed (blacklisted via any means) contacts for all / particular sms campaigns. * **hardBounces & softBounces** - Fetch the list of hard bounces / soft bounces for all / particular sms campaigns.",
        ),
    ] = None
    email_campaign_id: typing_extensions.Annotated[
        typing.Optional[int],
        FieldMetadata(alias="emailCampaignId"),
        pydantic.Field(
            alias="emailCampaignId",
            description="Considered only if **actionForEmailCampaigns** is passed, ignored otherwise. **Mandatory if action is one of the following - openers, nonOpeners, clickers, nonClickers, unsubscribed.** The id of the email campaign for which the corresponding action shall be applied in the filter.",
        ),
    ] = None
    list_id: typing_extensions.Annotated[
        typing.Optional[int],
        FieldMetadata(alias="listId"),
        pydantic.Field(
            alias="listId",
            description="ID of the list. This is mandatory if actionForContacts is specified and segmentId is not provided. Either segmentId or listId must be included.",
        ),
    ] = None
    segment_id: typing_extensions.Annotated[
        typing.Optional[int],
        FieldMetadata(alias="segmentId"),
        pydantic.Field(
            alias="segmentId",
            description="ID of the segment. This is mandatory if actionForContacts is specified and listId is not provided. Either segmentId or listId must be included.",
        ),
    ] = None
    sms_campaign_id: typing_extensions.Annotated[
        typing.Optional[int],
        FieldMetadata(alias="smsCampaignId"),
        pydantic.Field(
            alias="smsCampaignId",
            description="Considered only if **actionForSmsCampaigns** is passed, ignored otherwise. The id of sms campaign for which the corresponding action shall be applied in the filter.",
        ),
    ] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow
