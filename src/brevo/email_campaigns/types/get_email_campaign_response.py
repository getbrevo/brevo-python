# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
import typing_extensions
from ...core.pydantic_utilities import IS_PYDANTIC_V2
from ...core.serialization import FieldMetadata
from ...core.unchecked_base_model import UncheckedBaseModel
from ...types.get_campaign_recipients import GetCampaignRecipients
from ...types.get_extended_campaign_stats import GetExtendedCampaignStats
from .get_email_campaign_response_sender import GetEmailCampaignResponseSender
from .get_email_campaign_response_status import GetEmailCampaignResponseStatus
from .get_email_campaign_response_type import GetEmailCampaignResponseType


class GetEmailCampaignResponse(UncheckedBaseModel):
    ab_testing: typing_extensions.Annotated[
        typing.Optional[bool],
        FieldMetadata(alias="abTesting"),
        pydantic.Field(
            alias="abTesting",
            description="Status of A/B Test for the campaign. abTesting = false means it is disabled, & abTesting = true means it is enabled.",
        ),
    ] = None
    id: int = pydantic.Field()
    """
    ID of the campaign
    """

    name: str = pydantic.Field()
    """
    Name of the campaign
    """

    preview_text: typing_extensions.Annotated[
        typing.Optional[str],
        FieldMetadata(alias="previewText"),
        pydantic.Field(alias="previewText", description="Preview text or preheader of the email campaign"),
    ] = None
    scheduled_at: typing_extensions.Annotated[
        typing.Optional[str],
        FieldMetadata(alias="scheduledAt"),
        pydantic.Field(
            alias="scheduledAt", description="UTC date-time on which campaign is scheduled (YYYY-MM-DDTHH:mm:ss.SSSZ)"
        ),
    ] = None
    send_at_best_time: typing_extensions.Annotated[
        typing.Optional[bool],
        FieldMetadata(alias="sendAtBestTime"),
        pydantic.Field(
            alias="sendAtBestTime",
            description="It is true if you have chosen to send your campaign at best time, otherwise it is false",
        ),
    ] = None
    split_rule: typing_extensions.Annotated[
        typing.Optional[int],
        FieldMetadata(alias="splitRule"),
        pydantic.Field(
            alias="splitRule",
            description="The size of your ab-test groups. Only available if `abTesting` flag of the campaign is `true`",
        ),
    ] = None
    status: GetEmailCampaignResponseStatus = pydantic.Field()
    """
    Status of the campaign
    """

    subject: typing.Optional[str] = pydantic.Field(default=None)
    """
    Subject of the campaign. Only available if `abTesting` flag of the campaign is `false`
    """

    subject_a: typing_extensions.Annotated[
        typing.Optional[str],
        FieldMetadata(alias="subjectA"),
        pydantic.Field(
            alias="subjectA",
            description="Subject A of the ab-test campaign. Only available if `abTesting` flag of the campaign is `true`",
        ),
    ] = None
    subject_b: typing_extensions.Annotated[
        typing.Optional[str],
        FieldMetadata(alias="subjectB"),
        pydantic.Field(
            alias="subjectB",
            description="Subject B of the ab-test campaign. Only available if `abTesting` flag of the campaign is `true`",
        ),
    ] = None
    type: GetEmailCampaignResponseType = pydantic.Field()
    """
    Type of campaign
    """

    winner_criteria: typing_extensions.Annotated[
        typing.Optional[str],
        FieldMetadata(alias="winnerCriteria"),
        pydantic.Field(
            alias="winnerCriteria",
            description="Criteria for the winning version. Only available if `abTesting` flag of the campaign is `true`",
        ),
    ] = None
    winner_delay: typing_extensions.Annotated[
        typing.Optional[int],
        FieldMetadata(alias="winnerDelay"),
        pydantic.Field(
            alias="winnerDelay",
            description="The duration of the test in hours at the end of which the winning version will be sent. Only available if `abTesting` flag of the campaign is `true`",
        ),
    ] = None
    created_at: typing_extensions.Annotated[
        str,
        FieldMetadata(alias="createdAt"),
        pydantic.Field(
            alias="createdAt", description="Creation UTC date-time of the campaign (YYYY-MM-DDTHH:mm:ss.SSSZ)"
        ),
    ]
    footer: str = pydantic.Field()
    """
    Footer of the campaign
    """

    header: str = pydantic.Field()
    """
    Header of the campaign
    """

    html_content: typing_extensions.Annotated[
        str,
        FieldMetadata(alias="htmlContent"),
        pydantic.Field(alias="htmlContent", description="HTML content of the campaign"),
    ]
    inline_image_activation: typing_extensions.Annotated[
        typing.Optional[bool],
        FieldMetadata(alias="inlineImageActivation"),
        pydantic.Field(
            alias="inlineImageActivation",
            description="Status of inline image. inlineImageActivation = false means image canâ€™t be embedded, & inlineImageActivation = true means image can be embedded, in the email.",
        ),
    ] = None
    mirror_active: typing_extensions.Annotated[
        typing.Optional[bool],
        FieldMetadata(alias="mirrorActive"),
        pydantic.Field(
            alias="mirrorActive",
            description="Status of mirror links in campaign. mirrorActive = false means mirror links are deactivated, & mirrorActive = true means mirror links are activated, in the campaign",
        ),
    ] = None
    modified_at: typing_extensions.Annotated[
        str,
        FieldMetadata(alias="modifiedAt"),
        pydantic.Field(
            alias="modifiedAt",
            description="UTC date-time of last modification of the campaign (YYYY-MM-DDTHH:mm:ss.SSSZ)",
        ),
    ]
    recurring: typing.Optional[bool] = pydantic.Field(default=None)
    """
    FOR TRIGGER ONLY ! Type of trigger campaign.recurring = false means contact can receive the same Trigger campaign only once, & recurring = true means contact can receive the same Trigger campaign several times
    """

    reply_to: typing_extensions.Annotated[
        str,
        FieldMetadata(alias="replyTo"),
        pydantic.Field(alias="replyTo", description='Email defined as the "Reply to" of the campaign'),
    ]
    return_bounce: typing_extensions.Annotated[
        typing.Optional[int],
        FieldMetadata(alias="returnBounce"),
        pydantic.Field(
            alias="returnBounce", description="Total number of non-delivered campaigns for a particular campaign id."
        ),
    ] = None
    sender: GetEmailCampaignResponseSender
    sent_date: typing_extensions.Annotated[
        typing.Optional[str],
        FieldMetadata(alias="sentDate"),
        pydantic.Field(
            alias="sentDate",
            description="Sent UTC date-time of the campaign (YYYY-MM-DDTHH:mm:ss.SSSZ). Only available if 'status' of the campaign is 'sent'",
        ),
    ] = None
    share_link: typing_extensions.Annotated[
        typing.Optional[str],
        FieldMetadata(alias="shareLink"),
        pydantic.Field(alias="shareLink", description="Link to share the campaign on social medias"),
    ] = None
    tag: typing.Optional[str] = pydantic.Field(default=None)
    """
    Tag of the campaign
    """

    test_sent: typing_extensions.Annotated[
        bool,
        FieldMetadata(alias="testSent"),
        pydantic.Field(
            alias="testSent",
            description="Retrieved the status of test email sending. (true=Test email has been sent  false=Test email has not been sent)",
        ),
    ]
    to_field: typing_extensions.Annotated[
        typing.Optional[str],
        FieldMetadata(alias="toField"),
        pydantic.Field(alias="toField", description='Customisation of the "to" field of the campaign'),
    ] = None
    utm_campaign_value: typing_extensions.Annotated[
        typing.Optional[str],
        FieldMetadata(alias="utmCampaignValue"),
        pydantic.Field(alias="utmCampaignValue", description="utm parameter associated with campaign"),
    ] = None
    utm_id_active: typing_extensions.Annotated[
        typing.Optional[bool],
        FieldMetadata(alias="utmIDActive"),
        pydantic.Field(alias="utmIDActive", description="utm id active"),
    ] = None
    utm_medium: typing_extensions.Annotated[
        typing.Optional[str], FieldMetadata(alias="utmMedium"), pydantic.Field(alias="utmMedium")
    ] = None
    utm_source: typing_extensions.Annotated[
        typing.Optional[str],
        FieldMetadata(alias="utmSource"),
        pydantic.Field(alias="utmSource", description="source of utm"),
    ] = None
    recipients: GetCampaignRecipients
    statistics: GetExtendedCampaignStats

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow
