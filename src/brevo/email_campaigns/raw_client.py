# This file was auto-generated by Fern from our API Definition.

import typing
from json.decoder import JSONDecodeError

from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.http_response import AsyncHttpResponse, HttpResponse
from ..core.jsonable_encoder import jsonable_encoder
from ..core.request_options import RequestOptions
from ..core.serialization import convert_and_respect_annotation_metadata
from ..core.unchecked_base_model import construct_type
from ..errors.bad_request_error import BadRequestError
from ..errors.method_not_allowed_error import MethodNotAllowedError
from ..errors.not_found_error import NotFoundError
from ..errors.payment_required_error import PaymentRequiredError
from ..types.error_model import ErrorModel
from ..types.send_report_email import SendReportEmail
from ..types.send_report_language import SendReportLanguage
from ..types.update_campaign_status_status import UpdateCampaignStatusStatus
from .types.create_email_campaign_request_email_expiration_date import CreateEmailCampaignRequestEmailExpirationDate
from .types.create_email_campaign_request_recipients import CreateEmailCampaignRequestRecipients
from .types.create_email_campaign_request_sender import CreateEmailCampaignRequestSender
from .types.create_email_campaign_request_winner_criteria import CreateEmailCampaignRequestWinnerCriteria
from .types.create_email_campaign_response import CreateEmailCampaignResponse
from .types.email_export_recipients_request_recipients_type import EmailExportRecipientsRequestRecipientsType
from .types.email_export_recipients_response import EmailExportRecipientsResponse
from .types.get_ab_test_campaign_result_response import GetAbTestCampaignResultResponse
from .types.get_email_campaign_request_statistics import GetEmailCampaignRequestStatistics
from .types.get_email_campaign_response import GetEmailCampaignResponse
from .types.get_email_campaigns_request_sort import GetEmailCampaignsRequestSort
from .types.get_email_campaigns_request_statistics import GetEmailCampaignsRequestStatistics
from .types.get_email_campaigns_request_status import GetEmailCampaignsRequestStatus
from .types.get_email_campaigns_request_type import GetEmailCampaignsRequestType
from .types.get_email_campaigns_response import GetEmailCampaignsResponse
from .types.get_shared_template_url_response import GetSharedTemplateUrlResponse
from .types.update_email_campaign_request_email_expiration_date import UpdateEmailCampaignRequestEmailExpirationDate
from .types.update_email_campaign_request_recipients import UpdateEmailCampaignRequestRecipients
from .types.update_email_campaign_request_sender import UpdateEmailCampaignRequestSender
from .types.update_email_campaign_request_winner_criteria import UpdateEmailCampaignRequestWinnerCriteria
from .types.upload_image_to_gallery_response import UploadImageToGalleryResponse

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawEmailCampaignsClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def get_email_campaigns(
        self,
        *,
        type: typing.Optional[GetEmailCampaignsRequestType] = None,
        status: typing.Optional[GetEmailCampaignsRequestStatus] = None,
        statistics: typing.Optional[GetEmailCampaignsRequestStatistics] = None,
        start_date: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        limit: typing.Optional[int] = None,
        offset: typing.Optional[int] = None,
        sort: typing.Optional[GetEmailCampaignsRequestSort] = None,
        exclude_html_content: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[GetEmailCampaignsResponse]:
        """
        <Note>
        The response payload for this endpoint has changed

        You now need to specify which type of statistics you would like to retrieve. For more information visit [this page](https://developers.brevo.com/changelog/get-all-marketing-campaigns).
        </Note>

        Parameters
        ----------
        type : typing.Optional[GetEmailCampaignsRequestType]
            Filter on the type of the campaigns

        status : typing.Optional[GetEmailCampaignsRequestStatus]
            Filter on the status of the campaign

        statistics : typing.Optional[GetEmailCampaignsRequestStatistics]
            Filter on type of the statistics required. Example **globalStats** value will only fetch globalStats info of the campaign in returned response.This option only returns data for events occurred in the last 6 months.For older campaigns, it’s advisable to use the **Get Campaign Report** endpoint.

        start_date : typing.Optional[str]
            **Mandatory if endDate is used**. Starting (urlencoded) UTC date-time (YYYY-MM-DDTHH:mm:ss.SSSZ) to filter the sent email campaigns. **Prefer to pass your timezone in date-time format for accurate result** ( only available if either 'status' not passed and if passed is set to 'sent' )

        end_date : typing.Optional[str]
            **Mandatory if startDate is used**. Ending (urlencoded) UTC date-time (YYYY-MM-DDTHH:mm:ss.SSSZ) to filter the sent email campaigns. **Prefer to pass your timezone in date-time format for accurate result** ( only available if either 'status' not passed and if passed is set to 'sent' )

        limit : typing.Optional[int]
            Number of documents per page

        offset : typing.Optional[int]
            Index of the first document in the page

        sort : typing.Optional[GetEmailCampaignsRequestSort]
            Sort the results in the ascending/descending order of record creation. Default order is **descending** if `sort` is not passed

        exclude_html_content : typing.Optional[bool]
            Use this flag to exclude htmlContent from the response body. If set to **true**, htmlContent field will be returned as empty string in the response body

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetEmailCampaignsResponse]
            Email campaigns informations
        """
        _response = self._client_wrapper.httpx_client.request(
            "emailCampaigns",
            method="GET",
            params={
                "type": type,
                "status": status,
                "statistics": statistics,
                "startDate": start_date,
                "endDate": end_date,
                "limit": limit,
                "offset": offset,
                "sort": sort,
                "excludeHtmlContent": exclude_html_content,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetEmailCampaignsResponse,
                    construct_type(
                        type_=GetEmailCampaignsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def create_email_campaign(
        self,
        *,
        name: str,
        sender: CreateEmailCampaignRequestSender,
        ab_testing: typing.Optional[bool] = OMIT,
        attachment_url: typing.Optional[str] = OMIT,
        email_expiration_date: typing.Optional[CreateEmailCampaignRequestEmailExpirationDate] = OMIT,
        footer: typing.Optional[str] = OMIT,
        header: typing.Optional[str] = OMIT,
        html_content: typing.Optional[str] = OMIT,
        html_url: typing.Optional[str] = OMIT,
        increase_rate: typing.Optional[int] = OMIT,
        initial_quota: typing.Optional[int] = OMIT,
        inline_image_activation: typing.Optional[bool] = OMIT,
        ip_warmup_enable: typing.Optional[bool] = OMIT,
        mirror_active: typing.Optional[bool] = OMIT,
        params: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        preview_text: typing.Optional[str] = OMIT,
        recipients: typing.Optional[CreateEmailCampaignRequestRecipients] = OMIT,
        reply_to: typing.Optional[str] = OMIT,
        scheduled_at: typing.Optional[str] = OMIT,
        send_at_best_time: typing.Optional[bool] = OMIT,
        split_rule: typing.Optional[int] = OMIT,
        subject: typing.Optional[str] = OMIT,
        subject_a: typing.Optional[str] = OMIT,
        subject_b: typing.Optional[str] = OMIT,
        tag: typing.Optional[str] = OMIT,
        template_id: typing.Optional[int] = OMIT,
        to_field: typing.Optional[str] = OMIT,
        unsubscription_page_id: typing.Optional[str] = OMIT,
        update_form_id: typing.Optional[str] = OMIT,
        utm_campaign: typing.Optional[str] = OMIT,
        winner_criteria: typing.Optional[CreateEmailCampaignRequestWinnerCriteria] = OMIT,
        winner_delay: typing.Optional[int] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[CreateEmailCampaignResponse]:
        """
        Parameters
        ----------
        name : str
            Name of the campaign

        sender : CreateEmailCampaignRequestSender
            Sender details including id or email and name (_optional_). Only one of either Sender's email or Sender's ID shall be passed in one request at a time. For example: **{"name":"xyz", "email":"example@abc.com"}** **{"name":"xyz", "id":123}**

        ab_testing : typing.Optional[bool]
            Status of A/B Test. abTesting = false means it is disabled & abTesting = true means it is enabled. **subjectA, subjectB, splitRule, winnerCriteria & winnerDelay** will be considered when abTesting is set to true. subjectA & subjectB are mandatory together & subject if passed is ignored. **Can be set to true only if sendAtBestTime is false**. You will be able to set up two subject lines for your campaign and send them to a random sample of your total recipients. Half of the test group will receive version A, and the other half will receive version B

        attachment_url : typing.Optional[str]
            Absolute url of the attachment (no local file). Extension allowed: #### xlsx, xls, ods, docx, docm, doc, csv, pdf, txt, gif, jpg, jpeg, png, tif, tiff, rtf, bmp, cgm, css, shtml, html, htm, zip, xml, ppt, pptx, tar, ez, ics, mobi, msg, pub and eps

        email_expiration_date : typing.Optional[CreateEmailCampaignRequestEmailExpirationDate]
            To reduce your carbon footprint, set an expiration date for your email. If supported, it will be automatically deleted from the recipient’s inbox, saving storage space and energy. Learn more about setting an email expiration date. For reference , ``https://help.brevo.com/hc/en-us/articles/4413566705298-Create-an-email-campaign``

        footer : typing.Optional[str]
            Footer of the email campaign

        header : typing.Optional[str]
            Header of the email campaign

        html_content : typing.Optional[str]
            Mandatory if htmlUrl and templateId are empty. Body of the message (HTML).

        html_url : typing.Optional[str]
            **Mandatory if htmlContent and templateId are empty**. Url to the message (HTML). For example: **https://html.domain.com**

        increase_rate : typing.Optional[int]
            **Mandatory if ipWarmupEnable is set to true**. Set a percentage increase rate for warming up your ip. We recommend you set the increase rate to 30% per day. If you want to send the same number of emails every day, set the daily increase value to 0%.

        initial_quota : typing.Optional[int]
            **Mandatory if ipWarmupEnable is set to true**. Set an initial quota greater than 1 for warming up your ip. We recommend you set a value of 3000.

        inline_image_activation : typing.Optional[bool]
            Use true to embedded the images in your email. Final size of the email should be less than **4MB**. Campaigns with embedded images can _not be sent to more than 5000 contacts_

        ip_warmup_enable : typing.Optional[bool]
            **Available for dedicated ip clients**. Set this to true if you wish to warm up your ip.

        mirror_active : typing.Optional[bool]
            Use true to enable the mirror link

        params : typing.Optional[typing.Dict[str, typing.Any]]
            Pass the set of attributes to customize the type classic campaign. For example: **{"FNAME":"Joe", "LNAME":"Doe"}**. Only available if **type** is **classic**. It's considered only if campaign is in _New Template Language format_. The New Template Language is dependent on the values of **subject, htmlContent/htmlUrl, sender.name & toField**

        preview_text : typing.Optional[str]
            Preview text or preheader of the email campaign

        recipients : typing.Optional[CreateEmailCampaignRequestRecipients]
            Segment ids and List ids to include/exclude from campaign

        reply_to : typing.Optional[str]
            Email on which the campaign recipients will be able to reply to

        scheduled_at : typing.Optional[str]
            Sending UTC date-time (YYYY-MM-DDTHH:mm:ss.SSSZ). **Prefer to pass your timezone in date-time format for accurate result**. If sendAtBestTime is set to true, your campaign will be sent according to the date passed (ignoring the time part). For example: **2017-06-01T12:30:00+02:00**

        send_at_best_time : typing.Optional[bool]
            Set this to true if you want to send your campaign at best time.

        split_rule : typing.Optional[int]
            Add the size of your test groups. **Mandatory if abTesting = true & 'recipients' is passed**. We'll send version A and B to a random sample of recipients, and then the winning version to everyone else

        subject : typing.Optional[str]
            Subject of the campaign. **Mandatory if abTesting is false**. Ignored if abTesting is true.

        subject_a : typing.Optional[str]
            Subject A of the campaign. **Mandatory if abTesting = true**. subjectA & subjectB should have unique value

        subject_b : typing.Optional[str]
            Subject B of the campaign. **Mandatory if abTesting = true**. subjectA & subjectB should have unique value

        tag : typing.Optional[str]
            Tag of the campaign

        template_id : typing.Optional[int]
            **Mandatory if htmlContent and htmlUrl are empty**. Id of the transactional email template with status _active_. Used to copy only its content fetched from htmlContent/htmlUrl to an email campaign for RSS feature.

        to_field : typing.Optional[str]
            To personalize the **To** Field. If you want to include the first name and last name of your recipient, add **{FNAME} {LNAME}**. These contact attributes must already exist in your Brevo account. If input parameter **params** used please use **{{contact.FNAME}} {{contact.LNAME}}** for personalization

        unsubscription_page_id : typing.Optional[str]
            Enter an unsubscription page id. The page id is a 24 digit alphanumeric id that can be found in the URL when editing the page. If not entered, then the default unsubscription page will be used.

        update_form_id : typing.Optional[str]
            **Mandatory if templateId is used containing the {{ update_profile }} tag**. Enter an update profile form id. The form id is a 24 digit alphanumeric id that can be found in the URL when editing the form. If not entered, then the default update profile form will be used.

        utm_campaign : typing.Optional[str]
            Customize the utm_campaign value. If this field is empty, the campaign name will be used. Only alphanumeric characters and spaces are allowed

        winner_criteria : typing.Optional[CreateEmailCampaignRequestWinnerCriteria]
            Choose the metrics that will determinate the winning version. **Mandatory if _splitRule_ >= 1 and < 50**. If splitRule = 50, `winnerCriteria` is ignored if passed

        winner_delay : typing.Optional[int]
            Choose the duration of the test in hours. Maximum is 7 days, pass 24*7 = 168 hours. The winning version will be sent at the end of the test. **Mandatory if _splitRule_ >= 1 and < 50**. If splitRule = 50, `winnerDelay` is ignored if passed

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[CreateEmailCampaignResponse]
            successfully created
        """
        _response = self._client_wrapper.httpx_client.request(
            "emailCampaigns",
            method="POST",
            json={
                "abTesting": ab_testing,
                "attachmentUrl": attachment_url,
                "emailExpirationDate": convert_and_respect_annotation_metadata(
                    object_=email_expiration_date,
                    annotation=CreateEmailCampaignRequestEmailExpirationDate,
                    direction="write",
                ),
                "footer": footer,
                "header": header,
                "htmlContent": html_content,
                "htmlUrl": html_url,
                "increaseRate": increase_rate,
                "initialQuota": initial_quota,
                "inlineImageActivation": inline_image_activation,
                "ipWarmupEnable": ip_warmup_enable,
                "mirrorActive": mirror_active,
                "name": name,
                "params": params,
                "previewText": preview_text,
                "recipients": convert_and_respect_annotation_metadata(
                    object_=recipients, annotation=CreateEmailCampaignRequestRecipients, direction="write"
                ),
                "replyTo": reply_to,
                "scheduledAt": scheduled_at,
                "sendAtBestTime": send_at_best_time,
                "sender": convert_and_respect_annotation_metadata(
                    object_=sender, annotation=CreateEmailCampaignRequestSender, direction="write"
                ),
                "splitRule": split_rule,
                "subject": subject,
                "subjectA": subject_a,
                "subjectB": subject_b,
                "tag": tag,
                "templateId": template_id,
                "toField": to_field,
                "unsubscriptionPageId": unsubscription_page_id,
                "updateFormId": update_form_id,
                "utmCampaign": utm_campaign,
                "winnerCriteria": winner_criteria,
                "winnerDelay": winner_delay,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CreateEmailCampaignResponse,
                    construct_type(
                        type_=CreateEmailCampaignResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def upload_image_to_gallery(
        self,
        *,
        image_url: str,
        name: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[UploadImageToGalleryResponse]:
        """
        Parameters
        ----------
        image_url : str
            The absolute url of the image (**no local file**). Maximum allowed size for image is **2MB**. Allowed extensions for images are: #### jpeg, jpg, png, bmp, gif.

        name : typing.Optional[str]
            Name of the image.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[UploadImageToGalleryResponse]
            Image has been successfully uploaded
        """
        _response = self._client_wrapper.httpx_client.request(
            "emailCampaigns/images",
            method="POST",
            json={
                "imageUrl": image_url,
                "name": name,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    UploadImageToGalleryResponse,
                    construct_type(
                        type_=UploadImageToGalleryResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_email_campaign(
        self,
        campaign_id: int,
        *,
        statistics: typing.Optional[GetEmailCampaignRequestStatistics] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[GetEmailCampaignResponse]:
        """
        Parameters
        ----------
        campaign_id : int
            Id of the campaign

        statistics : typing.Optional[GetEmailCampaignRequestStatistics]
            Filter on type of the statistics required. Example **globalStats** value will only fetch globalStats info of the campaign in returned response.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetEmailCampaignResponse]
            Email campaign informations
        """
        _response = self._client_wrapper.httpx_client.request(
            f"emailCampaigns/{jsonable_encoder(campaign_id)}",
            method="GET",
            params={
                "statistics": statistics,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetEmailCampaignResponse,
                    construct_type(
                        type_=GetEmailCampaignResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def update_email_campaign(
        self,
        campaign_id: int,
        *,
        ab_testing: typing.Optional[bool] = OMIT,
        attachment_url: typing.Optional[str] = OMIT,
        email_expiration_date: typing.Optional[UpdateEmailCampaignRequestEmailExpirationDate] = OMIT,
        footer: typing.Optional[str] = OMIT,
        header: typing.Optional[str] = OMIT,
        html_content: typing.Optional[str] = OMIT,
        html_url: typing.Optional[str] = OMIT,
        increase_rate: typing.Optional[int] = OMIT,
        initial_quota: typing.Optional[int] = OMIT,
        inline_image_activation: typing.Optional[bool] = OMIT,
        ip_warmup_enable: typing.Optional[bool] = OMIT,
        mirror_active: typing.Optional[bool] = OMIT,
        name: typing.Optional[str] = OMIT,
        params: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        preview_text: typing.Optional[str] = OMIT,
        recipients: typing.Optional[UpdateEmailCampaignRequestRecipients] = OMIT,
        recurring: typing.Optional[bool] = OMIT,
        reply_to: typing.Optional[str] = OMIT,
        scheduled_at: typing.Optional[str] = OMIT,
        send_at_best_time: typing.Optional[bool] = OMIT,
        sender: typing.Optional[UpdateEmailCampaignRequestSender] = OMIT,
        split_rule: typing.Optional[int] = OMIT,
        subject: typing.Optional[str] = OMIT,
        subject_a: typing.Optional[str] = OMIT,
        subject_b: typing.Optional[str] = OMIT,
        tag: typing.Optional[str] = OMIT,
        to_field: typing.Optional[str] = OMIT,
        unsubscription_page_id: typing.Optional[str] = OMIT,
        update_form_id: typing.Optional[str] = OMIT,
        utm_campaign: typing.Optional[str] = OMIT,
        winner_criteria: typing.Optional[UpdateEmailCampaignRequestWinnerCriteria] = OMIT,
        winner_delay: typing.Optional[int] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        campaign_id : int
            Id of the campaign

        ab_testing : typing.Optional[bool]
            Status of A/B Test. abTesting = false means it is disabled & abTesting = true means it is enabled. **subjectA, subjectB, splitRule, winnerCriteria & winnerDelay** will be considered when abTesting is set to true. subjectA & subjectB are mandatory together & subject if passed is ignored. **Can be set to true only if sendAtBestTime is false**. You will be able to set up two subject lines for your campaign and send them to a random sample of your total recipients. Half of the test group will receive version A, and the other half will receive version B

        attachment_url : typing.Optional[str]
            Absolute url of the attachment (no local file). Extension allowed: #### xlsx, xls, ods, docx, docm, doc, csv, pdf, txt, gif, jpg, jpeg, png, tif, tiff, rtf, bmp, cgm, css, shtml, html, htm, zip, xml, ppt, pptx, tar, ez, ics, mobi, msg, pub and eps'

        email_expiration_date : typing.Optional[UpdateEmailCampaignRequestEmailExpirationDate]
            To reduce your carbon footprint, set an expiration date for your email. If supported, it will be automatically deleted from the recipient’s inbox, saving storage space and energy.

        footer : typing.Optional[str]
            Footer of the email campaign

        header : typing.Optional[str]
            Header of the email campaign

        html_content : typing.Optional[str]
            Body of the message (HTML version). If the campaign is designed using Drag & Drop editor via HTML content, then the design page will not have Drag & Drop editor access for that campaign. **REQUIRED if htmlUrl is empty**

        html_url : typing.Optional[str]
            Url which contents the body of the email message. **REQUIRED if htmlContent is empty**

        increase_rate : typing.Optional[int]
            Set a percentage increase rate for warming up your ip. We recommend you set the increase rate to 30% per day. If you want to send the same number of emails every day, set the daily increase value to 0%.

        initial_quota : typing.Optional[int]
            Set an initial quota greater than 1 for warming up your ip. We recommend you set a value of 3000.

        inline_image_activation : typing.Optional[bool]
            Status of inline image. inlineImageActivation = false means image can’t be embedded, & inlineImageActivation = true means image can be embedded, in the email. You cannot send a campaign of more than **4MB** with images embedded in the email. Campaigns with the images embedded in the email _must be sent to less than 5000 contacts_.

        ip_warmup_enable : typing.Optional[bool]
            **Available for dedicated ip clients**. Set this to true if you wish to warm up your ip.

        mirror_active : typing.Optional[bool]
            Status of mirror links in campaign. mirrorActive = false means mirror links are deactivated, & mirrorActive = true means mirror links are activated, in the campaign

        name : typing.Optional[str]
            Name of the campaign

        params : typing.Optional[typing.Dict[str, typing.Any]]
            Pass the set of attributes to customize the type classic campaign. For example: **{"FNAME":"Joe", "LNAME":"Doe"}**. Only available if **type** is **classic**. It's considered only if campaign is in _New Template Language format_. The New Template Language is dependent on the values of **subject, htmlContent/htmlUrl, sender.name & toField**

        preview_text : typing.Optional[str]
            Preview text or preheader of the email campaign

        recipients : typing.Optional[UpdateEmailCampaignRequestRecipients]
            Segment ids and List ids to include/exclude from campaign

        recurring : typing.Optional[bool]
            **FOR TRIGGER ONLY !** Type of trigger campaign.recurring = false means contact can receive the same Trigger campaign only once, & recurring = true means contact can receive the same Trigger campaign several times

        reply_to : typing.Optional[str]
            Email on which campaign recipients will be able to reply to

        scheduled_at : typing.Optional[str]
            UTC date-time on which the campaign has to run (YYYY-MM-DDTHH:mm:ss.SSSZ). **Prefer to pass your timezone in date-time format for accurate result.** If sendAtBestTime is set to true, your campaign will be sent according to the date passed (ignoring the time part).

        send_at_best_time : typing.Optional[bool]
            Set this to true if you want to send your campaign at best time. Note:- **if true, warmup ip will be disabled.**

        sender : typing.Optional[UpdateEmailCampaignRequestSender]
            Sender details including id or email and name (optional). Only one of either Sender's email or Sender's ID shall be passed in one request at a time. For example: **{"name":"xyz", "email":"example@abc.com"}** **{"name":"xyz", "id":123}**

        split_rule : typing.Optional[int]
            Add the size of your test groups. **Mandatory if abTesting = true & 'recipients' is passed**. We'll send version A and B to a random sample of recipients, and then the winning version to everyone else

        subject : typing.Optional[str]
            Subject of the campaign

        subject_a : typing.Optional[str]
            Subject A of the campaign. **Mandatory if abTesting = true**. subjectA & subjectB should have unique value

        subject_b : typing.Optional[str]
            Subject B of the campaign. **Mandatory if abTesting = true**. subjectA & subjectB should have unique value

        tag : typing.Optional[str]
            Tag of the campaign

        to_field : typing.Optional[str]
            To personalize the **To** Field. If you want to include the first name and last name of your recipient, add **{FNAME} {LNAME}**. These contact attributes must already exist in your Brevo account. If input parameter **params** used please use **{{contact.FNAME}} {{contact.LNAME}}** for personalization

        unsubscription_page_id : typing.Optional[str]
            Enter an unsubscription page id. The page id is a 24 digit alphanumeric id that can be found in the URL when editing the page.

        update_form_id : typing.Optional[str]
            **Mandatory if templateId is used containing the {{ update_profile }} tag**. Enter an update profile form id. The form id is a 24 digit alphanumeric id that can be found in the URL when editing the form.

        utm_campaign : typing.Optional[str]
            Customize the utm_campaign value. If this field is empty, the campaign name will be used. Only alphanumeric characters and spaces are allowed

        winner_criteria : typing.Optional[UpdateEmailCampaignRequestWinnerCriteria]
            Choose the metrics that will determinate the winning version. **Mandatory if _splitRule_ >= 1 and < 50**. If splitRule = 50, `winnerCriteria` is ignored if passed

        winner_delay : typing.Optional[int]
            Choose the duration of the test in hours. Maximum is 7 days, pass 24*7 = 168 hours. The winning version will be sent at the end of the test. **Mandatory if _splitRule_ >= 1 and < 50**. If splitRule = 50, `winnerDelay` is ignored if passed

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"emailCampaigns/{jsonable_encoder(campaign_id)}",
            method="PUT",
            json={
                "abTesting": ab_testing,
                "attachmentUrl": attachment_url,
                "emailExpirationDate": convert_and_respect_annotation_metadata(
                    object_=email_expiration_date,
                    annotation=UpdateEmailCampaignRequestEmailExpirationDate,
                    direction="write",
                ),
                "footer": footer,
                "header": header,
                "htmlContent": html_content,
                "htmlUrl": html_url,
                "increaseRate": increase_rate,
                "initialQuota": initial_quota,
                "inlineImageActivation": inline_image_activation,
                "ipWarmupEnable": ip_warmup_enable,
                "mirrorActive": mirror_active,
                "name": name,
                "params": params,
                "previewText": preview_text,
                "recipients": convert_and_respect_annotation_metadata(
                    object_=recipients, annotation=UpdateEmailCampaignRequestRecipients, direction="write"
                ),
                "recurring": recurring,
                "replyTo": reply_to,
                "scheduledAt": scheduled_at,
                "sendAtBestTime": send_at_best_time,
                "sender": convert_and_respect_annotation_metadata(
                    object_=sender, annotation=UpdateEmailCampaignRequestSender, direction="write"
                ),
                "splitRule": split_rule,
                "subject": subject,
                "subjectA": subject_a,
                "subjectB": subject_b,
                "tag": tag,
                "toField": to_field,
                "unsubscriptionPageId": unsubscription_page_id,
                "updateFormId": update_form_id,
                "utmCampaign": utm_campaign,
                "winnerCriteria": winner_criteria,
                "winnerDelay": winner_delay,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def delete_email_campaign(
        self, campaign_id: int, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        campaign_id : int
            id of the campaign

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"emailCampaigns/{jsonable_encoder(campaign_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_ab_test_campaign_result(
        self, campaign_id: int, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[GetAbTestCampaignResultResponse]:
        """
        Obtain winning version of an A/B test email campaign

        Parameters
        ----------
        campaign_id : int
            Id of the A/B test campaign

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetAbTestCampaignResultResponse]
            A/B test email campaign Result
        """
        _response = self._client_wrapper.httpx_client.request(
            f"emailCampaigns/{jsonable_encoder(campaign_id)}/abTestCampaignResult",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetAbTestCampaignResultResponse,
                    construct_type(
                        type_=GetAbTestCampaignResultResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def email_export_recipients(
        self,
        campaign_id: int,
        *,
        recipients_type: EmailExportRecipientsRequestRecipientsType,
        notify_url: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[EmailExportRecipientsResponse]:
        """
        Parameters
        ----------
        campaign_id : int
            Id of the campaign

        recipients_type : EmailExportRecipientsRequestRecipientsType
            Type of recipients to export for a campaign

        notify_url : typing.Optional[str]
            Webhook called once the export process is finished. For reference, https://help.brevo.com/hc/en-us/articles/360007666479

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[EmailExportRecipientsResponse]
            process id created
        """
        _response = self._client_wrapper.httpx_client.request(
            f"emailCampaigns/{jsonable_encoder(campaign_id)}/exportRecipients",
            method="POST",
            json={
                "notifyURL": notify_url,
                "recipientsType": recipients_type,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EmailExportRecipientsResponse,
                    construct_type(
                        type_=EmailExportRecipientsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def send_email_campaign_now(
        self, campaign_id: int, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        campaign_id : int
            Id of the campaign

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"emailCampaigns/{jsonable_encoder(campaign_id)}/sendNow",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 402:
                raise PaymentRequiredError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorModel,
                        construct_type(
                            type_=ErrorModel,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def send_report(
        self,
        campaign_id: int,
        *,
        email: SendReportEmail,
        language: typing.Optional[SendReportLanguage] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        A PDF will be sent to the specified email addresses

        Parameters
        ----------
        campaign_id : int
            Id of the campaign

        email : SendReportEmail
            Custom attributes for the report email.

        language : typing.Optional[SendReportLanguage]
            Language of email content for campaign report sending.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"emailCampaigns/{jsonable_encoder(campaign_id)}/sendReport",
            method="POST",
            json={
                "email": convert_and_respect_annotation_metadata(
                    object_=email, annotation=SendReportEmail, direction="write"
                ),
                "language": language,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def send_test_email(
        self,
        campaign_id: int,
        *,
        email_to: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        campaign_id : int
            Id of the campaign

        email_to : typing.Optional[typing.Sequence[str]]
            List of the email addresses of the recipients whom you wish to send the test mail. _If left empty, the test mail will be sent to your entire test list. You can not send more than 50 test emails per day_.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"emailCampaigns/{jsonable_encoder(campaign_id)}/sendTest",
            method="POST",
            json={
                "emailTo": email_to,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_shared_template_url(
        self, campaign_id: int, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[GetSharedTemplateUrlResponse]:
        """
        Get a unique URL to share & import an email template from one Brevo account to another.

        Parameters
        ----------
        campaign_id : int
            Id of the campaign or template

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetSharedTemplateUrlResponse]
            Shared template URL information
        """
        _response = self._client_wrapper.httpx_client.request(
            f"emailCampaigns/{jsonable_encoder(campaign_id)}/sharedUrl",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetSharedTemplateUrlResponse,
                    construct_type(
                        type_=GetSharedTemplateUrlResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 405:
                raise MethodNotAllowedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorModel,
                        construct_type(
                            type_=ErrorModel,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def update_campaign_status(
        self,
        campaign_id: int,
        *,
        status: typing.Optional[UpdateCampaignStatusStatus] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        campaign_id : int
            Id of the campaign

        status : typing.Optional[UpdateCampaignStatusStatus]
            Note:- **replicateTemplate** status will be available **only for template type campaigns.**

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"emailCampaigns/{jsonable_encoder(campaign_id)}/status",
            method="PUT",
            json={
                "status": status,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawEmailCampaignsClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def get_email_campaigns(
        self,
        *,
        type: typing.Optional[GetEmailCampaignsRequestType] = None,
        status: typing.Optional[GetEmailCampaignsRequestStatus] = None,
        statistics: typing.Optional[GetEmailCampaignsRequestStatistics] = None,
        start_date: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        limit: typing.Optional[int] = None,
        offset: typing.Optional[int] = None,
        sort: typing.Optional[GetEmailCampaignsRequestSort] = None,
        exclude_html_content: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[GetEmailCampaignsResponse]:
        """
        <Note>
        The response payload for this endpoint has changed

        You now need to specify which type of statistics you would like to retrieve. For more information visit [this page](https://developers.brevo.com/changelog/get-all-marketing-campaigns).
        </Note>

        Parameters
        ----------
        type : typing.Optional[GetEmailCampaignsRequestType]
            Filter on the type of the campaigns

        status : typing.Optional[GetEmailCampaignsRequestStatus]
            Filter on the status of the campaign

        statistics : typing.Optional[GetEmailCampaignsRequestStatistics]
            Filter on type of the statistics required. Example **globalStats** value will only fetch globalStats info of the campaign in returned response.This option only returns data for events occurred in the last 6 months.For older campaigns, it’s advisable to use the **Get Campaign Report** endpoint.

        start_date : typing.Optional[str]
            **Mandatory if endDate is used**. Starting (urlencoded) UTC date-time (YYYY-MM-DDTHH:mm:ss.SSSZ) to filter the sent email campaigns. **Prefer to pass your timezone in date-time format for accurate result** ( only available if either 'status' not passed and if passed is set to 'sent' )

        end_date : typing.Optional[str]
            **Mandatory if startDate is used**. Ending (urlencoded) UTC date-time (YYYY-MM-DDTHH:mm:ss.SSSZ) to filter the sent email campaigns. **Prefer to pass your timezone in date-time format for accurate result** ( only available if either 'status' not passed and if passed is set to 'sent' )

        limit : typing.Optional[int]
            Number of documents per page

        offset : typing.Optional[int]
            Index of the first document in the page

        sort : typing.Optional[GetEmailCampaignsRequestSort]
            Sort the results in the ascending/descending order of record creation. Default order is **descending** if `sort` is not passed

        exclude_html_content : typing.Optional[bool]
            Use this flag to exclude htmlContent from the response body. If set to **true**, htmlContent field will be returned as empty string in the response body

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetEmailCampaignsResponse]
            Email campaigns informations
        """
        _response = await self._client_wrapper.httpx_client.request(
            "emailCampaigns",
            method="GET",
            params={
                "type": type,
                "status": status,
                "statistics": statistics,
                "startDate": start_date,
                "endDate": end_date,
                "limit": limit,
                "offset": offset,
                "sort": sort,
                "excludeHtmlContent": exclude_html_content,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetEmailCampaignsResponse,
                    construct_type(
                        type_=GetEmailCampaignsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def create_email_campaign(
        self,
        *,
        name: str,
        sender: CreateEmailCampaignRequestSender,
        ab_testing: typing.Optional[bool] = OMIT,
        attachment_url: typing.Optional[str] = OMIT,
        email_expiration_date: typing.Optional[CreateEmailCampaignRequestEmailExpirationDate] = OMIT,
        footer: typing.Optional[str] = OMIT,
        header: typing.Optional[str] = OMIT,
        html_content: typing.Optional[str] = OMIT,
        html_url: typing.Optional[str] = OMIT,
        increase_rate: typing.Optional[int] = OMIT,
        initial_quota: typing.Optional[int] = OMIT,
        inline_image_activation: typing.Optional[bool] = OMIT,
        ip_warmup_enable: typing.Optional[bool] = OMIT,
        mirror_active: typing.Optional[bool] = OMIT,
        params: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        preview_text: typing.Optional[str] = OMIT,
        recipients: typing.Optional[CreateEmailCampaignRequestRecipients] = OMIT,
        reply_to: typing.Optional[str] = OMIT,
        scheduled_at: typing.Optional[str] = OMIT,
        send_at_best_time: typing.Optional[bool] = OMIT,
        split_rule: typing.Optional[int] = OMIT,
        subject: typing.Optional[str] = OMIT,
        subject_a: typing.Optional[str] = OMIT,
        subject_b: typing.Optional[str] = OMIT,
        tag: typing.Optional[str] = OMIT,
        template_id: typing.Optional[int] = OMIT,
        to_field: typing.Optional[str] = OMIT,
        unsubscription_page_id: typing.Optional[str] = OMIT,
        update_form_id: typing.Optional[str] = OMIT,
        utm_campaign: typing.Optional[str] = OMIT,
        winner_criteria: typing.Optional[CreateEmailCampaignRequestWinnerCriteria] = OMIT,
        winner_delay: typing.Optional[int] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[CreateEmailCampaignResponse]:
        """
        Parameters
        ----------
        name : str
            Name of the campaign

        sender : CreateEmailCampaignRequestSender
            Sender details including id or email and name (_optional_). Only one of either Sender's email or Sender's ID shall be passed in one request at a time. For example: **{"name":"xyz", "email":"example@abc.com"}** **{"name":"xyz", "id":123}**

        ab_testing : typing.Optional[bool]
            Status of A/B Test. abTesting = false means it is disabled & abTesting = true means it is enabled. **subjectA, subjectB, splitRule, winnerCriteria & winnerDelay** will be considered when abTesting is set to true. subjectA & subjectB are mandatory together & subject if passed is ignored. **Can be set to true only if sendAtBestTime is false**. You will be able to set up two subject lines for your campaign and send them to a random sample of your total recipients. Half of the test group will receive version A, and the other half will receive version B

        attachment_url : typing.Optional[str]
            Absolute url of the attachment (no local file). Extension allowed: #### xlsx, xls, ods, docx, docm, doc, csv, pdf, txt, gif, jpg, jpeg, png, tif, tiff, rtf, bmp, cgm, css, shtml, html, htm, zip, xml, ppt, pptx, tar, ez, ics, mobi, msg, pub and eps

        email_expiration_date : typing.Optional[CreateEmailCampaignRequestEmailExpirationDate]
            To reduce your carbon footprint, set an expiration date for your email. If supported, it will be automatically deleted from the recipient’s inbox, saving storage space and energy. Learn more about setting an email expiration date. For reference , ``https://help.brevo.com/hc/en-us/articles/4413566705298-Create-an-email-campaign``

        footer : typing.Optional[str]
            Footer of the email campaign

        header : typing.Optional[str]
            Header of the email campaign

        html_content : typing.Optional[str]
            Mandatory if htmlUrl and templateId are empty. Body of the message (HTML).

        html_url : typing.Optional[str]
            **Mandatory if htmlContent and templateId are empty**. Url to the message (HTML). For example: **https://html.domain.com**

        increase_rate : typing.Optional[int]
            **Mandatory if ipWarmupEnable is set to true**. Set a percentage increase rate for warming up your ip. We recommend you set the increase rate to 30% per day. If you want to send the same number of emails every day, set the daily increase value to 0%.

        initial_quota : typing.Optional[int]
            **Mandatory if ipWarmupEnable is set to true**. Set an initial quota greater than 1 for warming up your ip. We recommend you set a value of 3000.

        inline_image_activation : typing.Optional[bool]
            Use true to embedded the images in your email. Final size of the email should be less than **4MB**. Campaigns with embedded images can _not be sent to more than 5000 contacts_

        ip_warmup_enable : typing.Optional[bool]
            **Available for dedicated ip clients**. Set this to true if you wish to warm up your ip.

        mirror_active : typing.Optional[bool]
            Use true to enable the mirror link

        params : typing.Optional[typing.Dict[str, typing.Any]]
            Pass the set of attributes to customize the type classic campaign. For example: **{"FNAME":"Joe", "LNAME":"Doe"}**. Only available if **type** is **classic**. It's considered only if campaign is in _New Template Language format_. The New Template Language is dependent on the values of **subject, htmlContent/htmlUrl, sender.name & toField**

        preview_text : typing.Optional[str]
            Preview text or preheader of the email campaign

        recipients : typing.Optional[CreateEmailCampaignRequestRecipients]
            Segment ids and List ids to include/exclude from campaign

        reply_to : typing.Optional[str]
            Email on which the campaign recipients will be able to reply to

        scheduled_at : typing.Optional[str]
            Sending UTC date-time (YYYY-MM-DDTHH:mm:ss.SSSZ). **Prefer to pass your timezone in date-time format for accurate result**. If sendAtBestTime is set to true, your campaign will be sent according to the date passed (ignoring the time part). For example: **2017-06-01T12:30:00+02:00**

        send_at_best_time : typing.Optional[bool]
            Set this to true if you want to send your campaign at best time.

        split_rule : typing.Optional[int]
            Add the size of your test groups. **Mandatory if abTesting = true & 'recipients' is passed**. We'll send version A and B to a random sample of recipients, and then the winning version to everyone else

        subject : typing.Optional[str]
            Subject of the campaign. **Mandatory if abTesting is false**. Ignored if abTesting is true.

        subject_a : typing.Optional[str]
            Subject A of the campaign. **Mandatory if abTesting = true**. subjectA & subjectB should have unique value

        subject_b : typing.Optional[str]
            Subject B of the campaign. **Mandatory if abTesting = true**. subjectA & subjectB should have unique value

        tag : typing.Optional[str]
            Tag of the campaign

        template_id : typing.Optional[int]
            **Mandatory if htmlContent and htmlUrl are empty**. Id of the transactional email template with status _active_. Used to copy only its content fetched from htmlContent/htmlUrl to an email campaign for RSS feature.

        to_field : typing.Optional[str]
            To personalize the **To** Field. If you want to include the first name and last name of your recipient, add **{FNAME} {LNAME}**. These contact attributes must already exist in your Brevo account. If input parameter **params** used please use **{{contact.FNAME}} {{contact.LNAME}}** for personalization

        unsubscription_page_id : typing.Optional[str]
            Enter an unsubscription page id. The page id is a 24 digit alphanumeric id that can be found in the URL when editing the page. If not entered, then the default unsubscription page will be used.

        update_form_id : typing.Optional[str]
            **Mandatory if templateId is used containing the {{ update_profile }} tag**. Enter an update profile form id. The form id is a 24 digit alphanumeric id that can be found in the URL when editing the form. If not entered, then the default update profile form will be used.

        utm_campaign : typing.Optional[str]
            Customize the utm_campaign value. If this field is empty, the campaign name will be used. Only alphanumeric characters and spaces are allowed

        winner_criteria : typing.Optional[CreateEmailCampaignRequestWinnerCriteria]
            Choose the metrics that will determinate the winning version. **Mandatory if _splitRule_ >= 1 and < 50**. If splitRule = 50, `winnerCriteria` is ignored if passed

        winner_delay : typing.Optional[int]
            Choose the duration of the test in hours. Maximum is 7 days, pass 24*7 = 168 hours. The winning version will be sent at the end of the test. **Mandatory if _splitRule_ >= 1 and < 50**. If splitRule = 50, `winnerDelay` is ignored if passed

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[CreateEmailCampaignResponse]
            successfully created
        """
        _response = await self._client_wrapper.httpx_client.request(
            "emailCampaigns",
            method="POST",
            json={
                "abTesting": ab_testing,
                "attachmentUrl": attachment_url,
                "emailExpirationDate": convert_and_respect_annotation_metadata(
                    object_=email_expiration_date,
                    annotation=CreateEmailCampaignRequestEmailExpirationDate,
                    direction="write",
                ),
                "footer": footer,
                "header": header,
                "htmlContent": html_content,
                "htmlUrl": html_url,
                "increaseRate": increase_rate,
                "initialQuota": initial_quota,
                "inlineImageActivation": inline_image_activation,
                "ipWarmupEnable": ip_warmup_enable,
                "mirrorActive": mirror_active,
                "name": name,
                "params": params,
                "previewText": preview_text,
                "recipients": convert_and_respect_annotation_metadata(
                    object_=recipients, annotation=CreateEmailCampaignRequestRecipients, direction="write"
                ),
                "replyTo": reply_to,
                "scheduledAt": scheduled_at,
                "sendAtBestTime": send_at_best_time,
                "sender": convert_and_respect_annotation_metadata(
                    object_=sender, annotation=CreateEmailCampaignRequestSender, direction="write"
                ),
                "splitRule": split_rule,
                "subject": subject,
                "subjectA": subject_a,
                "subjectB": subject_b,
                "tag": tag,
                "templateId": template_id,
                "toField": to_field,
                "unsubscriptionPageId": unsubscription_page_id,
                "updateFormId": update_form_id,
                "utmCampaign": utm_campaign,
                "winnerCriteria": winner_criteria,
                "winnerDelay": winner_delay,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CreateEmailCampaignResponse,
                    construct_type(
                        type_=CreateEmailCampaignResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def upload_image_to_gallery(
        self,
        *,
        image_url: str,
        name: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[UploadImageToGalleryResponse]:
        """
        Parameters
        ----------
        image_url : str
            The absolute url of the image (**no local file**). Maximum allowed size for image is **2MB**. Allowed extensions for images are: #### jpeg, jpg, png, bmp, gif.

        name : typing.Optional[str]
            Name of the image.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[UploadImageToGalleryResponse]
            Image has been successfully uploaded
        """
        _response = await self._client_wrapper.httpx_client.request(
            "emailCampaigns/images",
            method="POST",
            json={
                "imageUrl": image_url,
                "name": name,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    UploadImageToGalleryResponse,
                    construct_type(
                        type_=UploadImageToGalleryResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_email_campaign(
        self,
        campaign_id: int,
        *,
        statistics: typing.Optional[GetEmailCampaignRequestStatistics] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[GetEmailCampaignResponse]:
        """
        Parameters
        ----------
        campaign_id : int
            Id of the campaign

        statistics : typing.Optional[GetEmailCampaignRequestStatistics]
            Filter on type of the statistics required. Example **globalStats** value will only fetch globalStats info of the campaign in returned response.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetEmailCampaignResponse]
            Email campaign informations
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"emailCampaigns/{jsonable_encoder(campaign_id)}",
            method="GET",
            params={
                "statistics": statistics,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetEmailCampaignResponse,
                    construct_type(
                        type_=GetEmailCampaignResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def update_email_campaign(
        self,
        campaign_id: int,
        *,
        ab_testing: typing.Optional[bool] = OMIT,
        attachment_url: typing.Optional[str] = OMIT,
        email_expiration_date: typing.Optional[UpdateEmailCampaignRequestEmailExpirationDate] = OMIT,
        footer: typing.Optional[str] = OMIT,
        header: typing.Optional[str] = OMIT,
        html_content: typing.Optional[str] = OMIT,
        html_url: typing.Optional[str] = OMIT,
        increase_rate: typing.Optional[int] = OMIT,
        initial_quota: typing.Optional[int] = OMIT,
        inline_image_activation: typing.Optional[bool] = OMIT,
        ip_warmup_enable: typing.Optional[bool] = OMIT,
        mirror_active: typing.Optional[bool] = OMIT,
        name: typing.Optional[str] = OMIT,
        params: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        preview_text: typing.Optional[str] = OMIT,
        recipients: typing.Optional[UpdateEmailCampaignRequestRecipients] = OMIT,
        recurring: typing.Optional[bool] = OMIT,
        reply_to: typing.Optional[str] = OMIT,
        scheduled_at: typing.Optional[str] = OMIT,
        send_at_best_time: typing.Optional[bool] = OMIT,
        sender: typing.Optional[UpdateEmailCampaignRequestSender] = OMIT,
        split_rule: typing.Optional[int] = OMIT,
        subject: typing.Optional[str] = OMIT,
        subject_a: typing.Optional[str] = OMIT,
        subject_b: typing.Optional[str] = OMIT,
        tag: typing.Optional[str] = OMIT,
        to_field: typing.Optional[str] = OMIT,
        unsubscription_page_id: typing.Optional[str] = OMIT,
        update_form_id: typing.Optional[str] = OMIT,
        utm_campaign: typing.Optional[str] = OMIT,
        winner_criteria: typing.Optional[UpdateEmailCampaignRequestWinnerCriteria] = OMIT,
        winner_delay: typing.Optional[int] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        campaign_id : int
            Id of the campaign

        ab_testing : typing.Optional[bool]
            Status of A/B Test. abTesting = false means it is disabled & abTesting = true means it is enabled. **subjectA, subjectB, splitRule, winnerCriteria & winnerDelay** will be considered when abTesting is set to true. subjectA & subjectB are mandatory together & subject if passed is ignored. **Can be set to true only if sendAtBestTime is false**. You will be able to set up two subject lines for your campaign and send them to a random sample of your total recipients. Half of the test group will receive version A, and the other half will receive version B

        attachment_url : typing.Optional[str]
            Absolute url of the attachment (no local file). Extension allowed: #### xlsx, xls, ods, docx, docm, doc, csv, pdf, txt, gif, jpg, jpeg, png, tif, tiff, rtf, bmp, cgm, css, shtml, html, htm, zip, xml, ppt, pptx, tar, ez, ics, mobi, msg, pub and eps'

        email_expiration_date : typing.Optional[UpdateEmailCampaignRequestEmailExpirationDate]
            To reduce your carbon footprint, set an expiration date for your email. If supported, it will be automatically deleted from the recipient’s inbox, saving storage space and energy.

        footer : typing.Optional[str]
            Footer of the email campaign

        header : typing.Optional[str]
            Header of the email campaign

        html_content : typing.Optional[str]
            Body of the message (HTML version). If the campaign is designed using Drag & Drop editor via HTML content, then the design page will not have Drag & Drop editor access for that campaign. **REQUIRED if htmlUrl is empty**

        html_url : typing.Optional[str]
            Url which contents the body of the email message. **REQUIRED if htmlContent is empty**

        increase_rate : typing.Optional[int]
            Set a percentage increase rate for warming up your ip. We recommend you set the increase rate to 30% per day. If you want to send the same number of emails every day, set the daily increase value to 0%.

        initial_quota : typing.Optional[int]
            Set an initial quota greater than 1 for warming up your ip. We recommend you set a value of 3000.

        inline_image_activation : typing.Optional[bool]
            Status of inline image. inlineImageActivation = false means image can’t be embedded, & inlineImageActivation = true means image can be embedded, in the email. You cannot send a campaign of more than **4MB** with images embedded in the email. Campaigns with the images embedded in the email _must be sent to less than 5000 contacts_.

        ip_warmup_enable : typing.Optional[bool]
            **Available for dedicated ip clients**. Set this to true if you wish to warm up your ip.

        mirror_active : typing.Optional[bool]
            Status of mirror links in campaign. mirrorActive = false means mirror links are deactivated, & mirrorActive = true means mirror links are activated, in the campaign

        name : typing.Optional[str]
            Name of the campaign

        params : typing.Optional[typing.Dict[str, typing.Any]]
            Pass the set of attributes to customize the type classic campaign. For example: **{"FNAME":"Joe", "LNAME":"Doe"}**. Only available if **type** is **classic**. It's considered only if campaign is in _New Template Language format_. The New Template Language is dependent on the values of **subject, htmlContent/htmlUrl, sender.name & toField**

        preview_text : typing.Optional[str]
            Preview text or preheader of the email campaign

        recipients : typing.Optional[UpdateEmailCampaignRequestRecipients]
            Segment ids and List ids to include/exclude from campaign

        recurring : typing.Optional[bool]
            **FOR TRIGGER ONLY !** Type of trigger campaign.recurring = false means contact can receive the same Trigger campaign only once, & recurring = true means contact can receive the same Trigger campaign several times

        reply_to : typing.Optional[str]
            Email on which campaign recipients will be able to reply to

        scheduled_at : typing.Optional[str]
            UTC date-time on which the campaign has to run (YYYY-MM-DDTHH:mm:ss.SSSZ). **Prefer to pass your timezone in date-time format for accurate result.** If sendAtBestTime is set to true, your campaign will be sent according to the date passed (ignoring the time part).

        send_at_best_time : typing.Optional[bool]
            Set this to true if you want to send your campaign at best time. Note:- **if true, warmup ip will be disabled.**

        sender : typing.Optional[UpdateEmailCampaignRequestSender]
            Sender details including id or email and name (optional). Only one of either Sender's email or Sender's ID shall be passed in one request at a time. For example: **{"name":"xyz", "email":"example@abc.com"}** **{"name":"xyz", "id":123}**

        split_rule : typing.Optional[int]
            Add the size of your test groups. **Mandatory if abTesting = true & 'recipients' is passed**. We'll send version A and B to a random sample of recipients, and then the winning version to everyone else

        subject : typing.Optional[str]
            Subject of the campaign

        subject_a : typing.Optional[str]
            Subject A of the campaign. **Mandatory if abTesting = true**. subjectA & subjectB should have unique value

        subject_b : typing.Optional[str]
            Subject B of the campaign. **Mandatory if abTesting = true**. subjectA & subjectB should have unique value

        tag : typing.Optional[str]
            Tag of the campaign

        to_field : typing.Optional[str]
            To personalize the **To** Field. If you want to include the first name and last name of your recipient, add **{FNAME} {LNAME}**. These contact attributes must already exist in your Brevo account. If input parameter **params** used please use **{{contact.FNAME}} {{contact.LNAME}}** for personalization

        unsubscription_page_id : typing.Optional[str]
            Enter an unsubscription page id. The page id is a 24 digit alphanumeric id that can be found in the URL when editing the page.

        update_form_id : typing.Optional[str]
            **Mandatory if templateId is used containing the {{ update_profile }} tag**. Enter an update profile form id. The form id is a 24 digit alphanumeric id that can be found in the URL when editing the form.

        utm_campaign : typing.Optional[str]
            Customize the utm_campaign value. If this field is empty, the campaign name will be used. Only alphanumeric characters and spaces are allowed

        winner_criteria : typing.Optional[UpdateEmailCampaignRequestWinnerCriteria]
            Choose the metrics that will determinate the winning version. **Mandatory if _splitRule_ >= 1 and < 50**. If splitRule = 50, `winnerCriteria` is ignored if passed

        winner_delay : typing.Optional[int]
            Choose the duration of the test in hours. Maximum is 7 days, pass 24*7 = 168 hours. The winning version will be sent at the end of the test. **Mandatory if _splitRule_ >= 1 and < 50**. If splitRule = 50, `winnerDelay` is ignored if passed

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"emailCampaigns/{jsonable_encoder(campaign_id)}",
            method="PUT",
            json={
                "abTesting": ab_testing,
                "attachmentUrl": attachment_url,
                "emailExpirationDate": convert_and_respect_annotation_metadata(
                    object_=email_expiration_date,
                    annotation=UpdateEmailCampaignRequestEmailExpirationDate,
                    direction="write",
                ),
                "footer": footer,
                "header": header,
                "htmlContent": html_content,
                "htmlUrl": html_url,
                "increaseRate": increase_rate,
                "initialQuota": initial_quota,
                "inlineImageActivation": inline_image_activation,
                "ipWarmupEnable": ip_warmup_enable,
                "mirrorActive": mirror_active,
                "name": name,
                "params": params,
                "previewText": preview_text,
                "recipients": convert_and_respect_annotation_metadata(
                    object_=recipients, annotation=UpdateEmailCampaignRequestRecipients, direction="write"
                ),
                "recurring": recurring,
                "replyTo": reply_to,
                "scheduledAt": scheduled_at,
                "sendAtBestTime": send_at_best_time,
                "sender": convert_and_respect_annotation_metadata(
                    object_=sender, annotation=UpdateEmailCampaignRequestSender, direction="write"
                ),
                "splitRule": split_rule,
                "subject": subject,
                "subjectA": subject_a,
                "subjectB": subject_b,
                "tag": tag,
                "toField": to_field,
                "unsubscriptionPageId": unsubscription_page_id,
                "updateFormId": update_form_id,
                "utmCampaign": utm_campaign,
                "winnerCriteria": winner_criteria,
                "winnerDelay": winner_delay,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def delete_email_campaign(
        self, campaign_id: int, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        campaign_id : int
            id of the campaign

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"emailCampaigns/{jsonable_encoder(campaign_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_ab_test_campaign_result(
        self, campaign_id: int, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[GetAbTestCampaignResultResponse]:
        """
        Obtain winning version of an A/B test email campaign

        Parameters
        ----------
        campaign_id : int
            Id of the A/B test campaign

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetAbTestCampaignResultResponse]
            A/B test email campaign Result
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"emailCampaigns/{jsonable_encoder(campaign_id)}/abTestCampaignResult",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetAbTestCampaignResultResponse,
                    construct_type(
                        type_=GetAbTestCampaignResultResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def email_export_recipients(
        self,
        campaign_id: int,
        *,
        recipients_type: EmailExportRecipientsRequestRecipientsType,
        notify_url: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[EmailExportRecipientsResponse]:
        """
        Parameters
        ----------
        campaign_id : int
            Id of the campaign

        recipients_type : EmailExportRecipientsRequestRecipientsType
            Type of recipients to export for a campaign

        notify_url : typing.Optional[str]
            Webhook called once the export process is finished. For reference, https://help.brevo.com/hc/en-us/articles/360007666479

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[EmailExportRecipientsResponse]
            process id created
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"emailCampaigns/{jsonable_encoder(campaign_id)}/exportRecipients",
            method="POST",
            json={
                "notifyURL": notify_url,
                "recipientsType": recipients_type,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EmailExportRecipientsResponse,
                    construct_type(
                        type_=EmailExportRecipientsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def send_email_campaign_now(
        self, campaign_id: int, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        campaign_id : int
            Id of the campaign

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"emailCampaigns/{jsonable_encoder(campaign_id)}/sendNow",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 402:
                raise PaymentRequiredError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorModel,
                        construct_type(
                            type_=ErrorModel,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def send_report(
        self,
        campaign_id: int,
        *,
        email: SendReportEmail,
        language: typing.Optional[SendReportLanguage] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        A PDF will be sent to the specified email addresses

        Parameters
        ----------
        campaign_id : int
            Id of the campaign

        email : SendReportEmail
            Custom attributes for the report email.

        language : typing.Optional[SendReportLanguage]
            Language of email content for campaign report sending.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"emailCampaigns/{jsonable_encoder(campaign_id)}/sendReport",
            method="POST",
            json={
                "email": convert_and_respect_annotation_metadata(
                    object_=email, annotation=SendReportEmail, direction="write"
                ),
                "language": language,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def send_test_email(
        self,
        campaign_id: int,
        *,
        email_to: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        campaign_id : int
            Id of the campaign

        email_to : typing.Optional[typing.Sequence[str]]
            List of the email addresses of the recipients whom you wish to send the test mail. _If left empty, the test mail will be sent to your entire test list. You can not send more than 50 test emails per day_.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"emailCampaigns/{jsonable_encoder(campaign_id)}/sendTest",
            method="POST",
            json={
                "emailTo": email_to,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_shared_template_url(
        self, campaign_id: int, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[GetSharedTemplateUrlResponse]:
        """
        Get a unique URL to share & import an email template from one Brevo account to another.

        Parameters
        ----------
        campaign_id : int
            Id of the campaign or template

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetSharedTemplateUrlResponse]
            Shared template URL information
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"emailCampaigns/{jsonable_encoder(campaign_id)}/sharedUrl",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetSharedTemplateUrlResponse,
                    construct_type(
                        type_=GetSharedTemplateUrlResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 405:
                raise MethodNotAllowedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorModel,
                        construct_type(
                            type_=ErrorModel,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def update_campaign_status(
        self,
        campaign_id: int,
        *,
        status: typing.Optional[UpdateCampaignStatusStatus] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        campaign_id : int
            Id of the campaign

        status : typing.Optional[UpdateCampaignStatusStatus]
            Note:- **replicateTemplate** status will be available **only for template type campaigns.**

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"emailCampaigns/{jsonable_encoder(campaign_id)}/status",
            method="PUT",
            json={
                "status": status,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)
