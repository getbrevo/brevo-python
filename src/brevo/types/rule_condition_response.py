# This file was auto-generated by Fern from our API Definition.

from __future__ import annotations

import typing

import pydantic
import typing_extensions
from ..core.pydantic_utilities import IS_PYDANTIC_V2, update_forward_refs
from ..core.serialization import FieldMetadata
from ..core.unchecked_base_model import UncheckedBaseModel


class RuleConditionResponse(UncheckedBaseModel):
    and_: typing_extensions.Annotated[
        typing.Optional[typing.List["RuleConditionResponse"]],
        FieldMetadata(alias="and"),
        pydantic.Field(alias="and", description="Metric to indicate AND between rules"),
    ] = None
    lhs: typing.Optional["ValueResponse"] = pydantic.Field(default=None)
    """
    Condition of the rule
    """

    op: typing.Optional[str] = pydantic.Field(default=None)
    """
    Selected operator for the rule
    """

    or_: typing_extensions.Annotated[
        typing.Optional[typing.List["RuleConditionResponse"]],
        FieldMetadata(alias="or"),
        pydantic.Field(alias="or", description="Metric to indicate OR between rules"),
    ] = None
    rhs: typing.Optional["ValueResponse"] = pydantic.Field(default=None)
    """
    Action of the rule
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


from .value_response import ValueResponse  # noqa: E402, I001

update_forward_refs(RuleConditionResponse, ValueResponse=ValueResponse)
