# This file was auto-generated by Fern from our API Definition.

import typing
from json.decoder import JSONDecodeError

from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.http_response import AsyncHttpResponse, HttpResponse
from ..core.jsonable_encoder import jsonable_encoder
from ..core.request_options import RequestOptions
from ..core.serialization import convert_and_respect_annotation_metadata
from ..core.unchecked_base_model import construct_type
from ..errors.bad_request_error import BadRequestError
from ..errors.expectation_failed_error import ExpectationFailedError
from ..errors.failed_dependency_error import FailedDependencyError
from ..errors.forbidden_error import ForbiddenError
from ..errors.internal_server_error import InternalServerError
from ..errors.not_found_error import NotFoundError
from ..errors.precondition_failed_error import PreconditionFailedError
from ..errors.unauthorized_error import UnauthorizedError
from ..errors.unprocessable_entity_error import UnprocessableEntityError
from ..types.error_model import ErrorModel
from ..types.redeem import Redeem
from .types.create_reward_response import CreateRewardResponse
from .types.create_voucher_response import CreateVoucherResponse
from .types.get_code_count_response import GetCodeCountResponse
from .types.get_loyalty_offer_programs_pid_offers_request_version import GetLoyaltyOfferProgramsPidOffersRequestVersion
from .types.get_loyalty_offer_programs_pid_offers_response import GetLoyaltyOfferProgramsPidOffersResponse
from .types.get_loyalty_offer_programs_pid_rewards_rid_request_version import (
    GetLoyaltyOfferProgramsPidRewardsRidRequestVersion,
)
from .types.get_loyalty_offer_programs_pid_rewards_rid_response import GetLoyaltyOfferProgramsPidRewardsRidResponse
from .types.get_loyalty_offer_programs_pid_vouchers_request_sort import GetLoyaltyOfferProgramsPidVouchersRequestSort
from .types.get_loyalty_offer_programs_pid_vouchers_request_sort_field import (
    GetLoyaltyOfferProgramsPidVouchersRequestSortField,
)
from .types.get_loyalty_offer_programs_pid_vouchers_response import GetLoyaltyOfferProgramsPidVouchersResponse
from .types.redeem_voucher_request_order import RedeemVoucherRequestOrder
from .types.validate_reward_response import ValidateRewardResponse

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawRewardClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def get_code_count(
        self, pid: str, cpid: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[GetCodeCountResponse]:
        """
        Get code count

        Parameters
        ----------
        pid : str
            Loyalty Program ID

        cpid : str
            Code Pool ID

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetCodeCountResponse]
            Code count successfully fetched
        """
        _response = self._client_wrapper.httpx_client.request(
            f"loyalty/offer/programs/{jsonable_encoder(pid)}/code-pools/{jsonable_encoder(cpid)}/codes-count",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetCodeCountResponse,
                    construct_type(
                        type_=GetCodeCountResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorModel,
                        construct_type(
                            type_=ErrorModel,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_reward_page_api(
        self,
        pid: str,
        *,
        limit: typing.Optional[int] = None,
        offset: typing.Optional[int] = None,
        state: typing.Optional[str] = None,
        version: typing.Optional[GetLoyaltyOfferProgramsPidOffersRequestVersion] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[GetLoyaltyOfferProgramsPidOffersResponse]:
        """
        Returns a reward page

        Parameters
        ----------
        pid : str
            Loyalty Program ID

        limit : typing.Optional[int]
            Page size

        offset : typing.Optional[int]
            Pagination offset

        state : typing.Optional[str]
            State of the reward

        version : typing.Optional[GetLoyaltyOfferProgramsPidOffersRequestVersion]
            Version

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetLoyaltyOfferProgramsPidOffersResponse]
            Reward list successfully retrieved
        """
        _response = self._client_wrapper.httpx_client.request(
            f"loyalty/offer/programs/{jsonable_encoder(pid)}/offers",
            method="GET",
            params={
                "limit": limit,
                "offset": offset,
                "state": state,
                "version": version,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetLoyaltyOfferProgramsPidOffersResponse,
                    construct_type(
                        type_=GetLoyaltyOfferProgramsPidOffersResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorModel,
                        construct_type(
                            type_=ErrorModel,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 424:
                raise FailedDependencyError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def create_reward(
        self,
        pid: str,
        *,
        name: str,
        public_description: typing.Optional[str] = OMIT,
        public_image: typing.Optional[str] = OMIT,
        public_name: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[CreateRewardResponse]:
        """
        Creates a new reward in the loyalty program.

        Parameters
        ----------
        pid : str
            Loyalty Program ID

        name : str
            Internal name of the reward

        public_description : typing.Optional[str]
            Public facing description of the reward

        public_image : typing.Optional[str]
            URL of the public image for the reward

        public_name : typing.Optional[str]
            Public facing name of the reward

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[CreateRewardResponse]
            Reward successfully created
        """
        _response = self._client_wrapper.httpx_client.request(
            f"loyalty/offer/programs/{jsonable_encoder(pid)}/offers",
            method="POST",
            json={
                "name": name,
                "publicDescription": public_description,
                "publicImage": public_image,
                "publicName": public_name,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CreateRewardResponse,
                    construct_type(
                        type_=CreateRewardResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorModel,
                        construct_type(
                            type_=ErrorModel,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def create_voucher(
        self,
        pid: str,
        *,
        reward_id: str,
        code: typing.Optional[str] = OMIT,
        contact_id: typing.Optional[int] = OMIT,
        expiration_date: typing.Optional[str] = OMIT,
        loyalty_subscription_id: typing.Optional[str] = OMIT,
        meta: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        value: typing.Optional[float] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[CreateVoucherResponse]:
        """
        Create a voucher and attribute it to a specific membership.

        Parameters
        ----------
        pid : str
            Loyalty Program ID

        reward_id : str
            Reward id

        code : typing.Optional[str]
            Code generated to attribute reward to a contact

        contact_id : typing.Optional[int]
            Contact to attribute the reward

        expiration_date : typing.Optional[str]
            Reward expiration date

        loyalty_subscription_id : typing.Optional[str]
            One of contactId or loyaltySubscriptionId is required

        meta : typing.Optional[typing.Dict[str, typing.Any]]
            Offer meta information (key/value object)

        value : typing.Optional[float]
            Value of the selected reward config

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[CreateVoucherResponse]
            Voucher successfully created
        """
        _response = self._client_wrapper.httpx_client.request(
            f"loyalty/offer/programs/{jsonable_encoder(pid)}/rewards/attribute",
            method="POST",
            json={
                "code": code,
                "contactId": contact_id,
                "expirationDate": expiration_date,
                "loyaltySubscriptionId": loyalty_subscription_id,
                "meta": meta,
                "rewardId": reward_id,
                "value": value,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CreateVoucherResponse,
                    construct_type(
                        type_=CreateVoucherResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorModel,
                        construct_type(
                            type_=ErrorModel,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def redeem_voucher(
        self,
        pid: str,
        *,
        attributed_reward_id: typing.Optional[str] = OMIT,
        code: typing.Optional[str] = OMIT,
        contact_id: typing.Optional[int] = OMIT,
        loyalty_subscription_id: typing.Optional[str] = OMIT,
        meta: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        order: typing.Optional[RedeemVoucherRequestOrder] = OMIT,
        reward_id: typing.Optional[str] = OMIT,
        ttl: typing.Optional[int] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[Redeem]:
        """
        Creates a request to redeem a voucher.

        Parameters
        ----------
        pid : str
            Loyalty Program ID

        attributed_reward_id : typing.Optional[str]
            Unique identifier for the attributed reward

        code : typing.Optional[str]
            Redemption code for the reward

        contact_id : typing.Optional[int]
            Unique identifier for the contact

        loyalty_subscription_id : typing.Optional[str]
            Identifier for the loyalty subscription

        meta : typing.Optional[typing.Dict[str, typing.Any]]
            Additional metadata associated with the redeem request

        order : typing.Optional[RedeemVoucherRequestOrder]
            Order details for the redemption

        reward_id : typing.Optional[str]
            Unique identifier for the reward

        ttl : typing.Optional[int]
            Time to live in seconds for the redemption request

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Redeem]
            Redeem request successfully created
        """
        _response = self._client_wrapper.httpx_client.request(
            f"loyalty/offer/programs/{jsonable_encoder(pid)}/rewards/redeem",
            method="POST",
            json={
                "attributedRewardId": attributed_reward_id,
                "code": code,
                "contactId": contact_id,
                "loyaltySubscriptionId": loyalty_subscription_id,
                "meta": meta,
                "order": convert_and_respect_annotation_metadata(
                    object_=order, annotation=RedeemVoucherRequestOrder, direction="write"
                ),
                "rewardId": reward_id,
                "ttl": ttl,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Redeem,
                    construct_type(
                        type_=Redeem,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 412:
                raise PreconditionFailedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorModel,
                        construct_type(
                            type_=ErrorModel,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 417:
                raise ExpectationFailedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorModel,
                        construct_type(
                            type_=ErrorModel,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorModel,
                        construct_type(
                            type_=ErrorModel,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def complete_redeem_transaction(
        self, pid: str, tid: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[Redeem]:
        """
        Completes voucher redeem request.

        Parameters
        ----------
        pid : str
            Loyalty Program ID

        tid : str
            Redeem transaction ID

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Redeem]
            Voucher Redeem completed
        """
        _response = self._client_wrapper.httpx_client.request(
            f"loyalty/offer/programs/{jsonable_encoder(pid)}/rewards/redeem/{jsonable_encoder(tid)}/complete",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Redeem,
                    construct_type(
                        type_=Redeem,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 412:
                raise PreconditionFailedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorModel,
                        construct_type(
                            type_=ErrorModel,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 417:
                raise ExpectationFailedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorModel,
                        construct_type(
                            type_=ErrorModel,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorModel,
                        construct_type(
                            type_=ErrorModel,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def revoke_vouchers(
        self,
        pid: str,
        *,
        attributed_reward_ids: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Revoke attributed vouchers.

        Parameters
        ----------
        pid : str
            Loyalty Program ID

        attributed_reward_ids : typing.Optional[str]
            Reward Attribution IDs (comma seperated)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"loyalty/offer/programs/{jsonable_encoder(pid)}/rewards/revoke",
            method="DELETE",
            params={
                "attributedRewardIds": attributed_reward_ids,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def validate_reward(
        self,
        pid: str,
        *,
        attributed_reward_id: typing.Optional[str] = OMIT,
        code: typing.Optional[str] = OMIT,
        contact_id: typing.Optional[int] = OMIT,
        loyalty_subscription_id: typing.Optional[str] = OMIT,
        point_of_sell_id: typing.Optional[str] = OMIT,
        reward_id: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[ValidateRewardResponse]:
        """
        Validates a reward.

        Parameters
        ----------
        pid : str
            Loyalty Program ID

        attributed_reward_id : typing.Optional[str]
            Unique identifier for the attributed reward

        code : typing.Optional[str]
            Validation code for the reward

        contact_id : typing.Optional[int]
            Unique identifier for the contact

        loyalty_subscription_id : typing.Optional[str]
            Identifier for the loyalty subscription

        point_of_sell_id : typing.Optional[str]
            Identifier for the point of sale

        reward_id : typing.Optional[str]
            Unique identifier for the reward

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ValidateRewardResponse]
            Reward successfully validated
        """
        _response = self._client_wrapper.httpx_client.request(
            f"loyalty/offer/programs/{jsonable_encoder(pid)}/rewards/validate",
            method="POST",
            json={
                "attributedRewardId": attributed_reward_id,
                "code": code,
                "contactId": contact_id,
                "loyaltySubscriptionId": loyalty_subscription_id,
                "pointOfSellId": point_of_sell_id,
                "rewardId": reward_id,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ValidateRewardResponse,
                    construct_type(
                        type_=ValidateRewardResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorModel,
                        construct_type(
                            type_=ErrorModel,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 424:
                raise FailedDependencyError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_reward_information(
        self,
        pid: str,
        rid: str,
        *,
        version: typing.Optional[GetLoyaltyOfferProgramsPidRewardsRidRequestVersion] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[GetLoyaltyOfferProgramsPidRewardsRidResponse]:
        """
        Returns reward information.

        Parameters
        ----------
        pid : str
            Loyalty Program ID

        rid : str
            Reward ID

        version : typing.Optional[GetLoyaltyOfferProgramsPidRewardsRidRequestVersion]
            Version

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetLoyaltyOfferProgramsPidRewardsRidResponse]
            Successful retrieval of reward data
        """
        _response = self._client_wrapper.httpx_client.request(
            f"loyalty/offer/programs/{jsonable_encoder(pid)}/rewards/{jsonable_encoder(rid)}",
            method="GET",
            params={
                "version": version,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetLoyaltyOfferProgramsPidRewardsRidResponse,
                    construct_type(
                        type_=GetLoyaltyOfferProgramsPidRewardsRidResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorModel,
                        construct_type(
                            type_=ErrorModel,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 424:
                raise FailedDependencyError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_voucher_for_a_contact(
        self,
        pid: str,
        *,
        contact_id: int,
        limit: typing.Optional[int] = None,
        offset: typing.Optional[int] = None,
        sort: typing.Optional[GetLoyaltyOfferProgramsPidVouchersRequestSort] = None,
        sort_field: typing.Optional[GetLoyaltyOfferProgramsPidVouchersRequestSortField] = None,
        metadata_key_value: typing.Optional[str] = None,
        reward_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[GetLoyaltyOfferProgramsPidVouchersResponse]:
        """
        Get voucher for a contact

        Parameters
        ----------
        pid : str
            Loyalty Program ID

        contact_id : int
            Contact ID

        limit : typing.Optional[int]
            Page size

        offset : typing.Optional[int]
            Pagination offset

        sort : typing.Optional[GetLoyaltyOfferProgramsPidVouchersRequestSort]
            Sort order

        sort_field : typing.Optional[GetLoyaltyOfferProgramsPidVouchersRequestSortField]
            Sort field

        metadata_key_value : typing.Optional[str]
            Metadata value for a Key filter

        reward_id : typing.Optional[str]
            Reward ID

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetLoyaltyOfferProgramsPidVouchersResponse]
            Voucher list successfully retrieved
        """
        _response = self._client_wrapper.httpx_client.request(
            f"loyalty/offer/programs/{jsonable_encoder(pid)}/vouchers",
            method="GET",
            params={
                "limit": limit,
                "offset": offset,
                "sort": sort,
                "sortField": sort_field,
                "contactId": contact_id,
                "metadata_key_value": metadata_key_value,
                "rewardId": reward_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetLoyaltyOfferProgramsPidVouchersResponse,
                    construct_type(
                        type_=GetLoyaltyOfferProgramsPidVouchersResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorModel,
                        construct_type(
                            type_=ErrorModel,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawRewardClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def get_code_count(
        self, pid: str, cpid: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[GetCodeCountResponse]:
        """
        Get code count

        Parameters
        ----------
        pid : str
            Loyalty Program ID

        cpid : str
            Code Pool ID

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetCodeCountResponse]
            Code count successfully fetched
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"loyalty/offer/programs/{jsonable_encoder(pid)}/code-pools/{jsonable_encoder(cpid)}/codes-count",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetCodeCountResponse,
                    construct_type(
                        type_=GetCodeCountResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorModel,
                        construct_type(
                            type_=ErrorModel,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_reward_page_api(
        self,
        pid: str,
        *,
        limit: typing.Optional[int] = None,
        offset: typing.Optional[int] = None,
        state: typing.Optional[str] = None,
        version: typing.Optional[GetLoyaltyOfferProgramsPidOffersRequestVersion] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[GetLoyaltyOfferProgramsPidOffersResponse]:
        """
        Returns a reward page

        Parameters
        ----------
        pid : str
            Loyalty Program ID

        limit : typing.Optional[int]
            Page size

        offset : typing.Optional[int]
            Pagination offset

        state : typing.Optional[str]
            State of the reward

        version : typing.Optional[GetLoyaltyOfferProgramsPidOffersRequestVersion]
            Version

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetLoyaltyOfferProgramsPidOffersResponse]
            Reward list successfully retrieved
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"loyalty/offer/programs/{jsonable_encoder(pid)}/offers",
            method="GET",
            params={
                "limit": limit,
                "offset": offset,
                "state": state,
                "version": version,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetLoyaltyOfferProgramsPidOffersResponse,
                    construct_type(
                        type_=GetLoyaltyOfferProgramsPidOffersResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorModel,
                        construct_type(
                            type_=ErrorModel,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 424:
                raise FailedDependencyError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def create_reward(
        self,
        pid: str,
        *,
        name: str,
        public_description: typing.Optional[str] = OMIT,
        public_image: typing.Optional[str] = OMIT,
        public_name: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[CreateRewardResponse]:
        """
        Creates a new reward in the loyalty program.

        Parameters
        ----------
        pid : str
            Loyalty Program ID

        name : str
            Internal name of the reward

        public_description : typing.Optional[str]
            Public facing description of the reward

        public_image : typing.Optional[str]
            URL of the public image for the reward

        public_name : typing.Optional[str]
            Public facing name of the reward

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[CreateRewardResponse]
            Reward successfully created
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"loyalty/offer/programs/{jsonable_encoder(pid)}/offers",
            method="POST",
            json={
                "name": name,
                "publicDescription": public_description,
                "publicImage": public_image,
                "publicName": public_name,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CreateRewardResponse,
                    construct_type(
                        type_=CreateRewardResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorModel,
                        construct_type(
                            type_=ErrorModel,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def create_voucher(
        self,
        pid: str,
        *,
        reward_id: str,
        code: typing.Optional[str] = OMIT,
        contact_id: typing.Optional[int] = OMIT,
        expiration_date: typing.Optional[str] = OMIT,
        loyalty_subscription_id: typing.Optional[str] = OMIT,
        meta: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        value: typing.Optional[float] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[CreateVoucherResponse]:
        """
        Create a voucher and attribute it to a specific membership.

        Parameters
        ----------
        pid : str
            Loyalty Program ID

        reward_id : str
            Reward id

        code : typing.Optional[str]
            Code generated to attribute reward to a contact

        contact_id : typing.Optional[int]
            Contact to attribute the reward

        expiration_date : typing.Optional[str]
            Reward expiration date

        loyalty_subscription_id : typing.Optional[str]
            One of contactId or loyaltySubscriptionId is required

        meta : typing.Optional[typing.Dict[str, typing.Any]]
            Offer meta information (key/value object)

        value : typing.Optional[float]
            Value of the selected reward config

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[CreateVoucherResponse]
            Voucher successfully created
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"loyalty/offer/programs/{jsonable_encoder(pid)}/rewards/attribute",
            method="POST",
            json={
                "code": code,
                "contactId": contact_id,
                "expirationDate": expiration_date,
                "loyaltySubscriptionId": loyalty_subscription_id,
                "meta": meta,
                "rewardId": reward_id,
                "value": value,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CreateVoucherResponse,
                    construct_type(
                        type_=CreateVoucherResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorModel,
                        construct_type(
                            type_=ErrorModel,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def redeem_voucher(
        self,
        pid: str,
        *,
        attributed_reward_id: typing.Optional[str] = OMIT,
        code: typing.Optional[str] = OMIT,
        contact_id: typing.Optional[int] = OMIT,
        loyalty_subscription_id: typing.Optional[str] = OMIT,
        meta: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        order: typing.Optional[RedeemVoucherRequestOrder] = OMIT,
        reward_id: typing.Optional[str] = OMIT,
        ttl: typing.Optional[int] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[Redeem]:
        """
        Creates a request to redeem a voucher.

        Parameters
        ----------
        pid : str
            Loyalty Program ID

        attributed_reward_id : typing.Optional[str]
            Unique identifier for the attributed reward

        code : typing.Optional[str]
            Redemption code for the reward

        contact_id : typing.Optional[int]
            Unique identifier for the contact

        loyalty_subscription_id : typing.Optional[str]
            Identifier for the loyalty subscription

        meta : typing.Optional[typing.Dict[str, typing.Any]]
            Additional metadata associated with the redeem request

        order : typing.Optional[RedeemVoucherRequestOrder]
            Order details for the redemption

        reward_id : typing.Optional[str]
            Unique identifier for the reward

        ttl : typing.Optional[int]
            Time to live in seconds for the redemption request

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Redeem]
            Redeem request successfully created
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"loyalty/offer/programs/{jsonable_encoder(pid)}/rewards/redeem",
            method="POST",
            json={
                "attributedRewardId": attributed_reward_id,
                "code": code,
                "contactId": contact_id,
                "loyaltySubscriptionId": loyalty_subscription_id,
                "meta": meta,
                "order": convert_and_respect_annotation_metadata(
                    object_=order, annotation=RedeemVoucherRequestOrder, direction="write"
                ),
                "rewardId": reward_id,
                "ttl": ttl,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Redeem,
                    construct_type(
                        type_=Redeem,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 412:
                raise PreconditionFailedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorModel,
                        construct_type(
                            type_=ErrorModel,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 417:
                raise ExpectationFailedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorModel,
                        construct_type(
                            type_=ErrorModel,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorModel,
                        construct_type(
                            type_=ErrorModel,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def complete_redeem_transaction(
        self, pid: str, tid: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[Redeem]:
        """
        Completes voucher redeem request.

        Parameters
        ----------
        pid : str
            Loyalty Program ID

        tid : str
            Redeem transaction ID

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Redeem]
            Voucher Redeem completed
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"loyalty/offer/programs/{jsonable_encoder(pid)}/rewards/redeem/{jsonable_encoder(tid)}/complete",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Redeem,
                    construct_type(
                        type_=Redeem,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 412:
                raise PreconditionFailedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorModel,
                        construct_type(
                            type_=ErrorModel,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 417:
                raise ExpectationFailedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorModel,
                        construct_type(
                            type_=ErrorModel,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorModel,
                        construct_type(
                            type_=ErrorModel,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def revoke_vouchers(
        self,
        pid: str,
        *,
        attributed_reward_ids: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Revoke attributed vouchers.

        Parameters
        ----------
        pid : str
            Loyalty Program ID

        attributed_reward_ids : typing.Optional[str]
            Reward Attribution IDs (comma seperated)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"loyalty/offer/programs/{jsonable_encoder(pid)}/rewards/revoke",
            method="DELETE",
            params={
                "attributedRewardIds": attributed_reward_ids,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def validate_reward(
        self,
        pid: str,
        *,
        attributed_reward_id: typing.Optional[str] = OMIT,
        code: typing.Optional[str] = OMIT,
        contact_id: typing.Optional[int] = OMIT,
        loyalty_subscription_id: typing.Optional[str] = OMIT,
        point_of_sell_id: typing.Optional[str] = OMIT,
        reward_id: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[ValidateRewardResponse]:
        """
        Validates a reward.

        Parameters
        ----------
        pid : str
            Loyalty Program ID

        attributed_reward_id : typing.Optional[str]
            Unique identifier for the attributed reward

        code : typing.Optional[str]
            Validation code for the reward

        contact_id : typing.Optional[int]
            Unique identifier for the contact

        loyalty_subscription_id : typing.Optional[str]
            Identifier for the loyalty subscription

        point_of_sell_id : typing.Optional[str]
            Identifier for the point of sale

        reward_id : typing.Optional[str]
            Unique identifier for the reward

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ValidateRewardResponse]
            Reward successfully validated
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"loyalty/offer/programs/{jsonable_encoder(pid)}/rewards/validate",
            method="POST",
            json={
                "attributedRewardId": attributed_reward_id,
                "code": code,
                "contactId": contact_id,
                "loyaltySubscriptionId": loyalty_subscription_id,
                "pointOfSellId": point_of_sell_id,
                "rewardId": reward_id,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ValidateRewardResponse,
                    construct_type(
                        type_=ValidateRewardResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorModel,
                        construct_type(
                            type_=ErrorModel,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 424:
                raise FailedDependencyError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_reward_information(
        self,
        pid: str,
        rid: str,
        *,
        version: typing.Optional[GetLoyaltyOfferProgramsPidRewardsRidRequestVersion] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[GetLoyaltyOfferProgramsPidRewardsRidResponse]:
        """
        Returns reward information.

        Parameters
        ----------
        pid : str
            Loyalty Program ID

        rid : str
            Reward ID

        version : typing.Optional[GetLoyaltyOfferProgramsPidRewardsRidRequestVersion]
            Version

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetLoyaltyOfferProgramsPidRewardsRidResponse]
            Successful retrieval of reward data
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"loyalty/offer/programs/{jsonable_encoder(pid)}/rewards/{jsonable_encoder(rid)}",
            method="GET",
            params={
                "version": version,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetLoyaltyOfferProgramsPidRewardsRidResponse,
                    construct_type(
                        type_=GetLoyaltyOfferProgramsPidRewardsRidResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorModel,
                        construct_type(
                            type_=ErrorModel,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 424:
                raise FailedDependencyError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_voucher_for_a_contact(
        self,
        pid: str,
        *,
        contact_id: int,
        limit: typing.Optional[int] = None,
        offset: typing.Optional[int] = None,
        sort: typing.Optional[GetLoyaltyOfferProgramsPidVouchersRequestSort] = None,
        sort_field: typing.Optional[GetLoyaltyOfferProgramsPidVouchersRequestSortField] = None,
        metadata_key_value: typing.Optional[str] = None,
        reward_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[GetLoyaltyOfferProgramsPidVouchersResponse]:
        """
        Get voucher for a contact

        Parameters
        ----------
        pid : str
            Loyalty Program ID

        contact_id : int
            Contact ID

        limit : typing.Optional[int]
            Page size

        offset : typing.Optional[int]
            Pagination offset

        sort : typing.Optional[GetLoyaltyOfferProgramsPidVouchersRequestSort]
            Sort order

        sort_field : typing.Optional[GetLoyaltyOfferProgramsPidVouchersRequestSortField]
            Sort field

        metadata_key_value : typing.Optional[str]
            Metadata value for a Key filter

        reward_id : typing.Optional[str]
            Reward ID

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetLoyaltyOfferProgramsPidVouchersResponse]
            Voucher list successfully retrieved
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"loyalty/offer/programs/{jsonable_encoder(pid)}/vouchers",
            method="GET",
            params={
                "limit": limit,
                "offset": offset,
                "sort": sort,
                "sortField": sort_field,
                "contactId": contact_id,
                "metadata_key_value": metadata_key_value,
                "rewardId": reward_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetLoyaltyOfferProgramsPidVouchersResponse,
                    construct_type(
                        type_=GetLoyaltyOfferProgramsPidVouchersResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorModel,
                        construct_type(
                            type_=ErrorModel,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)
