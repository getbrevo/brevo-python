# This file was auto-generated by Fern from our API Definition.

import typing
from json.decoder import JSONDecodeError

from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.http_response import AsyncHttpResponse, HttpResponse
from ..core.jsonable_encoder import jsonable_encoder
from ..core.request_options import RequestOptions
from ..core.serialization import convert_and_respect_annotation_metadata
from ..core.unchecked_base_model import construct_type
from ..errors.bad_request_error import BadRequestError
from ..errors.failed_dependency_error import FailedDependencyError
from ..errors.forbidden_error import ForbiddenError
from ..errors.internal_server_error import InternalServerError
from ..errors.not_found_error import NotFoundError
from .types.batch_delete_object_records_request_identifiers import BatchDeleteObjectRecordsRequestIdentifiers
from .types.batch_delete_object_records_response import BatchDeleteObjectRecordsResponse
from .types.getrecords_request_association import GetrecordsRequestAssociation
from .types.getrecords_request_sort import GetrecordsRequestSort
from .types.getrecords_response import GetrecordsResponse
from .types.upsertrecords_request_records_item import UpsertrecordsRequestRecordsItem
from .types.upsertrecords_response import UpsertrecordsResponse

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawCustomObjectsClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def upsertrecords(
        self,
        object_type: str,
        *,
        records: typing.Sequence[UpsertrecordsRequestRecordsItem],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[UpsertrecordsResponse]:
        """
        <Note title="Enterprise access only">
        Custom objects are only available to Enterprise plans.

        This feature is in beta. These are subject to change.
        </Note>

        This API allows bulk upsert of object records in a single request. Each object record may include
          - Attributes
          - Identifiers
          - Associations
        **Response:**
          The API processes the request asynchronously and returns a processId that you can use to track the background process status.
        **API and Schema Limitation:**
          - Size:
              - Max 1000 objects records per request
              - Max request body size: 1 MB
          - Max 500 attributes defined per object record upsert request
            - This is coherent with schema limitation: an object cannot have more than 500 attributes.
            - Worth noting: Nothing happens If an attribute is mentioned in the request, but was not previously defined for the object schema (no error, no attribute creation)
          - Max 10 associations defined per object record upsert request
            - This is coherent with schema limitation: an object cannot have more than 10 associations with other objects. and each object record can be linked to max 10 other records.
        **Errors:**
            - Make sure both object records exist before associating them, else the API will return an error.
            - This route does not create objects. The object where the object records are upserted by this API must be created already else the API will return an error "invalid object type".

        Parameters
        ----------
        object_type : str
            object type for the attribute

        records : typing.Sequence[UpsertrecordsRequestRecordsItem]
            List of object records to be upsert. Each record can have attributes, identifiers, and associations.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[UpsertrecordsResponse]
            Batch request accepted for processing of upsert object records.
        """
        _response = self._client_wrapper.httpx_client.request(
            f"objects/{jsonable_encoder(object_type)}/batch/upsert",
            method="POST",
            json={
                "records": convert_and_respect_annotation_metadata(
                    object_=records, annotation=typing.Sequence[UpsertrecordsRequestRecordsItem], direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    UpsertrecordsResponse,
                    construct_type(
                        type_=UpsertrecordsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def getrecords(
        self,
        object_type: str,
        *,
        limit: int,
        page_num: int,
        sort: typing.Optional[GetrecordsRequestSort] = None,
        association: typing.Optional[GetrecordsRequestAssociation] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[GetrecordsResponse]:
        """
        <Note title="Enterprise access only">
        Custom objects are only available to Enterprise plans.

        This feature is in beta. These are subject to change.
        </Note>

        This API retrieves a list of object records along with their associated records and provides the total count of records for the specified object. **Note**: Contact as object type is not supported in this endpoint.

        Parameters
        ----------
        object_type : str
            object type for the attribute

        limit : int
            Number of records returned per page

        page_num : int
            Page number for pagination. It's used to fetch the object records on a provided page number. Must be a valid positive integer.

        sort : typing.Optional[GetrecordsRequestSort]
            Sort order, must be 'asc' or 'desc'. Default to 'desc' if not provided.

        association : typing.Optional[GetrecordsRequestAssociation]
            Whether to include associations, must be 'true' or 'false'. Default to 'false' if not provided.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetrecordsResponse]
            A list of object records for an object type. If association param is set true it will return 5 associated records per association for an object type.
        """
        _response = self._client_wrapper.httpx_client.request(
            f"objects/{jsonable_encoder(object_type)}/records",
            method="GET",
            params={
                "limit": limit,
                "page_num": page_num,
                "sort": sort,
                "association": association,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetrecordsResponse,
                    construct_type(
                        type_=GetrecordsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 424:
                raise FailedDependencyError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def batch_delete_object_records(
        self,
        object_type: str,
        *,
        identifiers: typing.Optional[BatchDeleteObjectRecordsRequestIdentifiers] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[BatchDeleteObjectRecordsResponse]:
        """
        Use this endpoint to delete multiple object records of the same object-type in one request.
        The request is accepted and processed asynchronously.   You can track the status of the deletion process using the returned **processId**.
        **API and Schema Limitations:** - Each request can contain up to **1000** object record identifiers   - If more records must be deleted → send multiple batch requests

        Parameters
        ----------
        object_type : str
            Object type for the records to delete

        identifiers : typing.Optional[BatchDeleteObjectRecordsRequestIdentifiers]
            One of the below must be provided

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[BatchDeleteObjectRecordsResponse]
            Batch request accepted for deletion - process started
        """
        _response = self._client_wrapper.httpx_client.request(
            f"objects/{jsonable_encoder(object_type)}/batch/delete",
            method="POST",
            json={
                "identifiers": convert_and_respect_annotation_metadata(
                    object_=identifiers, annotation=BatchDeleteObjectRecordsRequestIdentifiers, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    BatchDeleteObjectRecordsResponse,
                    construct_type(
                        type_=BatchDeleteObjectRecordsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawCustomObjectsClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def upsertrecords(
        self,
        object_type: str,
        *,
        records: typing.Sequence[UpsertrecordsRequestRecordsItem],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[UpsertrecordsResponse]:
        """
        <Note title="Enterprise access only">
        Custom objects are only available to Enterprise plans.

        This feature is in beta. These are subject to change.
        </Note>

        This API allows bulk upsert of object records in a single request. Each object record may include
          - Attributes
          - Identifiers
          - Associations
        **Response:**
          The API processes the request asynchronously and returns a processId that you can use to track the background process status.
        **API and Schema Limitation:**
          - Size:
              - Max 1000 objects records per request
              - Max request body size: 1 MB
          - Max 500 attributes defined per object record upsert request
            - This is coherent with schema limitation: an object cannot have more than 500 attributes.
            - Worth noting: Nothing happens If an attribute is mentioned in the request, but was not previously defined for the object schema (no error, no attribute creation)
          - Max 10 associations defined per object record upsert request
            - This is coherent with schema limitation: an object cannot have more than 10 associations with other objects. and each object record can be linked to max 10 other records.
        **Errors:**
            - Make sure both object records exist before associating them, else the API will return an error.
            - This route does not create objects. The object where the object records are upserted by this API must be created already else the API will return an error "invalid object type".

        Parameters
        ----------
        object_type : str
            object type for the attribute

        records : typing.Sequence[UpsertrecordsRequestRecordsItem]
            List of object records to be upsert. Each record can have attributes, identifiers, and associations.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[UpsertrecordsResponse]
            Batch request accepted for processing of upsert object records.
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"objects/{jsonable_encoder(object_type)}/batch/upsert",
            method="POST",
            json={
                "records": convert_and_respect_annotation_metadata(
                    object_=records, annotation=typing.Sequence[UpsertrecordsRequestRecordsItem], direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    UpsertrecordsResponse,
                    construct_type(
                        type_=UpsertrecordsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def getrecords(
        self,
        object_type: str,
        *,
        limit: int,
        page_num: int,
        sort: typing.Optional[GetrecordsRequestSort] = None,
        association: typing.Optional[GetrecordsRequestAssociation] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[GetrecordsResponse]:
        """
        <Note title="Enterprise access only">
        Custom objects are only available to Enterprise plans.

        This feature is in beta. These are subject to change.
        </Note>

        This API retrieves a list of object records along with their associated records and provides the total count of records for the specified object. **Note**: Contact as object type is not supported in this endpoint.

        Parameters
        ----------
        object_type : str
            object type for the attribute

        limit : int
            Number of records returned per page

        page_num : int
            Page number for pagination. It's used to fetch the object records on a provided page number. Must be a valid positive integer.

        sort : typing.Optional[GetrecordsRequestSort]
            Sort order, must be 'asc' or 'desc'. Default to 'desc' if not provided.

        association : typing.Optional[GetrecordsRequestAssociation]
            Whether to include associations, must be 'true' or 'false'. Default to 'false' if not provided.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetrecordsResponse]
            A list of object records for an object type. If association param is set true it will return 5 associated records per association for an object type.
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"objects/{jsonable_encoder(object_type)}/records",
            method="GET",
            params={
                "limit": limit,
                "page_num": page_num,
                "sort": sort,
                "association": association,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetrecordsResponse,
                    construct_type(
                        type_=GetrecordsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 424:
                raise FailedDependencyError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def batch_delete_object_records(
        self,
        object_type: str,
        *,
        identifiers: typing.Optional[BatchDeleteObjectRecordsRequestIdentifiers] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[BatchDeleteObjectRecordsResponse]:
        """
        Use this endpoint to delete multiple object records of the same object-type in one request.
        The request is accepted and processed asynchronously.   You can track the status of the deletion process using the returned **processId**.
        **API and Schema Limitations:** - Each request can contain up to **1000** object record identifiers   - If more records must be deleted → send multiple batch requests

        Parameters
        ----------
        object_type : str
            Object type for the records to delete

        identifiers : typing.Optional[BatchDeleteObjectRecordsRequestIdentifiers]
            One of the below must be provided

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[BatchDeleteObjectRecordsResponse]
            Batch request accepted for deletion - process started
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"objects/{jsonable_encoder(object_type)}/batch/delete",
            method="POST",
            json={
                "identifiers": convert_and_respect_annotation_metadata(
                    object_=identifiers, annotation=BatchDeleteObjectRecordsRequestIdentifiers, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    BatchDeleteObjectRecordsResponse,
                    construct_type(
                        type_=BatchDeleteObjectRecordsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)
