# This file was auto-generated by Fern from our API Definition.

import typing
from json.decoder import JSONDecodeError

from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.http_response import AsyncHttpResponse, HttpResponse
from ..core.jsonable_encoder import jsonable_encoder
from ..core.request_options import RequestOptions
from ..core.serialization import convert_and_respect_annotation_metadata
from ..core.unchecked_base_model import construct_type
from ..errors.bad_request_error import BadRequestError
from ..errors.forbidden_error import ForbiddenError
from ..errors.not_found_error import NotFoundError
from ..types.get_sso_token import GetSsoToken
from .types.get_corporate_group_id_response import GetCorporateGroupIdResponse
from .types.get_corporate_invited_users_list_response import GetCorporateInvitedUsersListResponse
from .types.get_corporate_ip_response_item import GetCorporateIpResponseItem
from .types.get_corporate_master_account_response import GetCorporateMasterAccountResponse
from .types.get_corporate_sub_account_id_response import GetCorporateSubAccountIdResponse
from .types.get_corporate_sub_account_response import GetCorporateSubAccountResponse
from .types.get_corporate_user_permission_response import GetCorporateUserPermissionResponse
from .types.get_sub_account_groups_response_item import GetSubAccountGroupsResponseItem
from .types.invite_admin_user_request_privileges_item import InviteAdminUserRequestPrivilegesItem
from .types.invite_admin_user_response import InviteAdminUserResponse
from .types.post_corporate_group_response import PostCorporateGroupResponse
from .types.post_corporate_sub_account_key_response import PostCorporateSubAccountKeyResponse
from .types.post_corporate_sub_account_request_language import PostCorporateSubAccountRequestLanguage
from .types.post_corporate_sub_account_response import PostCorporateSubAccountResponse
from .types.post_corporate_sub_account_sso_token_request_target import PostCorporateSubAccountSsoTokenRequestTarget
from .types.put_corporate_sub_account_id_plan_request_credits import PutCorporateSubAccountIdPlanRequestCredits
from .types.put_corporate_sub_account_id_plan_request_features import PutCorporateSubAccountIdPlanRequestFeatures
from .types.put_corporate_sub_accounts_plan_request_credits import PutCorporateSubAccountsPlanRequestCredits
from .types.put_corporate_sub_accounts_plan_request_features import PutCorporateSubAccountsPlanRequestFeatures
from .types.put_corporate_user_email_permissions_request_privileges_item import (
    PutCorporateUserEmailPermissionsRequestPrivilegesItem,
)
from .types.put_corporate_user_invitation_action_email_request_action import (
    PutCorporateUserInvitationActionEmailRequestAction,
)
from .types.put_corporate_user_invitation_action_email_response import PutCorporateUserInvitationActionEmailResponse

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawMasterAccountClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def create_a_new_group_of_sub_accounts(
        self,
        *,
        group_name: str,
        sub_account_ids: typing.Optional[typing.Sequence[int]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[PostCorporateGroupResponse]:
        """
        This endpoint allows to create a group of sub-accounts

        Parameters
        ----------
        group_name : str
            The name of the group of sub-accounts

        sub_account_ids : typing.Optional[typing.Sequence[int]]
            Pass the list of sub-account Ids to be included in the group

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[PostCorporateGroupResponse]
            Group ID
        """
        _response = self._client_wrapper.httpx_client.request(
            "corporate/group",
            method="POST",
            json={
                "groupName": group_name,
                "subAccountIds": sub_account_ids,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PostCorporateGroupResponse,
                    construct_type(
                        type_=PostCorporateGroupResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def delete_sub_account_from_group(
        self,
        group_id: str,
        *,
        sub_account_ids: typing.Sequence[int],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        This endpoint allows you to remove a sub-organization from a group.

        Parameters
        ----------
        group_id : str
            Group id

        sub_account_ids : typing.Sequence[int]
            List of sub-account ids

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"corporate/group/unlink/{jsonable_encoder(group_id)}/subAccounts",
            method="PUT",
            json={
                "subAccountIds": sub_account_ids,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_a_group_details(
        self, id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[GetCorporateGroupIdResponse]:
        """
        This endpoint allows you to retrieve a specific group’s information such as
        the list of sub-organizations and the user associated with the group.

        Parameters
        ----------
        id : str
            Id of the group of sub-organization

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetCorporateGroupIdResponse]
            Group details
        """
        _response = self._client_wrapper.httpx_client.request(
            f"corporate/group/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetCorporateGroupIdResponse,
                    construct_type(
                        type_=GetCorporateGroupIdResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def update_a_group_of_sub_accounts(
        self,
        id: str,
        *,
        group_name: typing.Optional[str] = OMIT,
        sub_account_ids: typing.Optional[typing.Sequence[int]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        This endpoint allows to update a group of sub-accounts

        Parameters
        ----------
        id : str
            Id of the group

        group_name : typing.Optional[str]
            The name of the group of sub-accounts

        sub_account_ids : typing.Optional[typing.Sequence[int]]
            Pass the list of sub-account Ids to be included in the group

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"corporate/group/{jsonable_encoder(id)}",
            method="PUT",
            json={
                "groupName": group_name,
                "subAccountIds": sub_account_ids,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def delete_a_group(self, id: str, *, request_options: typing.Optional[RequestOptions] = None) -> HttpResponse[None]:
        """
        This endpoint allows you to delete a group of sub-organizations. When a
        group is deleted, the sub-organizations are no longer part of this group.
        The users associated with the group are no longer associated with the group
        once deleted.

        Parameters
        ----------
        id : str
            Id of the group

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"corporate/group/{jsonable_encoder(id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_sub_account_groups(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[typing.List[GetSubAccountGroupsResponseItem]]:
        """
        This endpoint allows you to list all groups created on your Admin account.

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[GetSubAccountGroupsResponseItem]]
            list of all the sub-account groups
        """
        _response = self._client_wrapper.httpx_client.request(
            "corporate/groups",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[GetSubAccountGroupsResponseItem],
                    construct_type(
                        type_=typing.List[GetSubAccountGroupsResponseItem],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_corporate_invited_users_list(
        self,
        *,
        type: typing.Optional[str] = None,
        offset: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[GetCorporateInvitedUsersListResponse]:
        """
        This endpoint allows you to list all Admin users of your Admin account. You
        can filter users by type (active or pending) and paginate results using
        offset and limit.

        Parameters
        ----------
        type : typing.Optional[str]
            User type (active | pending). This is required if offset is provided for
            limited result.

        offset : typing.Optional[int]
            Page number for the result set. This is optional, default value will be
            the 1st page.

        limit : typing.Optional[int]
            Number of users to be displayed on each page. This is optional, the
            default limit is 20, but max allowed limit is 100.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetCorporateInvitedUsersListResponse]
            list of all admin users
        """
        _response = self._client_wrapper.httpx_client.request(
            "corporate/invited/users",
            method="GET",
            params={
                "type": type,
                "offset": offset,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetCorporateInvitedUsersListResponse,
                    construct_type(
                        type_=GetCorporateInvitedUsersListResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def list_of_all_i_ps(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[typing.List[GetCorporateIpResponseItem]]:
        """
        This endpoint allows you to retrieve the list of active IPs on your Admin
        account

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[GetCorporateIpResponseItem]]
            List of all IPs
        """
        _response = self._client_wrapper.httpx_client.request(
            "corporate/ip",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[GetCorporateIpResponseItem],
                    construct_type(
                        type_=typing.List[GetCorporateIpResponseItem],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_the_details_of_requested_master_account(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[GetCorporateMasterAccountResponse]:
        """
        This endpoint will provide the details of the master account.

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetCorporateMasterAccountResponse]
            Master account details
        """
        _response = self._client_wrapper.httpx_client.request(
            "corporate/masterAccount",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetCorporateMasterAccountResponse,
                    construct_type(
                        type_=GetCorporateMasterAccountResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def generate_sso_token_to_access_admin_account(
        self, *, email: str, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[GetSsoToken]:
        """
        This endpoint generates an SSO token to authenticate and access the admin
        account using the endpoint
        https://account-app.brevo.com/account/login/corporate/sso/[token], where
        [token] will be replaced by the actual token.

        Parameters
        ----------
        email : str
            User email of admin account

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetSsoToken]
            Session token
        """
        _response = self._client_wrapper.httpx_client.request(
            "corporate/ssoToken",
            method="POST",
            json={
                "email": email,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetSsoToken,
                    construct_type(
                        type_=GetSsoToken,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_the_list_of_all_the_sub_accounts_of_the_master_account(
        self, *, offset: int, limit: int, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[GetCorporateSubAccountResponse]:
        """
        This endpoint will provide the list all the sub-accounts of the master
        account.

        Parameters
        ----------
        offset : int
            Index of the first sub-account in the page

        limit : int
            Number of sub-accounts to be displayed on each page

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetCorporateSubAccountResponse]
            Sub-accounts list
        """
        _response = self._client_wrapper.httpx_client.request(
            "corporate/subAccount",
            method="GET",
            params={
                "offset": offset,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetCorporateSubAccountResponse,
                    construct_type(
                        type_=GetCorporateSubAccountResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def create_a_new_sub_account_under_a_master_account(
        self,
        *,
        company_name: str,
        email: str,
        group_ids: typing.Optional[typing.Sequence[str]] = OMIT,
        language: typing.Optional[PostCorporateSubAccountRequestLanguage] = OMIT,
        timezone: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[PostCorporateSubAccountResponse]:
        """
        This endpoint will create a new sub-account under a master account

        Parameters
        ----------
        company_name : str
            Set the name of the sub-account company

        email : str
            Email address for the organization

        group_ids : typing.Optional[typing.Sequence[str]]
            Set the group(s) for the sub-account

        language : typing.Optional[PostCorporateSubAccountRequestLanguage]
            Set the language of the sub-account

        timezone : typing.Optional[str]
            Set the timezone of the sub-account

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[PostCorporateSubAccountResponse]
            Created sub-account ID
        """
        _response = self._client_wrapper.httpx_client.request(
            "corporate/subAccount",
            method="POST",
            json={
                "companyName": company_name,
                "email": email,
                "groupIds": group_ids,
                "language": language,
                "timezone": timezone,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PostCorporateSubAccountResponse,
                    construct_type(
                        type_=PostCorporateSubAccountResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def associate_an_ip_to_sub_accounts(
        self, *, ids: typing.Sequence[int], ip: str, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[typing.Dict[str, typing.Any]]:
        """
        This endpoint allows to associate an IP to sub-accounts

        Parameters
        ----------
        ids : typing.Sequence[int]
            Pass the list of sub-account Ids to be associated with the IP
            address

        ip : str
            IP address

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.Dict[str, typing.Any]]
            IP has been associated with sub-accounts successfully
        """
        _response = self._client_wrapper.httpx_client.request(
            "corporate/subAccount/ip/associate",
            method="POST",
            json={
                "ids": ids,
                "ip": ip,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Dict[str, typing.Any],
                    construct_type(
                        type_=typing.Dict[str, typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def dissociate_an_ip_to_sub_accounts(
        self, *, ids: typing.Sequence[int], ip: str, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[None]:
        """
        This endpoint allows to dissociate an IP from sub-accounts

        Parameters
        ----------
        ids : typing.Sequence[int]
            Pass the list of sub-account Ids to be dissociated from the IP
            address

        ip : str
            IP address

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            "corporate/subAccount/ip/dissociate",
            method="PUT",
            json={
                "ids": ids,
                "ip": ip,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def create_an_api_key_for_a_sub_account(
        self, *, id: int, name: str, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[PostCorporateSubAccountKeyResponse]:
        """
        This endpoint will generate an API v3 key for a sub-account

        Parameters
        ----------
        id : int
            Id of the sub-account organization

        name : str
            Name of the API key

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[PostCorporateSubAccountKeyResponse]
            API key
        """
        _response = self._client_wrapper.httpx_client.request(
            "corporate/subAccount/key",
            method="POST",
            json={
                "id": id,
                "name": name,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PostCorporateSubAccountKeyResponse,
                    construct_type(
                        type_=PostCorporateSubAccountKeyResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def generate_sso_token_to_access_sub_account(
        self,
        *,
        id: int,
        email: typing.Optional[str] = OMIT,
        target: typing.Optional[PostCorporateSubAccountSsoTokenRequestTarget] = OMIT,
        url: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[GetSsoToken]:
        """
        This endpoint generates an sso token to authenticate and access a
        sub-account of the master using the account endpoint
        https://account-app.brevo.com/account/login/sub-account/sso/[token], where
        [token] will be replaced by the actual token.

        Parameters
        ----------
        id : int
            Id of the sub-account organization

        email : typing.Optional[str]
            User email of sub-account organization

        target : typing.Optional[PostCorporateSubAccountSsoTokenRequestTarget]
            **Set target after login success** * **automation** - Redirect
            to Automation after login * **email_campaign** - Redirect to
            Email Campaign after login * **contacts** - Redirect to Contacts
            after login * **landing_pages** - Redirect to Landing Pages
            after login * **email_transactional** - Redirect to Email
            Transactional after login * **senders** - Redirect to Senders
            after login * **sms_campaign** - Redirect to Sms Campaign after
            login * **sms_transactional** - Redirect to Sms Transactional
            after login

        url : typing.Optional[str]
            Set the full target URL after login success. The user will land
            directly on this target URL after login

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetSsoToken]
            Session token
        """
        _response = self._client_wrapper.httpx_client.request(
            "corporate/subAccount/ssoToken",
            method="POST",
            json={
                "email": email,
                "id": id,
                "target": target,
                "url": url,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetSsoToken,
                    construct_type(
                        type_=GetSsoToken,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_sub_account_details(
        self, id: int, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[GetCorporateSubAccountIdResponse]:
        """
        This endpoint will provide the details for the specified sub-account company

        Parameters
        ----------
        id : int
            Id of the sub-account organization

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetCorporateSubAccountIdResponse]
            Sub-account organization details
        """
        _response = self._client_wrapper.httpx_client.request(
            f"corporate/subAccount/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetCorporateSubAccountIdResponse,
                    construct_type(
                        type_=GetCorporateSubAccountIdResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def delete_a_sub_account(
        self, id: int, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        id : int
            Id of the sub-account organization to be deleted

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"corporate/subAccount/{jsonable_encoder(id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def enable_disable_sub_account_application_s(
        self,
        id: int,
        *,
        automation: typing.Optional[bool] = OMIT,
        conversations: typing.Optional[bool] = OMIT,
        crm: typing.Optional[bool] = OMIT,
        email_campaigns: typing.Optional[bool] = OMIT,
        facebook_ads: typing.Optional[bool] = OMIT,
        inbox: typing.Optional[bool] = OMIT,
        landing_pages: typing.Optional[bool] = OMIT,
        meetings: typing.Optional[bool] = OMIT,
        sms_campaigns: typing.Optional[bool] = OMIT,
        transactional_emails: typing.Optional[bool] = OMIT,
        transactional_sms: typing.Optional[bool] = OMIT,
        web_push: typing.Optional[bool] = OMIT,
        whatsapp: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        API endpoint for the Corporate owner to enable/disable applications on the
        sub-account

        Parameters
        ----------
        id : int
            Id of the sub-account organization (mandatory)

        automation : typing.Optional[bool]
            Set this field to enable or disable Automation on the
            sub-account

        conversations : typing.Optional[bool]
            Set this field to enable or disable Conversations on the
            sub-account

        crm : typing.Optional[bool]
            Set this field to enable or disable Sales CRM on the sub-account

        email_campaigns : typing.Optional[bool]
            Set this field to enable or disable Email Campaigns on the
            sub-account

        facebook_ads : typing.Optional[bool]
            Set this field to enable or disable Facebook ads on the
            sub-account

        inbox : typing.Optional[bool]
            Set this field to enable or disable Inbox on the sub-account /
            Not applicable on ENTv2

        landing_pages : typing.Optional[bool]
            Set this field to enable or disable Landing pages on the
            sub-account

        meetings : typing.Optional[bool]
            Set this field to enable or disable Meetings on the sub-account

        sms_campaigns : typing.Optional[bool]
            Set this field to enable or disable SMS Marketing on the
            sub-account

        transactional_emails : typing.Optional[bool]
            Set this field to enable or disable Transactional Email on the
            sub-account

        transactional_sms : typing.Optional[bool]
            Set this field to enable or disable Transactional SMS on the
            sub-account

        web_push : typing.Optional[bool]
            Set this field to enable or disable Web Push on the sub-account

        whatsapp : typing.Optional[bool]
            Set this field to enable or disable Whatsapp campaigns on the
            sub-account

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"corporate/subAccount/{jsonable_encoder(id)}/applications/toggle",
            method="PUT",
            json={
                "automation": automation,
                "conversations": conversations,
                "crm": crm,
                "email-campaigns": email_campaigns,
                "facebook-ads": facebook_ads,
                "inbox": inbox,
                "landing-pages": landing_pages,
                "meetings": meetings,
                "sms-campaigns": sms_campaigns,
                "transactional-emails": transactional_emails,
                "transactional-sms": transactional_sms,
                "web-push": web_push,
                "whatsapp": whatsapp,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def update_sub_account_plan(
        self,
        id: int,
        *,
        credits: typing.Optional[PutCorporateSubAccountIdPlanRequestCredits] = OMIT,
        features: typing.Optional[PutCorporateSubAccountIdPlanRequestFeatures] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        This endpoint will update the sub-account plan. On the Corporate solution
        new version v2, you can set an unlimited number of credits in your
        sub-organization. Please pass the value “-1" to set the consumable in
        unlimited mode.

        Parameters
        ----------
        id : int
            Id of the sub-account organization

        credits : typing.Optional[PutCorporateSubAccountIdPlanRequestCredits]
            Credit details to update

        features : typing.Optional[PutCorporateSubAccountIdPlanRequestFeatures]
            Features details to update

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"corporate/subAccount/{jsonable_encoder(id)}/plan",
            method="PUT",
            json={
                "credits": convert_and_respect_annotation_metadata(
                    object_=credits, annotation=PutCorporateSubAccountIdPlanRequestCredits, direction="write"
                ),
                "features": convert_and_respect_annotation_metadata(
                    object_=features, annotation=PutCorporateSubAccountIdPlanRequestFeatures, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def update_sub_accounts_plan(
        self,
        *,
        credits: typing.Optional[PutCorporateSubAccountsPlanRequestCredits] = OMIT,
        features: typing.Optional[PutCorporateSubAccountsPlanRequestFeatures] = OMIT,
        sub_account_ids: typing.Optional[typing.Sequence[int]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        This endpoint will update multiple sub-accounts plan. On the Corporate
        solution new version v2, you can set an unlimited number of credits in your
        sub-organization. Please pass the value “-1" to set the consumable in
        unlimited mode.

        Parameters
        ----------
        credits : typing.Optional[PutCorporateSubAccountsPlanRequestCredits]
            Credit details to update

        features : typing.Optional[PutCorporateSubAccountsPlanRequestFeatures]
            Features details to update

        sub_account_ids : typing.Optional[typing.Sequence[int]]
            List of sub-account ids

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            "corporate/subAccounts/plan",
            method="PUT",
            json={
                "credits": convert_and_respect_annotation_metadata(
                    object_=credits, annotation=PutCorporateSubAccountsPlanRequestCredits, direction="write"
                ),
                "features": convert_and_respect_annotation_metadata(
                    object_=features, annotation=PutCorporateSubAccountsPlanRequestFeatures, direction="write"
                ),
                "subAccountIds": sub_account_ids,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def invite_admin_user(
        self,
        *,
        all_features_access: bool,
        email: str,
        privileges: typing.Sequence[InviteAdminUserRequestPrivilegesItem],
        group_ids: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[InviteAdminUserResponse]:
        """
        `This endpoint allows you to invite a member to manage the Admin account
        Features and their respective permissions are as below: - `my_plan`:
          - "all"
        - `api`:
          - "none"
        - `user_management`:
          - "all"
        - `app_management` | Not available in ENTv2:
          - "all"
        - `sub_organization_groups`
          - "create"
          - "edit_delete"
        - `create_sub_organizations`
          - "all"
        - `manage_sub_organizations`
          - "all"
        - `analytics`
          - "download_data"
          - "create_alerts"
          - "my_looks"
          - "explore_create"
        - `security`
          - "all"
        **Note**: - If `all_features_access: false` then only privileges are
        required otherwise if `true` then it's assumed that all permissions will be
        there for the invited admin user.

        Parameters
        ----------
        all_features_access : bool
            All access to the features

        email : str
            Email address for the organization

        privileges : typing.Sequence[InviteAdminUserRequestPrivilegesItem]

        group_ids : typing.Optional[typing.Sequence[str]]
            Ids of Group

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[InviteAdminUserResponse]
            Invitation ID
        """
        _response = self._client_wrapper.httpx_client.request(
            "corporate/user/invitation/send",
            method="POST",
            json={
                "all_features_access": all_features_access,
                "email": email,
                "groupIds": group_ids,
                "privileges": convert_and_respect_annotation_metadata(
                    object_=privileges,
                    annotation=typing.Sequence[InviteAdminUserRequestPrivilegesItem],
                    direction="write",
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    InviteAdminUserResponse,
                    construct_type(
                        type_=InviteAdminUserResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def resend_cancel_admin_user_invitation(
        self,
        action: PutCorporateUserInvitationActionEmailRequestAction,
        email: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[PutCorporateUserInvitationActionEmailResponse]:
        """
        This endpoint will allow the user to:
        - Resend an admin user invitation
        - Cancel an admin user invitation

        Parameters
        ----------
        action : PutCorporateUserInvitationActionEmailRequestAction
            Action to be performed (cancel / resend)

        email : str
            Email address of the recipient

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[PutCorporateUserInvitationActionEmailResponse]
            Response of the action performed
        """
        _response = self._client_wrapper.httpx_client.request(
            f"corporate/user/invitation/{jsonable_encoder(action)}/{jsonable_encoder(email)}",
            method="PUT",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PutCorporateUserInvitationActionEmailResponse,
                    construct_type(
                        type_=PutCorporateUserInvitationActionEmailResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def revoke_an_admin_user(
        self, email: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[None]:
        """
        This endpoint allows to revoke/remove an invited member of your Admin
        account

        Parameters
        ----------
        email : str
            Email of the invited user

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"corporate/user/revoke/{jsonable_encoder(email)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_corporate_user_permission(
        self, email: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[GetCorporateUserPermissionResponse]:
        """
        This endpoint will provide the list of admin user permissions

        Parameters
        ----------
        email : str
            Email of the invited user.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetCorporateUserPermissionResponse]
            List of user's permissions
        """
        _response = self._client_wrapper.httpx_client.request(
            f"corporate/user/{jsonable_encoder(email)}/permissions",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetCorporateUserPermissionResponse,
                    construct_type(
                        type_=GetCorporateUserPermissionResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def change_admin_user_permissions(
        self,
        email: str,
        *,
        all_features_access: bool,
        privileges: typing.Sequence[PutCorporateUserEmailPermissionsRequestPrivilegesItem],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        This endpoint will allow you to change the permissions of Admin users of
        your Admin account

        Parameters
        ----------
        email : str
            Email address of Admin user

        all_features_access : bool
            All access to the features

        privileges : typing.Sequence[PutCorporateUserEmailPermissionsRequestPrivilegesItem]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"corporate/user/{jsonable_encoder(email)}/permissions",
            method="PUT",
            json={
                "all_features_access": all_features_access,
                "privileges": convert_and_respect_annotation_metadata(
                    object_=privileges,
                    annotation=typing.Sequence[PutCorporateUserEmailPermissionsRequestPrivilegesItem],
                    direction="write",
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawMasterAccountClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def create_a_new_group_of_sub_accounts(
        self,
        *,
        group_name: str,
        sub_account_ids: typing.Optional[typing.Sequence[int]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[PostCorporateGroupResponse]:
        """
        This endpoint allows to create a group of sub-accounts

        Parameters
        ----------
        group_name : str
            The name of the group of sub-accounts

        sub_account_ids : typing.Optional[typing.Sequence[int]]
            Pass the list of sub-account Ids to be included in the group

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[PostCorporateGroupResponse]
            Group ID
        """
        _response = await self._client_wrapper.httpx_client.request(
            "corporate/group",
            method="POST",
            json={
                "groupName": group_name,
                "subAccountIds": sub_account_ids,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PostCorporateGroupResponse,
                    construct_type(
                        type_=PostCorporateGroupResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def delete_sub_account_from_group(
        self,
        group_id: str,
        *,
        sub_account_ids: typing.Sequence[int],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        This endpoint allows you to remove a sub-organization from a group.

        Parameters
        ----------
        group_id : str
            Group id

        sub_account_ids : typing.Sequence[int]
            List of sub-account ids

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"corporate/group/unlink/{jsonable_encoder(group_id)}/subAccounts",
            method="PUT",
            json={
                "subAccountIds": sub_account_ids,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_a_group_details(
        self, id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[GetCorporateGroupIdResponse]:
        """
        This endpoint allows you to retrieve a specific group’s information such as
        the list of sub-organizations and the user associated with the group.

        Parameters
        ----------
        id : str
            Id of the group of sub-organization

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetCorporateGroupIdResponse]
            Group details
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"corporate/group/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetCorporateGroupIdResponse,
                    construct_type(
                        type_=GetCorporateGroupIdResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def update_a_group_of_sub_accounts(
        self,
        id: str,
        *,
        group_name: typing.Optional[str] = OMIT,
        sub_account_ids: typing.Optional[typing.Sequence[int]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        This endpoint allows to update a group of sub-accounts

        Parameters
        ----------
        id : str
            Id of the group

        group_name : typing.Optional[str]
            The name of the group of sub-accounts

        sub_account_ids : typing.Optional[typing.Sequence[int]]
            Pass the list of sub-account Ids to be included in the group

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"corporate/group/{jsonable_encoder(id)}",
            method="PUT",
            json={
                "groupName": group_name,
                "subAccountIds": sub_account_ids,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def delete_a_group(
        self, id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[None]:
        """
        This endpoint allows you to delete a group of sub-organizations. When a
        group is deleted, the sub-organizations are no longer part of this group.
        The users associated with the group are no longer associated with the group
        once deleted.

        Parameters
        ----------
        id : str
            Id of the group

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"corporate/group/{jsonable_encoder(id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_sub_account_groups(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[typing.List[GetSubAccountGroupsResponseItem]]:
        """
        This endpoint allows you to list all groups created on your Admin account.

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[GetSubAccountGroupsResponseItem]]
            list of all the sub-account groups
        """
        _response = await self._client_wrapper.httpx_client.request(
            "corporate/groups",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[GetSubAccountGroupsResponseItem],
                    construct_type(
                        type_=typing.List[GetSubAccountGroupsResponseItem],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_corporate_invited_users_list(
        self,
        *,
        type: typing.Optional[str] = None,
        offset: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[GetCorporateInvitedUsersListResponse]:
        """
        This endpoint allows you to list all Admin users of your Admin account. You
        can filter users by type (active or pending) and paginate results using
        offset and limit.

        Parameters
        ----------
        type : typing.Optional[str]
            User type (active | pending). This is required if offset is provided for
            limited result.

        offset : typing.Optional[int]
            Page number for the result set. This is optional, default value will be
            the 1st page.

        limit : typing.Optional[int]
            Number of users to be displayed on each page. This is optional, the
            default limit is 20, but max allowed limit is 100.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetCorporateInvitedUsersListResponse]
            list of all admin users
        """
        _response = await self._client_wrapper.httpx_client.request(
            "corporate/invited/users",
            method="GET",
            params={
                "type": type,
                "offset": offset,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetCorporateInvitedUsersListResponse,
                    construct_type(
                        type_=GetCorporateInvitedUsersListResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def list_of_all_i_ps(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[typing.List[GetCorporateIpResponseItem]]:
        """
        This endpoint allows you to retrieve the list of active IPs on your Admin
        account

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[GetCorporateIpResponseItem]]
            List of all IPs
        """
        _response = await self._client_wrapper.httpx_client.request(
            "corporate/ip",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[GetCorporateIpResponseItem],
                    construct_type(
                        type_=typing.List[GetCorporateIpResponseItem],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_the_details_of_requested_master_account(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[GetCorporateMasterAccountResponse]:
        """
        This endpoint will provide the details of the master account.

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetCorporateMasterAccountResponse]
            Master account details
        """
        _response = await self._client_wrapper.httpx_client.request(
            "corporate/masterAccount",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetCorporateMasterAccountResponse,
                    construct_type(
                        type_=GetCorporateMasterAccountResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def generate_sso_token_to_access_admin_account(
        self, *, email: str, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[GetSsoToken]:
        """
        This endpoint generates an SSO token to authenticate and access the admin
        account using the endpoint
        https://account-app.brevo.com/account/login/corporate/sso/[token], where
        [token] will be replaced by the actual token.

        Parameters
        ----------
        email : str
            User email of admin account

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetSsoToken]
            Session token
        """
        _response = await self._client_wrapper.httpx_client.request(
            "corporate/ssoToken",
            method="POST",
            json={
                "email": email,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetSsoToken,
                    construct_type(
                        type_=GetSsoToken,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_the_list_of_all_the_sub_accounts_of_the_master_account(
        self, *, offset: int, limit: int, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[GetCorporateSubAccountResponse]:
        """
        This endpoint will provide the list all the sub-accounts of the master
        account.

        Parameters
        ----------
        offset : int
            Index of the first sub-account in the page

        limit : int
            Number of sub-accounts to be displayed on each page

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetCorporateSubAccountResponse]
            Sub-accounts list
        """
        _response = await self._client_wrapper.httpx_client.request(
            "corporate/subAccount",
            method="GET",
            params={
                "offset": offset,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetCorporateSubAccountResponse,
                    construct_type(
                        type_=GetCorporateSubAccountResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def create_a_new_sub_account_under_a_master_account(
        self,
        *,
        company_name: str,
        email: str,
        group_ids: typing.Optional[typing.Sequence[str]] = OMIT,
        language: typing.Optional[PostCorporateSubAccountRequestLanguage] = OMIT,
        timezone: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[PostCorporateSubAccountResponse]:
        """
        This endpoint will create a new sub-account under a master account

        Parameters
        ----------
        company_name : str
            Set the name of the sub-account company

        email : str
            Email address for the organization

        group_ids : typing.Optional[typing.Sequence[str]]
            Set the group(s) for the sub-account

        language : typing.Optional[PostCorporateSubAccountRequestLanguage]
            Set the language of the sub-account

        timezone : typing.Optional[str]
            Set the timezone of the sub-account

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[PostCorporateSubAccountResponse]
            Created sub-account ID
        """
        _response = await self._client_wrapper.httpx_client.request(
            "corporate/subAccount",
            method="POST",
            json={
                "companyName": company_name,
                "email": email,
                "groupIds": group_ids,
                "language": language,
                "timezone": timezone,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PostCorporateSubAccountResponse,
                    construct_type(
                        type_=PostCorporateSubAccountResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def associate_an_ip_to_sub_accounts(
        self, *, ids: typing.Sequence[int], ip: str, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[typing.Dict[str, typing.Any]]:
        """
        This endpoint allows to associate an IP to sub-accounts

        Parameters
        ----------
        ids : typing.Sequence[int]
            Pass the list of sub-account Ids to be associated with the IP
            address

        ip : str
            IP address

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.Dict[str, typing.Any]]
            IP has been associated with sub-accounts successfully
        """
        _response = await self._client_wrapper.httpx_client.request(
            "corporate/subAccount/ip/associate",
            method="POST",
            json={
                "ids": ids,
                "ip": ip,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Dict[str, typing.Any],
                    construct_type(
                        type_=typing.Dict[str, typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def dissociate_an_ip_to_sub_accounts(
        self, *, ids: typing.Sequence[int], ip: str, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[None]:
        """
        This endpoint allows to dissociate an IP from sub-accounts

        Parameters
        ----------
        ids : typing.Sequence[int]
            Pass the list of sub-account Ids to be dissociated from the IP
            address

        ip : str
            IP address

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            "corporate/subAccount/ip/dissociate",
            method="PUT",
            json={
                "ids": ids,
                "ip": ip,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def create_an_api_key_for_a_sub_account(
        self, *, id: int, name: str, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[PostCorporateSubAccountKeyResponse]:
        """
        This endpoint will generate an API v3 key for a sub-account

        Parameters
        ----------
        id : int
            Id of the sub-account organization

        name : str
            Name of the API key

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[PostCorporateSubAccountKeyResponse]
            API key
        """
        _response = await self._client_wrapper.httpx_client.request(
            "corporate/subAccount/key",
            method="POST",
            json={
                "id": id,
                "name": name,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PostCorporateSubAccountKeyResponse,
                    construct_type(
                        type_=PostCorporateSubAccountKeyResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def generate_sso_token_to_access_sub_account(
        self,
        *,
        id: int,
        email: typing.Optional[str] = OMIT,
        target: typing.Optional[PostCorporateSubAccountSsoTokenRequestTarget] = OMIT,
        url: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[GetSsoToken]:
        """
        This endpoint generates an sso token to authenticate and access a
        sub-account of the master using the account endpoint
        https://account-app.brevo.com/account/login/sub-account/sso/[token], where
        [token] will be replaced by the actual token.

        Parameters
        ----------
        id : int
            Id of the sub-account organization

        email : typing.Optional[str]
            User email of sub-account organization

        target : typing.Optional[PostCorporateSubAccountSsoTokenRequestTarget]
            **Set target after login success** * **automation** - Redirect
            to Automation after login * **email_campaign** - Redirect to
            Email Campaign after login * **contacts** - Redirect to Contacts
            after login * **landing_pages** - Redirect to Landing Pages
            after login * **email_transactional** - Redirect to Email
            Transactional after login * **senders** - Redirect to Senders
            after login * **sms_campaign** - Redirect to Sms Campaign after
            login * **sms_transactional** - Redirect to Sms Transactional
            after login

        url : typing.Optional[str]
            Set the full target URL after login success. The user will land
            directly on this target URL after login

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetSsoToken]
            Session token
        """
        _response = await self._client_wrapper.httpx_client.request(
            "corporate/subAccount/ssoToken",
            method="POST",
            json={
                "email": email,
                "id": id,
                "target": target,
                "url": url,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetSsoToken,
                    construct_type(
                        type_=GetSsoToken,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_sub_account_details(
        self, id: int, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[GetCorporateSubAccountIdResponse]:
        """
        This endpoint will provide the details for the specified sub-account company

        Parameters
        ----------
        id : int
            Id of the sub-account organization

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetCorporateSubAccountIdResponse]
            Sub-account organization details
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"corporate/subAccount/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetCorporateSubAccountIdResponse,
                    construct_type(
                        type_=GetCorporateSubAccountIdResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def delete_a_sub_account(
        self, id: int, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        id : int
            Id of the sub-account organization to be deleted

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"corporate/subAccount/{jsonable_encoder(id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def enable_disable_sub_account_application_s(
        self,
        id: int,
        *,
        automation: typing.Optional[bool] = OMIT,
        conversations: typing.Optional[bool] = OMIT,
        crm: typing.Optional[bool] = OMIT,
        email_campaigns: typing.Optional[bool] = OMIT,
        facebook_ads: typing.Optional[bool] = OMIT,
        inbox: typing.Optional[bool] = OMIT,
        landing_pages: typing.Optional[bool] = OMIT,
        meetings: typing.Optional[bool] = OMIT,
        sms_campaigns: typing.Optional[bool] = OMIT,
        transactional_emails: typing.Optional[bool] = OMIT,
        transactional_sms: typing.Optional[bool] = OMIT,
        web_push: typing.Optional[bool] = OMIT,
        whatsapp: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        API endpoint for the Corporate owner to enable/disable applications on the
        sub-account

        Parameters
        ----------
        id : int
            Id of the sub-account organization (mandatory)

        automation : typing.Optional[bool]
            Set this field to enable or disable Automation on the
            sub-account

        conversations : typing.Optional[bool]
            Set this field to enable or disable Conversations on the
            sub-account

        crm : typing.Optional[bool]
            Set this field to enable or disable Sales CRM on the sub-account

        email_campaigns : typing.Optional[bool]
            Set this field to enable or disable Email Campaigns on the
            sub-account

        facebook_ads : typing.Optional[bool]
            Set this field to enable or disable Facebook ads on the
            sub-account

        inbox : typing.Optional[bool]
            Set this field to enable or disable Inbox on the sub-account /
            Not applicable on ENTv2

        landing_pages : typing.Optional[bool]
            Set this field to enable or disable Landing pages on the
            sub-account

        meetings : typing.Optional[bool]
            Set this field to enable or disable Meetings on the sub-account

        sms_campaigns : typing.Optional[bool]
            Set this field to enable or disable SMS Marketing on the
            sub-account

        transactional_emails : typing.Optional[bool]
            Set this field to enable or disable Transactional Email on the
            sub-account

        transactional_sms : typing.Optional[bool]
            Set this field to enable or disable Transactional SMS on the
            sub-account

        web_push : typing.Optional[bool]
            Set this field to enable or disable Web Push on the sub-account

        whatsapp : typing.Optional[bool]
            Set this field to enable or disable Whatsapp campaigns on the
            sub-account

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"corporate/subAccount/{jsonable_encoder(id)}/applications/toggle",
            method="PUT",
            json={
                "automation": automation,
                "conversations": conversations,
                "crm": crm,
                "email-campaigns": email_campaigns,
                "facebook-ads": facebook_ads,
                "inbox": inbox,
                "landing-pages": landing_pages,
                "meetings": meetings,
                "sms-campaigns": sms_campaigns,
                "transactional-emails": transactional_emails,
                "transactional-sms": transactional_sms,
                "web-push": web_push,
                "whatsapp": whatsapp,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def update_sub_account_plan(
        self,
        id: int,
        *,
        credits: typing.Optional[PutCorporateSubAccountIdPlanRequestCredits] = OMIT,
        features: typing.Optional[PutCorporateSubAccountIdPlanRequestFeatures] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        This endpoint will update the sub-account plan. On the Corporate solution
        new version v2, you can set an unlimited number of credits in your
        sub-organization. Please pass the value “-1" to set the consumable in
        unlimited mode.

        Parameters
        ----------
        id : int
            Id of the sub-account organization

        credits : typing.Optional[PutCorporateSubAccountIdPlanRequestCredits]
            Credit details to update

        features : typing.Optional[PutCorporateSubAccountIdPlanRequestFeatures]
            Features details to update

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"corporate/subAccount/{jsonable_encoder(id)}/plan",
            method="PUT",
            json={
                "credits": convert_and_respect_annotation_metadata(
                    object_=credits, annotation=PutCorporateSubAccountIdPlanRequestCredits, direction="write"
                ),
                "features": convert_and_respect_annotation_metadata(
                    object_=features, annotation=PutCorporateSubAccountIdPlanRequestFeatures, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def update_sub_accounts_plan(
        self,
        *,
        credits: typing.Optional[PutCorporateSubAccountsPlanRequestCredits] = OMIT,
        features: typing.Optional[PutCorporateSubAccountsPlanRequestFeatures] = OMIT,
        sub_account_ids: typing.Optional[typing.Sequence[int]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        This endpoint will update multiple sub-accounts plan. On the Corporate
        solution new version v2, you can set an unlimited number of credits in your
        sub-organization. Please pass the value “-1" to set the consumable in
        unlimited mode.

        Parameters
        ----------
        credits : typing.Optional[PutCorporateSubAccountsPlanRequestCredits]
            Credit details to update

        features : typing.Optional[PutCorporateSubAccountsPlanRequestFeatures]
            Features details to update

        sub_account_ids : typing.Optional[typing.Sequence[int]]
            List of sub-account ids

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            "corporate/subAccounts/plan",
            method="PUT",
            json={
                "credits": convert_and_respect_annotation_metadata(
                    object_=credits, annotation=PutCorporateSubAccountsPlanRequestCredits, direction="write"
                ),
                "features": convert_and_respect_annotation_metadata(
                    object_=features, annotation=PutCorporateSubAccountsPlanRequestFeatures, direction="write"
                ),
                "subAccountIds": sub_account_ids,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def invite_admin_user(
        self,
        *,
        all_features_access: bool,
        email: str,
        privileges: typing.Sequence[InviteAdminUserRequestPrivilegesItem],
        group_ids: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[InviteAdminUserResponse]:
        """
        `This endpoint allows you to invite a member to manage the Admin account
        Features and their respective permissions are as below: - `my_plan`:
          - "all"
        - `api`:
          - "none"
        - `user_management`:
          - "all"
        - `app_management` | Not available in ENTv2:
          - "all"
        - `sub_organization_groups`
          - "create"
          - "edit_delete"
        - `create_sub_organizations`
          - "all"
        - `manage_sub_organizations`
          - "all"
        - `analytics`
          - "download_data"
          - "create_alerts"
          - "my_looks"
          - "explore_create"
        - `security`
          - "all"
        **Note**: - If `all_features_access: false` then only privileges are
        required otherwise if `true` then it's assumed that all permissions will be
        there for the invited admin user.

        Parameters
        ----------
        all_features_access : bool
            All access to the features

        email : str
            Email address for the organization

        privileges : typing.Sequence[InviteAdminUserRequestPrivilegesItem]

        group_ids : typing.Optional[typing.Sequence[str]]
            Ids of Group

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[InviteAdminUserResponse]
            Invitation ID
        """
        _response = await self._client_wrapper.httpx_client.request(
            "corporate/user/invitation/send",
            method="POST",
            json={
                "all_features_access": all_features_access,
                "email": email,
                "groupIds": group_ids,
                "privileges": convert_and_respect_annotation_metadata(
                    object_=privileges,
                    annotation=typing.Sequence[InviteAdminUserRequestPrivilegesItem],
                    direction="write",
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    InviteAdminUserResponse,
                    construct_type(
                        type_=InviteAdminUserResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def resend_cancel_admin_user_invitation(
        self,
        action: PutCorporateUserInvitationActionEmailRequestAction,
        email: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[PutCorporateUserInvitationActionEmailResponse]:
        """
        This endpoint will allow the user to:
        - Resend an admin user invitation
        - Cancel an admin user invitation

        Parameters
        ----------
        action : PutCorporateUserInvitationActionEmailRequestAction
            Action to be performed (cancel / resend)

        email : str
            Email address of the recipient

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[PutCorporateUserInvitationActionEmailResponse]
            Response of the action performed
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"corporate/user/invitation/{jsonable_encoder(action)}/{jsonable_encoder(email)}",
            method="PUT",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PutCorporateUserInvitationActionEmailResponse,
                    construct_type(
                        type_=PutCorporateUserInvitationActionEmailResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def revoke_an_admin_user(
        self, email: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[None]:
        """
        This endpoint allows to revoke/remove an invited member of your Admin
        account

        Parameters
        ----------
        email : str
            Email of the invited user

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"corporate/user/revoke/{jsonable_encoder(email)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_corporate_user_permission(
        self, email: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[GetCorporateUserPermissionResponse]:
        """
        This endpoint will provide the list of admin user permissions

        Parameters
        ----------
        email : str
            Email of the invited user.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetCorporateUserPermissionResponse]
            List of user's permissions
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"corporate/user/{jsonable_encoder(email)}/permissions",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetCorporateUserPermissionResponse,
                    construct_type(
                        type_=GetCorporateUserPermissionResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def change_admin_user_permissions(
        self,
        email: str,
        *,
        all_features_access: bool,
        privileges: typing.Sequence[PutCorporateUserEmailPermissionsRequestPrivilegesItem],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        This endpoint will allow you to change the permissions of Admin users of
        your Admin account

        Parameters
        ----------
        email : str
            Email address of Admin user

        all_features_access : bool
            All access to the features

        privileges : typing.Sequence[PutCorporateUserEmailPermissionsRequestPrivilegesItem]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"corporate/user/{jsonable_encoder(email)}/permissions",
            method="PUT",
            json={
                "all_features_access": all_features_access,
                "privileges": convert_and_respect_annotation_metadata(
                    object_=privileges,
                    annotation=typing.Sequence[PutCorporateUserEmailPermissionsRequestPrivilegesItem],
                    direction="write",
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)
