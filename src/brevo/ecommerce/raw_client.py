# This file was auto-generated by Fern from our API Definition.

import datetime as dt
import typing
from json.decoder import JSONDecodeError

from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.datetime_utils import serialize_datetime
from ..core.http_response import AsyncHttpResponse, HttpResponse
from ..core.jsonable_encoder import jsonable_encoder
from ..core.request_options import RequestOptions
from ..core.serialization import convert_and_respect_annotation_metadata
from ..core.unchecked_base_model import construct_type
from ..errors.bad_request_error import BadRequestError
from ..errors.forbidden_error import ForbiddenError
from ..errors.not_found_error import NotFoundError
from ..errors.unauthorized_error import UnauthorizedError
from ..errors.unprocessable_entity_error import UnprocessableEntityError
from ..types.error_model import ErrorModel
from ..types.get_category_details import GetCategoryDetails
from ..types.get_product_details import GetProductDetails
from ..types.order import Order
from ..types.order_billing import OrderBilling
from ..types.order_identifiers import OrderIdentifiers
from ..types.order_meta_info_value import OrderMetaInfoValue
from ..types.order_products_item import OrderProductsItem
from .types.create_batch_order_response import CreateBatchOrderResponse
from .types.create_product_alert_request_contact_identifiers import CreateProductAlertRequestContactIdentifiers
from .types.create_update_batch_category_request_categories_item import CreateUpdateBatchCategoryRequestCategoriesItem
from .types.create_update_batch_category_response import CreateUpdateBatchCategoryResponse
from .types.create_update_batch_products_request_products_item import CreateUpdateBatchProductsRequestProductsItem
from .types.create_update_batch_products_response import CreateUpdateBatchProductsResponse
from .types.create_update_category_response import CreateUpdateCategoryResponse
from .types.create_update_product_request_meta_info_value import CreateUpdateProductRequestMetaInfoValue
from .types.create_update_product_response import CreateUpdateProductResponse
from .types.get_categories_request_sort import GetCategoriesRequestSort
from .types.get_categories_response import GetCategoriesResponse
from .types.get_ecommerce_attribution_metrics_conversion_source_conversion_source_id_request_conversion_source import (
    GetEcommerceAttributionMetricsConversionSourceConversionSourceIdRequestConversionSource,
)
from .types.get_ecommerce_attribution_metrics_conversion_source_conversion_source_id_response import (
    GetEcommerceAttributionMetricsConversionSourceConversionSourceIdResponse,
)
from .types.get_ecommerce_attribution_metrics_response import GetEcommerceAttributionMetricsResponse
from .types.get_ecommerce_attribution_products_conversion_source_conversion_source_id_request_conversion_source import (
    GetEcommerceAttributionProductsConversionSourceConversionSourceIdRequestConversionSource,
)
from .types.get_ecommerce_attribution_products_conversion_source_conversion_source_id_response import (
    GetEcommerceAttributionProductsConversionSourceConversionSourceIdResponse,
)
from .types.get_ecommerce_config_display_currency_response import GetEcommerceConfigDisplayCurrencyResponse
from .types.get_orders_request_sort import GetOrdersRequestSort
from .types.get_products_request_sort import GetProductsRequestSort
from .types.get_products_response import GetProductsResponse
from .types.set_config_display_currency_response import SetConfigDisplayCurrencyResponse

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawEcommerceClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def get_categories(
        self,
        *,
        limit: typing.Optional[int] = None,
        offset: typing.Optional[int] = None,
        sort: typing.Optional[GetCategoriesRequestSort] = None,
        ids: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        name: typing.Optional[str] = None,
        modified_since: typing.Optional[str] = None,
        created_since: typing.Optional[str] = None,
        is_deleted: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[GetCategoriesResponse]:
        """
        Parameters
        ----------
        limit : typing.Optional[int]
            Number of documents per page

        offset : typing.Optional[int]
            Index of the first document in the page

        sort : typing.Optional[GetCategoriesRequestSort]
            Sort the results in the ascending/descending order of record creation. Default order is **descending** if `sort` is not passed

        ids : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            Filter by category ids

        name : typing.Optional[str]
            Filter by category name

        modified_since : typing.Optional[str]
            Filter (urlencoded) the categories modified after a given UTC date-time (YYYY-MM-DDTHH:mm:ss.SSSZ). **Prefer to pass your timezone in date-time format for accurate result.**

        created_since : typing.Optional[str]
            Filter (urlencoded) the categories created after a given UTC date-time (YYYY-MM-DDTHH:mm:ss.SSSZ). **Prefer to pass your timezone in date-time format for accurate result.**

        is_deleted : typing.Optional[str]
            Filter categories by their deletion status. If `false` is passed, only categories that are not deleted will be returned.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetCategoriesResponse]
            All categories listed
        """
        _response = self._client_wrapper.httpx_client.request(
            "categories",
            method="GET",
            params={
                "limit": limit,
                "offset": offset,
                "sort": sort,
                "ids": ids,
                "name": name,
                "modifiedSince": modified_since,
                "createdSince": created_since,
                "isDeleted": is_deleted,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetCategoriesResponse,
                    construct_type(
                        type_=GetCategoriesResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def create_update_category(
        self,
        *,
        id: str,
        deleted_at: typing.Optional[str] = OMIT,
        is_deleted: typing.Optional[bool] = OMIT,
        name: typing.Optional[str] = OMIT,
        update_enabled: typing.Optional[bool] = OMIT,
        url: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[CreateUpdateCategoryResponse]:
        """
        Parameters
        ----------
        id : str
            Unique Category ID as saved in the shop

        deleted_at : typing.Optional[str]
            UTC date-time (YYYY-MM-DDTHH:mm:ss.SSSZ) of the category deleted from the shop's database

        is_deleted : typing.Optional[bool]
            category deleted from the shop's database

        name : typing.Optional[str]
            **Mandatory in case of creation**. Name of the Category, as displayed in the shop

        update_enabled : typing.Optional[bool]
            Facilitate to update the existing category in the same request (updateEnabled = true)

        url : typing.Optional[str]
            URL to the category

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[CreateUpdateCategoryResponse]
            Category created
        """
        _response = self._client_wrapper.httpx_client.request(
            "categories",
            method="POST",
            json={
                "deletedAt": deleted_at,
                "id": id,
                "isDeleted": is_deleted,
                "name": name,
                "updateEnabled": update_enabled,
                "url": url,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CreateUpdateCategoryResponse,
                    construct_type(
                        type_=CreateUpdateCategoryResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def create_update_batch_category(
        self,
        *,
        categories: typing.Sequence[CreateUpdateBatchCategoryRequestCategoriesItem],
        update_enabled: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[CreateUpdateBatchCategoryResponse]:
        """
        Parameters
        ----------
        categories : typing.Sequence[CreateUpdateBatchCategoryRequestCategoriesItem]
            array of categories objects

        update_enabled : typing.Optional[bool]
            Facilitate to update the existing categories in the same request (updateEnabled = true)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[CreateUpdateBatchCategoryResponse]
            Category created and updated
        """
        _response = self._client_wrapper.httpx_client.request(
            "categories/batch",
            method="POST",
            json={
                "categories": convert_and_respect_annotation_metadata(
                    object_=categories,
                    annotation=typing.Sequence[CreateUpdateBatchCategoryRequestCategoriesItem],
                    direction="write",
                ),
                "updateEnabled": update_enabled,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CreateUpdateBatchCategoryResponse,
                    construct_type(
                        type_=CreateUpdateBatchCategoryResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_category_info(
        self, id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[GetCategoryDetails]:
        """
        Parameters
        ----------
        id : str
            Category ID

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetCategoryDetails]
            Category informations
        """
        _response = self._client_wrapper.httpx_client.request(
            f"categories/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetCategoryDetails,
                    construct_type(
                        type_=GetCategoryDetails,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def activate_the_e_commerce_app(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[None]:
        """
        Getting access to Brevo eCommerce.

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            "ecommerce/activate",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_attribution_metrics_for_one_or_more_brevo_campaigns_or_workflows(
        self,
        *,
        period_from: typing.Optional[dt.datetime] = None,
        period_to: typing.Optional[dt.datetime] = None,
        email_campaign_id_array: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        sms_campaign_id_array: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        automation_workflow_email_id_array: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        automation_workflow_sms_id_array: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[GetEcommerceAttributionMetricsResponse]:
        """
        Parameters
        ----------
        period_from : typing.Optional[dt.datetime]
            When getting metrics for a specific period, define the starting datetime in RFC3339 format

        period_to : typing.Optional[dt.datetime]
            When getting metrics for a specific period, define the end datetime in RFC3339 format

        email_campaign_id_array : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            The email campaign ID(s) to get metrics for

        sms_campaign_id_array : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            The SMS campaign ID(s) to get metrics for

        automation_workflow_email_id_array : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            The automation workflow ID(s) to get email attribution metrics for

        automation_workflow_sms_id_array : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            The automation workflow ID(s) to get SMS attribution metrics for

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetEcommerceAttributionMetricsResponse]
            OK
        """
        _response = self._client_wrapper.httpx_client.request(
            "ecommerce/attribution/metrics",
            method="GET",
            params={
                "periodFrom": serialize_datetime(period_from) if period_from is not None else None,
                "periodTo": serialize_datetime(period_to) if period_to is not None else None,
                "emailCampaignId[]": email_campaign_id_array,
                "smsCampaignId[]": sms_campaign_id_array,
                "automationWorkflowEmailId[]": automation_workflow_email_id_array,
                "automationWorkflowSmsId[]": automation_workflow_sms_id_array,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetEcommerceAttributionMetricsResponse,
                    construct_type(
                        type_=GetEcommerceAttributionMetricsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_detailed_attribution_metrics_for_a_single_brevo_campaign_or_workflow(
        self,
        conversion_source: GetEcommerceAttributionMetricsConversionSourceConversionSourceIdRequestConversionSource,
        conversion_source_id: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[GetEcommerceAttributionMetricsConversionSourceConversionSourceIdResponse]:
        """
        Parameters
        ----------
        conversion_source : GetEcommerceAttributionMetricsConversionSourceConversionSourceIdRequestConversionSource
            The Brevo campaign type or workflow type for which data will be retrieved

        conversion_source_id : str
            The Brevo campaign or automation workflow id for which data will be retrieved

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetEcommerceAttributionMetricsConversionSourceConversionSourceIdResponse]
            OK
        """
        _response = self._client_wrapper.httpx_client.request(
            f"ecommerce/attribution/metrics/{jsonable_encoder(conversion_source)}/{jsonable_encoder(conversion_source_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetEcommerceAttributionMetricsConversionSourceConversionSourceIdResponse,
                    construct_type(
                        type_=GetEcommerceAttributionMetricsConversionSourceConversionSourceIdResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_attributed_product_sales_for_a_single_brevo_campaign_or_workflow(
        self,
        conversion_source: GetEcommerceAttributionProductsConversionSourceConversionSourceIdRequestConversionSource,
        conversion_source_id: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[GetEcommerceAttributionProductsConversionSourceConversionSourceIdResponse]:
        """
        Parameters
        ----------
        conversion_source : GetEcommerceAttributionProductsConversionSourceConversionSourceIdRequestConversionSource
            The Brevo campaign or automation workflow type for which data will be retrieved

        conversion_source_id : str
            The Brevo campaign or automation workflow id for which data will be retrieved

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetEcommerceAttributionProductsConversionSourceConversionSourceIdResponse]
            OK
        """
        _response = self._client_wrapper.httpx_client.request(
            f"ecommerce/attribution/products/{jsonable_encoder(conversion_source)}/{jsonable_encoder(conversion_source_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetEcommerceAttributionProductsConversionSourceConversionSourceIdResponse,
                    construct_type(
                        type_=GetEcommerceAttributionProductsConversionSourceConversionSourceIdResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_the_iso4217compliant_display_currency_code_for_your_brevo_account(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[GetEcommerceConfigDisplayCurrencyResponse]:
        """
        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetEcommerceConfigDisplayCurrencyResponse]
            OK
        """
        _response = self._client_wrapper.httpx_client.request(
            "ecommerce/config/displayCurrency",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetEcommerceConfigDisplayCurrencyResponse,
                    construct_type(
                        type_=GetEcommerceConfigDisplayCurrencyResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def set_config_display_currency(
        self, *, code: str, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[SetConfigDisplayCurrencyResponse]:
        """
        Parameters
        ----------
        code : str
            ISO 4217 compliant display currency code

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[SetConfigDisplayCurrencyResponse]
            OK
        """
        _response = self._client_wrapper.httpx_client.request(
            "ecommerce/config/displayCurrency",
            method="POST",
            json={
                "code": code,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SetConfigDisplayCurrencyResponse,
                    construct_type(
                        type_=SetConfigDisplayCurrencyResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorModel,
                        construct_type(
                            type_=ErrorModel,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_orders(
        self,
        *,
        limit: typing.Optional[int] = None,
        offset: typing.Optional[int] = None,
        sort: typing.Optional[GetOrdersRequestSort] = None,
        modified_since: typing.Optional[str] = None,
        created_since: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.Any]:
        """
        Get all the orders

        Parameters
        ----------
        limit : typing.Optional[int]
            Number of documents per page

        offset : typing.Optional[int]
            Index of the first document in the page

        sort : typing.Optional[GetOrdersRequestSort]
            Sort the results in the ascending/descending order of record creation. Default order is **descending** if `sort` is not passed

        modified_since : typing.Optional[str]
            Filter (urlencoded) the orders modified after a given UTC date-time (YYYY-MM-DDTHH:mm:ss.SSSZ). **Prefer to pass your timezone in date-time format for accurate result.**

        created_since : typing.Optional[str]
            Filter (urlencoded) the orders created after a given UTC date-time (YYYY-MM-DDTHH:mm:ss.SSSZ). **Prefer to pass your timezone in date-time format for accurate result.**

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.Any]
            orders fetched successfully
        """
        _response = self._client_wrapper.httpx_client.request(
            "orders",
            method="GET",
            params={
                "limit": limit,
                "offset": offset,
                "sort": sort,
                "modifiedSince": modified_since,
                "createdSince": created_since,
            },
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return HttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Any,
                    construct_type(
                        type_=typing.Any,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def create_order(
        self,
        *,
        amount: float,
        created_at: str,
        id: str,
        products: typing.Sequence[OrderProductsItem],
        status: str,
        updated_at: str,
        billing: typing.Optional[OrderBilling] = OMIT,
        coupons: typing.Optional[typing.Sequence[str]] = OMIT,
        identifiers: typing.Optional[OrderIdentifiers] = OMIT,
        meta_info: typing.Optional[typing.Dict[str, OrderMetaInfoValue]] = OMIT,
        store_id: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Manages the transactional status of the order

        Parameters
        ----------
        amount : float
            Total amount of the order, including all shipping expenses, tax and the price of items.

        created_at : str
            Event occurrence UTC date-time (YYYY-MM-DDTHH:mm:ssZ), when order is actually created.

        id : str
            Unique ID of the order.

        products : typing.Sequence[OrderProductsItem]

        status : str
            State of the order.

        updated_at : str
            Event updated UTC date-time (YYYY-MM-DDTHH:mm:ssZ), when the status of the order is actually changed/updated.

        billing : typing.Optional[OrderBilling]
            Billing details of an order.

        coupons : typing.Optional[typing.Sequence[str]]
            Coupons applied to the order. Stored case insensitive.

        identifiers : typing.Optional[OrderIdentifiers]
            Identifies the contact associated with the order.

        meta_info : typing.Optional[typing.Dict[str, OrderMetaInfoValue]]
            Meta data of order to store additional detal such as custom message, customer type, source.

        store_id : typing.Optional[str]
            ID of store where the order is placed

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            "orders/status",
            method="POST",
            json={
                "amount": amount,
                "billing": convert_and_respect_annotation_metadata(
                    object_=billing, annotation=OrderBilling, direction="write"
                ),
                "coupons": coupons,
                "createdAt": created_at,
                "id": id,
                "identifiers": convert_and_respect_annotation_metadata(
                    object_=identifiers, annotation=OrderIdentifiers, direction="write"
                ),
                "metaInfo": convert_and_respect_annotation_metadata(
                    object_=meta_info, annotation=typing.Dict[str, OrderMetaInfoValue], direction="write"
                ),
                "products": convert_and_respect_annotation_metadata(
                    object_=products, annotation=typing.Sequence[OrderProductsItem], direction="write"
                ),
                "status": status,
                "storeId": store_id,
                "updatedAt": updated_at,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def create_batch_order(
        self,
        *,
        orders: typing.Sequence[Order],
        historical: typing.Optional[bool] = OMIT,
        notify_url: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[CreateBatchOrderResponse]:
        """
        Create multiple orders at one time instead of one order at a time

        Parameters
        ----------
        orders : typing.Sequence[Order]
            array of order objects

        historical : typing.Optional[bool]
            Defines wether you want your orders to be considered as live data or as historical data (import of past data, synchronising data). True: orders will not trigger any automation workflows. False: orders will trigger workflows as usual.

        notify_url : typing.Optional[str]
            Notify Url provided by client_dev to get the status of batch request

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[CreateBatchOrderResponse]
            batch id created
        """
        _response = self._client_wrapper.httpx_client.request(
            "orders/status/batch",
            method="POST",
            json={
                "historical": historical,
                "notifyUrl": notify_url,
                "orders": convert_and_respect_annotation_metadata(
                    object_=orders, annotation=typing.Sequence[Order], direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CreateBatchOrderResponse,
                    construct_type(
                        type_=CreateBatchOrderResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_products(
        self,
        *,
        limit: typing.Optional[int] = None,
        offset: typing.Optional[int] = None,
        sort: typing.Optional[GetProductsRequestSort] = None,
        ids: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        name: typing.Optional[str] = None,
        price_lte: typing.Optional[float] = None,
        price_gte: typing.Optional[float] = None,
        price_lt: typing.Optional[float] = None,
        price_gt: typing.Optional[float] = None,
        price_eq: typing.Optional[float] = None,
        price_ne: typing.Optional[float] = None,
        categories: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        modified_since: typing.Optional[str] = None,
        created_since: typing.Optional[str] = None,
        is_deleted: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[GetProductsResponse]:
        """
        Parameters
        ----------
        limit : typing.Optional[int]
            Number of documents per page

        offset : typing.Optional[int]
            Index of the first document in the page

        sort : typing.Optional[GetProductsRequestSort]
            Sort the results in the ascending/descending order of record creation. Default order is **descending** if `sort` is not passed

        ids : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            Filter by product ids

        name : typing.Optional[str]
            Filter by product name, minimum 3 characters should be present for search.

        price_lte : typing.Optional[float]
            Price filter for products less than and equals to particular amount

        price_gte : typing.Optional[float]
            Price filter for products greater than and equals to particular amount

        price_lt : typing.Optional[float]
            Price filter for products less than particular amount

        price_gt : typing.Optional[float]
            Price filter for products greater than particular amount

        price_eq : typing.Optional[float]
            Price filter for products equals to particular amount

        price_ne : typing.Optional[float]
            Price filter for products not equals to particular amount

        categories : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            Filter by categories ids

        modified_since : typing.Optional[str]
            Filter (urlencoded) the orders modified after a given UTC date-time (YYYY-MM-DDTHH:mm:ss.SSSZ). **Prefer to pass your timezone in date-time format for accurate result.**

        created_since : typing.Optional[str]
            Filter (urlencoded) the orders created after a given UTC date-time (YYYY-MM-DDTHH:mm:ss.SSSZ). **Prefer to pass your timezone in date-time format for accurate result.**

        is_deleted : typing.Optional[str]
            Filter products by their deletion status. If `false` is passed, only products that are not deleted will be returned.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetProductsResponse]
            All products listed
        """
        _response = self._client_wrapper.httpx_client.request(
            "products",
            method="GET",
            params={
                "limit": limit,
                "offset": offset,
                "sort": sort,
                "ids": ids,
                "name": name,
                "price[lte]": price_lte,
                "price[gte]": price_gte,
                "price[lt]": price_lt,
                "price[gt]": price_gt,
                "price[eq]": price_eq,
                "price[ne]": price_ne,
                "categories": categories,
                "modifiedSince": modified_since,
                "createdSince": created_since,
                "isDeleted": is_deleted,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetProductsResponse,
                    construct_type(
                        type_=GetProductsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def create_update_product(
        self,
        *,
        id: str,
        name: str,
        categories: typing.Optional[typing.Sequence[str]] = OMIT,
        deleted_at: typing.Optional[str] = OMIT,
        image_url: typing.Optional[str] = OMIT,
        is_deleted: typing.Optional[bool] = OMIT,
        meta_info: typing.Optional[typing.Dict[str, CreateUpdateProductRequestMetaInfoValue]] = OMIT,
        parent_id: typing.Optional[str] = OMIT,
        price: typing.Optional[float] = OMIT,
        sku: typing.Optional[str] = OMIT,
        stock: typing.Optional[float] = OMIT,
        update_enabled: typing.Optional[bool] = OMIT,
        url: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[CreateUpdateProductResponse]:
        """
        Parameters
        ----------
        id : str
            Product ID for which you requested the details

        name : str
            Mandatory in case of creation**. Name of the product for which you requested the details

        categories : typing.Optional[typing.Sequence[str]]
            Category ID-s of the product

        deleted_at : typing.Optional[str]
            UTC date-time (YYYY-MM-DDTHH:mm:ss.SSSZ) of the product deleted from the shop's database

        image_url : typing.Optional[str]
            Absolute URL to the cover image of the product

        is_deleted : typing.Optional[bool]
            product deleted from the shop's database

        meta_info : typing.Optional[typing.Dict[str, CreateUpdateProductRequestMetaInfoValue]]
            Meta data of product such as description, vendor, producer, stock level. The size of cumulative metaInfo shall not exceed **1000 KB**. Maximum length of metaInfo object can be 20.

        parent_id : typing.Optional[str]
            Parent product id of the product

        price : typing.Optional[float]
            Price of the product

        sku : typing.Optional[str]
            Product identifier from the shop

        stock : typing.Optional[float]
            Current stock value of the product from the shop's database

        update_enabled : typing.Optional[bool]
            Facilitate to update the existing category in the same request (updateEnabled = true)

        url : typing.Optional[str]
            URL to the product

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[CreateUpdateProductResponse]
            Product created
        """
        _response = self._client_wrapper.httpx_client.request(
            "products",
            method="POST",
            json={
                "categories": categories,
                "deletedAt": deleted_at,
                "id": id,
                "imageUrl": image_url,
                "isDeleted": is_deleted,
                "metaInfo": convert_and_respect_annotation_metadata(
                    object_=meta_info,
                    annotation=typing.Dict[str, CreateUpdateProductRequestMetaInfoValue],
                    direction="write",
                ),
                "name": name,
                "parentId": parent_id,
                "price": price,
                "sku": sku,
                "stock": stock,
                "updateEnabled": update_enabled,
                "url": url,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CreateUpdateProductResponse,
                    construct_type(
                        type_=CreateUpdateProductResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def create_update_batch_products(
        self,
        *,
        products: typing.Sequence[CreateUpdateBatchProductsRequestProductsItem],
        update_enabled: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[CreateUpdateBatchProductsResponse]:
        """
        Parameters
        ----------
        products : typing.Sequence[CreateUpdateBatchProductsRequestProductsItem]
            array of products objects

        update_enabled : typing.Optional[bool]
            Facilitate to update the existing categories in the same request (updateEnabled = true)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[CreateUpdateBatchProductsResponse]
            Products created and updated
        """
        _response = self._client_wrapper.httpx_client.request(
            "products/batch",
            method="POST",
            json={
                "products": convert_and_respect_annotation_metadata(
                    object_=products,
                    annotation=typing.Sequence[CreateUpdateBatchProductsRequestProductsItem],
                    direction="write",
                ),
                "updateEnabled": update_enabled,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CreateUpdateBatchProductsResponse,
                    construct_type(
                        type_=CreateUpdateBatchProductsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_product_info(
        self, id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[GetProductDetails]:
        """
        Parameters
        ----------
        id : str
            Product ID

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetProductDetails]
            Product informations
        """
        _response = self._client_wrapper.httpx_client.request(
            f"products/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetProductDetails,
                    construct_type(
                        type_=GetProductDetails,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def create_product_alert(
        self,
        id: str,
        *,
        contact_identifiers: typing.Optional[CreateProductAlertRequestContactIdentifiers] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        id : str
            Product ID

        contact_identifiers : typing.Optional[CreateProductAlertRequestContactIdentifiers]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"products/{jsonable_encoder(id)}/alerts/back_in_stock",
            method="POST",
            json={
                "contactIdentifiers": convert_and_respect_annotation_metadata(
                    object_=contact_identifiers,
                    annotation=CreateProductAlertRequestContactIdentifiers,
                    direction="write",
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawEcommerceClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def get_categories(
        self,
        *,
        limit: typing.Optional[int] = None,
        offset: typing.Optional[int] = None,
        sort: typing.Optional[GetCategoriesRequestSort] = None,
        ids: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        name: typing.Optional[str] = None,
        modified_since: typing.Optional[str] = None,
        created_since: typing.Optional[str] = None,
        is_deleted: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[GetCategoriesResponse]:
        """
        Parameters
        ----------
        limit : typing.Optional[int]
            Number of documents per page

        offset : typing.Optional[int]
            Index of the first document in the page

        sort : typing.Optional[GetCategoriesRequestSort]
            Sort the results in the ascending/descending order of record creation. Default order is **descending** if `sort` is not passed

        ids : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            Filter by category ids

        name : typing.Optional[str]
            Filter by category name

        modified_since : typing.Optional[str]
            Filter (urlencoded) the categories modified after a given UTC date-time (YYYY-MM-DDTHH:mm:ss.SSSZ). **Prefer to pass your timezone in date-time format for accurate result.**

        created_since : typing.Optional[str]
            Filter (urlencoded) the categories created after a given UTC date-time (YYYY-MM-DDTHH:mm:ss.SSSZ). **Prefer to pass your timezone in date-time format for accurate result.**

        is_deleted : typing.Optional[str]
            Filter categories by their deletion status. If `false` is passed, only categories that are not deleted will be returned.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetCategoriesResponse]
            All categories listed
        """
        _response = await self._client_wrapper.httpx_client.request(
            "categories",
            method="GET",
            params={
                "limit": limit,
                "offset": offset,
                "sort": sort,
                "ids": ids,
                "name": name,
                "modifiedSince": modified_since,
                "createdSince": created_since,
                "isDeleted": is_deleted,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetCategoriesResponse,
                    construct_type(
                        type_=GetCategoriesResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def create_update_category(
        self,
        *,
        id: str,
        deleted_at: typing.Optional[str] = OMIT,
        is_deleted: typing.Optional[bool] = OMIT,
        name: typing.Optional[str] = OMIT,
        update_enabled: typing.Optional[bool] = OMIT,
        url: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[CreateUpdateCategoryResponse]:
        """
        Parameters
        ----------
        id : str
            Unique Category ID as saved in the shop

        deleted_at : typing.Optional[str]
            UTC date-time (YYYY-MM-DDTHH:mm:ss.SSSZ) of the category deleted from the shop's database

        is_deleted : typing.Optional[bool]
            category deleted from the shop's database

        name : typing.Optional[str]
            **Mandatory in case of creation**. Name of the Category, as displayed in the shop

        update_enabled : typing.Optional[bool]
            Facilitate to update the existing category in the same request (updateEnabled = true)

        url : typing.Optional[str]
            URL to the category

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[CreateUpdateCategoryResponse]
            Category created
        """
        _response = await self._client_wrapper.httpx_client.request(
            "categories",
            method="POST",
            json={
                "deletedAt": deleted_at,
                "id": id,
                "isDeleted": is_deleted,
                "name": name,
                "updateEnabled": update_enabled,
                "url": url,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CreateUpdateCategoryResponse,
                    construct_type(
                        type_=CreateUpdateCategoryResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def create_update_batch_category(
        self,
        *,
        categories: typing.Sequence[CreateUpdateBatchCategoryRequestCategoriesItem],
        update_enabled: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[CreateUpdateBatchCategoryResponse]:
        """
        Parameters
        ----------
        categories : typing.Sequence[CreateUpdateBatchCategoryRequestCategoriesItem]
            array of categories objects

        update_enabled : typing.Optional[bool]
            Facilitate to update the existing categories in the same request (updateEnabled = true)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[CreateUpdateBatchCategoryResponse]
            Category created and updated
        """
        _response = await self._client_wrapper.httpx_client.request(
            "categories/batch",
            method="POST",
            json={
                "categories": convert_and_respect_annotation_metadata(
                    object_=categories,
                    annotation=typing.Sequence[CreateUpdateBatchCategoryRequestCategoriesItem],
                    direction="write",
                ),
                "updateEnabled": update_enabled,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CreateUpdateBatchCategoryResponse,
                    construct_type(
                        type_=CreateUpdateBatchCategoryResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_category_info(
        self, id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[GetCategoryDetails]:
        """
        Parameters
        ----------
        id : str
            Category ID

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetCategoryDetails]
            Category informations
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"categories/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetCategoryDetails,
                    construct_type(
                        type_=GetCategoryDetails,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def activate_the_e_commerce_app(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[None]:
        """
        Getting access to Brevo eCommerce.

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            "ecommerce/activate",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_attribution_metrics_for_one_or_more_brevo_campaigns_or_workflows(
        self,
        *,
        period_from: typing.Optional[dt.datetime] = None,
        period_to: typing.Optional[dt.datetime] = None,
        email_campaign_id_array: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        sms_campaign_id_array: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        automation_workflow_email_id_array: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        automation_workflow_sms_id_array: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[GetEcommerceAttributionMetricsResponse]:
        """
        Parameters
        ----------
        period_from : typing.Optional[dt.datetime]
            When getting metrics for a specific period, define the starting datetime in RFC3339 format

        period_to : typing.Optional[dt.datetime]
            When getting metrics for a specific period, define the end datetime in RFC3339 format

        email_campaign_id_array : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            The email campaign ID(s) to get metrics for

        sms_campaign_id_array : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            The SMS campaign ID(s) to get metrics for

        automation_workflow_email_id_array : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            The automation workflow ID(s) to get email attribution metrics for

        automation_workflow_sms_id_array : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            The automation workflow ID(s) to get SMS attribution metrics for

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetEcommerceAttributionMetricsResponse]
            OK
        """
        _response = await self._client_wrapper.httpx_client.request(
            "ecommerce/attribution/metrics",
            method="GET",
            params={
                "periodFrom": serialize_datetime(period_from) if period_from is not None else None,
                "periodTo": serialize_datetime(period_to) if period_to is not None else None,
                "emailCampaignId[]": email_campaign_id_array,
                "smsCampaignId[]": sms_campaign_id_array,
                "automationWorkflowEmailId[]": automation_workflow_email_id_array,
                "automationWorkflowSmsId[]": automation_workflow_sms_id_array,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetEcommerceAttributionMetricsResponse,
                    construct_type(
                        type_=GetEcommerceAttributionMetricsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_detailed_attribution_metrics_for_a_single_brevo_campaign_or_workflow(
        self,
        conversion_source: GetEcommerceAttributionMetricsConversionSourceConversionSourceIdRequestConversionSource,
        conversion_source_id: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[GetEcommerceAttributionMetricsConversionSourceConversionSourceIdResponse]:
        """
        Parameters
        ----------
        conversion_source : GetEcommerceAttributionMetricsConversionSourceConversionSourceIdRequestConversionSource
            The Brevo campaign type or workflow type for which data will be retrieved

        conversion_source_id : str
            The Brevo campaign or automation workflow id for which data will be retrieved

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetEcommerceAttributionMetricsConversionSourceConversionSourceIdResponse]
            OK
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"ecommerce/attribution/metrics/{jsonable_encoder(conversion_source)}/{jsonable_encoder(conversion_source_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetEcommerceAttributionMetricsConversionSourceConversionSourceIdResponse,
                    construct_type(
                        type_=GetEcommerceAttributionMetricsConversionSourceConversionSourceIdResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_attributed_product_sales_for_a_single_brevo_campaign_or_workflow(
        self,
        conversion_source: GetEcommerceAttributionProductsConversionSourceConversionSourceIdRequestConversionSource,
        conversion_source_id: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[GetEcommerceAttributionProductsConversionSourceConversionSourceIdResponse]:
        """
        Parameters
        ----------
        conversion_source : GetEcommerceAttributionProductsConversionSourceConversionSourceIdRequestConversionSource
            The Brevo campaign or automation workflow type for which data will be retrieved

        conversion_source_id : str
            The Brevo campaign or automation workflow id for which data will be retrieved

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetEcommerceAttributionProductsConversionSourceConversionSourceIdResponse]
            OK
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"ecommerce/attribution/products/{jsonable_encoder(conversion_source)}/{jsonable_encoder(conversion_source_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetEcommerceAttributionProductsConversionSourceConversionSourceIdResponse,
                    construct_type(
                        type_=GetEcommerceAttributionProductsConversionSourceConversionSourceIdResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_the_iso4217compliant_display_currency_code_for_your_brevo_account(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[GetEcommerceConfigDisplayCurrencyResponse]:
        """
        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetEcommerceConfigDisplayCurrencyResponse]
            OK
        """
        _response = await self._client_wrapper.httpx_client.request(
            "ecommerce/config/displayCurrency",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetEcommerceConfigDisplayCurrencyResponse,
                    construct_type(
                        type_=GetEcommerceConfigDisplayCurrencyResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def set_config_display_currency(
        self, *, code: str, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[SetConfigDisplayCurrencyResponse]:
        """
        Parameters
        ----------
        code : str
            ISO 4217 compliant display currency code

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[SetConfigDisplayCurrencyResponse]
            OK
        """
        _response = await self._client_wrapper.httpx_client.request(
            "ecommerce/config/displayCurrency",
            method="POST",
            json={
                "code": code,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SetConfigDisplayCurrencyResponse,
                    construct_type(
                        type_=SetConfigDisplayCurrencyResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorModel,
                        construct_type(
                            type_=ErrorModel,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_orders(
        self,
        *,
        limit: typing.Optional[int] = None,
        offset: typing.Optional[int] = None,
        sort: typing.Optional[GetOrdersRequestSort] = None,
        modified_since: typing.Optional[str] = None,
        created_since: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.Any]:
        """
        Get all the orders

        Parameters
        ----------
        limit : typing.Optional[int]
            Number of documents per page

        offset : typing.Optional[int]
            Index of the first document in the page

        sort : typing.Optional[GetOrdersRequestSort]
            Sort the results in the ascending/descending order of record creation. Default order is **descending** if `sort` is not passed

        modified_since : typing.Optional[str]
            Filter (urlencoded) the orders modified after a given UTC date-time (YYYY-MM-DDTHH:mm:ss.SSSZ). **Prefer to pass your timezone in date-time format for accurate result.**

        created_since : typing.Optional[str]
            Filter (urlencoded) the orders created after a given UTC date-time (YYYY-MM-DDTHH:mm:ss.SSSZ). **Prefer to pass your timezone in date-time format for accurate result.**

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.Any]
            orders fetched successfully
        """
        _response = await self._client_wrapper.httpx_client.request(
            "orders",
            method="GET",
            params={
                "limit": limit,
                "offset": offset,
                "sort": sort,
                "modifiedSince": modified_since,
                "createdSince": created_since,
            },
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return AsyncHttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Any,
                    construct_type(
                        type_=typing.Any,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def create_order(
        self,
        *,
        amount: float,
        created_at: str,
        id: str,
        products: typing.Sequence[OrderProductsItem],
        status: str,
        updated_at: str,
        billing: typing.Optional[OrderBilling] = OMIT,
        coupons: typing.Optional[typing.Sequence[str]] = OMIT,
        identifiers: typing.Optional[OrderIdentifiers] = OMIT,
        meta_info: typing.Optional[typing.Dict[str, OrderMetaInfoValue]] = OMIT,
        store_id: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Manages the transactional status of the order

        Parameters
        ----------
        amount : float
            Total amount of the order, including all shipping expenses, tax and the price of items.

        created_at : str
            Event occurrence UTC date-time (YYYY-MM-DDTHH:mm:ssZ), when order is actually created.

        id : str
            Unique ID of the order.

        products : typing.Sequence[OrderProductsItem]

        status : str
            State of the order.

        updated_at : str
            Event updated UTC date-time (YYYY-MM-DDTHH:mm:ssZ), when the status of the order is actually changed/updated.

        billing : typing.Optional[OrderBilling]
            Billing details of an order.

        coupons : typing.Optional[typing.Sequence[str]]
            Coupons applied to the order. Stored case insensitive.

        identifiers : typing.Optional[OrderIdentifiers]
            Identifies the contact associated with the order.

        meta_info : typing.Optional[typing.Dict[str, OrderMetaInfoValue]]
            Meta data of order to store additional detal such as custom message, customer type, source.

        store_id : typing.Optional[str]
            ID of store where the order is placed

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            "orders/status",
            method="POST",
            json={
                "amount": amount,
                "billing": convert_and_respect_annotation_metadata(
                    object_=billing, annotation=OrderBilling, direction="write"
                ),
                "coupons": coupons,
                "createdAt": created_at,
                "id": id,
                "identifiers": convert_and_respect_annotation_metadata(
                    object_=identifiers, annotation=OrderIdentifiers, direction="write"
                ),
                "metaInfo": convert_and_respect_annotation_metadata(
                    object_=meta_info, annotation=typing.Dict[str, OrderMetaInfoValue], direction="write"
                ),
                "products": convert_and_respect_annotation_metadata(
                    object_=products, annotation=typing.Sequence[OrderProductsItem], direction="write"
                ),
                "status": status,
                "storeId": store_id,
                "updatedAt": updated_at,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def create_batch_order(
        self,
        *,
        orders: typing.Sequence[Order],
        historical: typing.Optional[bool] = OMIT,
        notify_url: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[CreateBatchOrderResponse]:
        """
        Create multiple orders at one time instead of one order at a time

        Parameters
        ----------
        orders : typing.Sequence[Order]
            array of order objects

        historical : typing.Optional[bool]
            Defines wether you want your orders to be considered as live data or as historical data (import of past data, synchronising data). True: orders will not trigger any automation workflows. False: orders will trigger workflows as usual.

        notify_url : typing.Optional[str]
            Notify Url provided by client_dev to get the status of batch request

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[CreateBatchOrderResponse]
            batch id created
        """
        _response = await self._client_wrapper.httpx_client.request(
            "orders/status/batch",
            method="POST",
            json={
                "historical": historical,
                "notifyUrl": notify_url,
                "orders": convert_and_respect_annotation_metadata(
                    object_=orders, annotation=typing.Sequence[Order], direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CreateBatchOrderResponse,
                    construct_type(
                        type_=CreateBatchOrderResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_products(
        self,
        *,
        limit: typing.Optional[int] = None,
        offset: typing.Optional[int] = None,
        sort: typing.Optional[GetProductsRequestSort] = None,
        ids: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        name: typing.Optional[str] = None,
        price_lte: typing.Optional[float] = None,
        price_gte: typing.Optional[float] = None,
        price_lt: typing.Optional[float] = None,
        price_gt: typing.Optional[float] = None,
        price_eq: typing.Optional[float] = None,
        price_ne: typing.Optional[float] = None,
        categories: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        modified_since: typing.Optional[str] = None,
        created_since: typing.Optional[str] = None,
        is_deleted: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[GetProductsResponse]:
        """
        Parameters
        ----------
        limit : typing.Optional[int]
            Number of documents per page

        offset : typing.Optional[int]
            Index of the first document in the page

        sort : typing.Optional[GetProductsRequestSort]
            Sort the results in the ascending/descending order of record creation. Default order is **descending** if `sort` is not passed

        ids : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            Filter by product ids

        name : typing.Optional[str]
            Filter by product name, minimum 3 characters should be present for search.

        price_lte : typing.Optional[float]
            Price filter for products less than and equals to particular amount

        price_gte : typing.Optional[float]
            Price filter for products greater than and equals to particular amount

        price_lt : typing.Optional[float]
            Price filter for products less than particular amount

        price_gt : typing.Optional[float]
            Price filter for products greater than particular amount

        price_eq : typing.Optional[float]
            Price filter for products equals to particular amount

        price_ne : typing.Optional[float]
            Price filter for products not equals to particular amount

        categories : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            Filter by categories ids

        modified_since : typing.Optional[str]
            Filter (urlencoded) the orders modified after a given UTC date-time (YYYY-MM-DDTHH:mm:ss.SSSZ). **Prefer to pass your timezone in date-time format for accurate result.**

        created_since : typing.Optional[str]
            Filter (urlencoded) the orders created after a given UTC date-time (YYYY-MM-DDTHH:mm:ss.SSSZ). **Prefer to pass your timezone in date-time format for accurate result.**

        is_deleted : typing.Optional[str]
            Filter products by their deletion status. If `false` is passed, only products that are not deleted will be returned.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetProductsResponse]
            All products listed
        """
        _response = await self._client_wrapper.httpx_client.request(
            "products",
            method="GET",
            params={
                "limit": limit,
                "offset": offset,
                "sort": sort,
                "ids": ids,
                "name": name,
                "price[lte]": price_lte,
                "price[gte]": price_gte,
                "price[lt]": price_lt,
                "price[gt]": price_gt,
                "price[eq]": price_eq,
                "price[ne]": price_ne,
                "categories": categories,
                "modifiedSince": modified_since,
                "createdSince": created_since,
                "isDeleted": is_deleted,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetProductsResponse,
                    construct_type(
                        type_=GetProductsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def create_update_product(
        self,
        *,
        id: str,
        name: str,
        categories: typing.Optional[typing.Sequence[str]] = OMIT,
        deleted_at: typing.Optional[str] = OMIT,
        image_url: typing.Optional[str] = OMIT,
        is_deleted: typing.Optional[bool] = OMIT,
        meta_info: typing.Optional[typing.Dict[str, CreateUpdateProductRequestMetaInfoValue]] = OMIT,
        parent_id: typing.Optional[str] = OMIT,
        price: typing.Optional[float] = OMIT,
        sku: typing.Optional[str] = OMIT,
        stock: typing.Optional[float] = OMIT,
        update_enabled: typing.Optional[bool] = OMIT,
        url: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[CreateUpdateProductResponse]:
        """
        Parameters
        ----------
        id : str
            Product ID for which you requested the details

        name : str
            Mandatory in case of creation**. Name of the product for which you requested the details

        categories : typing.Optional[typing.Sequence[str]]
            Category ID-s of the product

        deleted_at : typing.Optional[str]
            UTC date-time (YYYY-MM-DDTHH:mm:ss.SSSZ) of the product deleted from the shop's database

        image_url : typing.Optional[str]
            Absolute URL to the cover image of the product

        is_deleted : typing.Optional[bool]
            product deleted from the shop's database

        meta_info : typing.Optional[typing.Dict[str, CreateUpdateProductRequestMetaInfoValue]]
            Meta data of product such as description, vendor, producer, stock level. The size of cumulative metaInfo shall not exceed **1000 KB**. Maximum length of metaInfo object can be 20.

        parent_id : typing.Optional[str]
            Parent product id of the product

        price : typing.Optional[float]
            Price of the product

        sku : typing.Optional[str]
            Product identifier from the shop

        stock : typing.Optional[float]
            Current stock value of the product from the shop's database

        update_enabled : typing.Optional[bool]
            Facilitate to update the existing category in the same request (updateEnabled = true)

        url : typing.Optional[str]
            URL to the product

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[CreateUpdateProductResponse]
            Product created
        """
        _response = await self._client_wrapper.httpx_client.request(
            "products",
            method="POST",
            json={
                "categories": categories,
                "deletedAt": deleted_at,
                "id": id,
                "imageUrl": image_url,
                "isDeleted": is_deleted,
                "metaInfo": convert_and_respect_annotation_metadata(
                    object_=meta_info,
                    annotation=typing.Dict[str, CreateUpdateProductRequestMetaInfoValue],
                    direction="write",
                ),
                "name": name,
                "parentId": parent_id,
                "price": price,
                "sku": sku,
                "stock": stock,
                "updateEnabled": update_enabled,
                "url": url,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CreateUpdateProductResponse,
                    construct_type(
                        type_=CreateUpdateProductResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def create_update_batch_products(
        self,
        *,
        products: typing.Sequence[CreateUpdateBatchProductsRequestProductsItem],
        update_enabled: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[CreateUpdateBatchProductsResponse]:
        """
        Parameters
        ----------
        products : typing.Sequence[CreateUpdateBatchProductsRequestProductsItem]
            array of products objects

        update_enabled : typing.Optional[bool]
            Facilitate to update the existing categories in the same request (updateEnabled = true)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[CreateUpdateBatchProductsResponse]
            Products created and updated
        """
        _response = await self._client_wrapper.httpx_client.request(
            "products/batch",
            method="POST",
            json={
                "products": convert_and_respect_annotation_metadata(
                    object_=products,
                    annotation=typing.Sequence[CreateUpdateBatchProductsRequestProductsItem],
                    direction="write",
                ),
                "updateEnabled": update_enabled,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CreateUpdateBatchProductsResponse,
                    construct_type(
                        type_=CreateUpdateBatchProductsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_product_info(
        self, id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[GetProductDetails]:
        """
        Parameters
        ----------
        id : str
            Product ID

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetProductDetails]
            Product informations
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"products/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetProductDetails,
                    construct_type(
                        type_=GetProductDetails,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def create_product_alert(
        self,
        id: str,
        *,
        contact_identifiers: typing.Optional[CreateProductAlertRequestContactIdentifiers] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        id : str
            Product ID

        contact_identifiers : typing.Optional[CreateProductAlertRequestContactIdentifiers]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"products/{jsonable_encoder(id)}/alerts/back_in_stock",
            method="POST",
            json={
                "contactIdentifiers": convert_and_respect_annotation_metadata(
                    object_=contact_identifiers,
                    annotation=CreateProductAlertRequestContactIdentifiers,
                    direction="write",
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)
